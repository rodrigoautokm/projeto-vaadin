{
  "version": 3,
  "sources": ["../../@vaadin/component-base/src/gestures.js"],
  "sourcesContent": ["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * Module for adding listeners to a node for the following normalized\n * cross-platform \"gesture\" events:\n * - `down` - mouse or touch went down\n * - `up` - mouse or touch went up\n * - `tap` - mouse click or finger tap\n * - `track` - mouse drag or touch move\n *\n * @summary Module for adding cross-platform gesture event listeners.\n */\n\nimport { microTask } from './async.js';\n\nconst passiveTouchGestures = false;\nconst wrap = (node) => node;\n\n// Detect native touch action support\nconst HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\nconst GESTURE_KEY = '__polymerGestures';\nconst HANDLED_OBJ = '__polymerGesturesHandled';\nconst TOUCH_ACTION = '__polymerGesturesTouchAction';\n// Radius for tap and track\nconst TAP_DISTANCE = 25;\nconst TRACK_DISTANCE = 5;\n// Number of last N track positions to keep\nconst TRACK_LENGTH = 2;\n\nconst MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];\n// An array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons\nconst MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];\nconst MOUSE_HAS_BUTTONS = (function () {\n  try {\n    return new MouseEvent('test', { buttons: 1 }).buttons === 1;\n  } catch (e) {\n    return false;\n  }\n})();\n\n/**\n * @param {string} name Possible mouse event name\n * @return {boolean} true if mouse event, false if not\n */\nfunction isMouseEvent(name) {\n  return MOUSE_EVENTS.indexOf(name) > -1;\n}\n\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n// check for passive event listeners\nlet supportsPassive = false;\n(function () {\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      // eslint-disable-next-line getter-return\n      get() {\n        supportsPassive = true;\n      },\n    });\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch (e) {}\n})();\n\n/**\n * Generate settings for event listeners, dependant on `passiveTouchGestures`\n *\n * @param {string} eventName Event name to determine if `{passive}` option is\n *   needed\n * @return {{passive: boolean} | undefined} Options to use for addEventListener\n *   and removeEventListener\n */\nfunction PASSIVE_TOUCH(eventName) {\n  if (isMouseEvent(eventName) || eventName === 'touchend') {\n    return;\n  }\n  if (HAS_NATIVE_TA && supportsPassive && passiveTouchGestures) {\n    return { passive: true };\n  }\n}\n\n// Check for touch-only devices\nconst IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);\n\n// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute\n/** @type {!Object<boolean>} */\nconst canBeDisabled = {\n  button: true,\n  command: true,\n  fieldset: true,\n  input: true,\n  keygen: true,\n  optgroup: true,\n  option: true,\n  select: true,\n  textarea: true,\n};\n\n/**\n * @param {MouseEvent} ev event to test for left mouse button down\n * @return {boolean} has left mouse button down\n */\nfunction hasLeftMouseButton(ev) {\n  const type = ev.type;\n  // Exit early if the event is not a mouse event\n  if (!isMouseEvent(type)) {\n    return false;\n  }\n  // Ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)\n  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)\n  if (type === 'mousemove') {\n    // Allow undefined for testing events\n    let buttons = ev.buttons === undefined ? 1 : ev.buttons;\n    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {\n      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\n    }\n    // Buttons is a bitmask, check that the left button bit is set (1)\n    return Boolean(buttons & 1);\n  }\n  // Allow undefined for testing events\n  const button = ev.button === undefined ? 0 : ev.button;\n  // Ev.button is 0 in mousedown/mouseup/click for left button activation\n  return button === 0;\n}\n\nfunction isSyntheticClick(ev) {\n  if (ev.type === 'click') {\n    // Ev.detail is 0 for HTMLElement.click in most browsers\n    if (ev.detail === 0) {\n      return true;\n    }\n    // In the worst case, check that the x/y position of the click is within\n    // the bounding box of the target of the event\n    // Thanks IE 10 >:(\n    const t = _findOriginalTarget(ev);\n    // Make sure the target of the event is an element so we can use getBoundingClientRect,\n    // if not, just assume it is a synthetic click\n    if (!t.nodeType || /** @type {Element} */ (t).nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n    const bcr = /** @type {Element} */ (t).getBoundingClientRect();\n    // Use page x/y to account for scrolling\n    const x = ev.pageX,\n      y = ev.pageY;\n    // Ev is a synthetic click if the position is outside the bounding box of the target\n    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);\n  }\n  return false;\n}\n\nconst POINTERSTATE = {\n  mouse: {\n    target: null,\n    mouseIgnoreJob: null,\n  },\n  touch: {\n    x: 0,\n    y: 0,\n    id: -1,\n    scrollDecided: false,\n  },\n};\n\nfunction firstTouchAction(ev) {\n  let ta = 'auto';\n  const path = getComposedPath(ev);\n  for (let i = 0, n; i < path.length; i++) {\n    n = path[i];\n    if (n[TOUCH_ACTION]) {\n      ta = n[TOUCH_ACTION];\n      break;\n    }\n  }\n  return ta;\n}\n\nfunction trackDocument(stateObj, movefn, upfn) {\n  stateObj.movefn = movefn;\n  stateObj.upfn = upfn;\n  document.addEventListener('mousemove', movefn);\n  document.addEventListener('mouseup', upfn);\n}\n\nfunction untrackDocument(stateObj) {\n  document.removeEventListener('mousemove', stateObj.movefn);\n  document.removeEventListener('mouseup', stateObj.upfn);\n  stateObj.movefn = null;\n  stateObj.upfn = null;\n}\n\n/**\n * Returns the composedPath for the given event.\n * @param {Event} event to process\n * @return {!Array<!EventTarget>} Path of the event\n */\nconst getComposedPath =\n  window.ShadyDOM && window.ShadyDOM.noPatch\n    ? window.ShadyDOM.composedPath\n    : (event) => (event.composedPath && event.composedPath()) || [];\n\n/** @type {!Object<string, !GestureRecognizer>} */\nexport const gestures = {};\n\n/** @type {!Array<!GestureRecognizer>} */\nexport const recognizers = [];\n\n/**\n * Finds the element rendered on the screen at the provided coordinates.\n *\n * Similar to `document.elementFromPoint`, but pierces through\n * shadow roots.\n *\n * @param {number} x Horizontal pixel coordinate\n * @param {number} y Vertical pixel coordinate\n * @return {Element} Returns the deepest shadowRoot inclusive element\n * found at the screen position given.\n */\nexport function deepTargetFind(x, y) {\n  let node = document.elementFromPoint(x, y);\n  let next = node;\n  // This code path is only taken when native ShadowDOM is used\n  // if there is a shadowroot, it may have a node at x/y\n  // if there is not a shadowroot, exit the loop\n  while (next && next.shadowRoot && !window.ShadyDOM) {\n    // If there is a node at x/y in the shadowroot, look deeper\n    const oldNext = next;\n    next = next.shadowRoot.elementFromPoint(x, y);\n    // On Safari, elementFromPoint may return the shadowRoot host\n    if (oldNext === next) {\n      break;\n    }\n    if (next) {\n      node = next;\n    }\n  }\n  return node;\n}\n\n/**\n * A cheaper check than ev.composedPath()[0];\n *\n * @private\n * @param {Event|Touch} ev Event.\n * @return {EventTarget} Returns the event target.\n */\nfunction _findOriginalTarget(ev) {\n  const path = getComposedPath(/** @type {?Event} */ (ev));\n  // It shouldn't be, but sometimes path is empty (window on Safari).\n  return path.length > 0 ? path[0] : ev.target;\n}\n\n/**\n * @private\n * @param {Event} ev Event.\n * @return {void}\n */\nfunction _handleNative(ev) {\n  const type = ev.type;\n  const node = ev.currentTarget;\n  const gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    return;\n  }\n  const gs = gobj[type];\n  if (!gs) {\n    return;\n  }\n  if (!ev[HANDLED_OBJ]) {\n    ev[HANDLED_OBJ] = {};\n    if (type.startsWith('touch')) {\n      const t = ev.changedTouches[0];\n      if (type === 'touchstart') {\n        // Only handle the first finger\n        if (ev.touches.length === 1) {\n          POINTERSTATE.touch.id = t.identifier;\n        }\n      }\n      if (POINTERSTATE.touch.id !== t.identifier) {\n        return;\n      }\n      if (!HAS_NATIVE_TA) {\n        if (type === 'touchstart' || type === 'touchmove') {\n          _handleTouchAction(ev);\n        }\n      }\n    }\n  }\n  const handled = ev[HANDLED_OBJ];\n  // Used to ignore synthetic mouse events\n  if (handled.skip) {\n    return;\n  }\n  // Reset recognizer state\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\n        r.reset();\n      }\n    }\n  }\n  // Enforce gesture recognizer order\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      handled[r.name] = true;\n      r[type](ev);\n    }\n  }\n}\n\n/**\n * @private\n * @param {TouchEvent} ev Event.\n * @return {void}\n */\nfunction _handleTouchAction(ev) {\n  const t = ev.changedTouches[0];\n  const type = ev.type;\n  if (type === 'touchstart') {\n    POINTERSTATE.touch.x = t.clientX;\n    POINTERSTATE.touch.y = t.clientY;\n    POINTERSTATE.touch.scrollDecided = false;\n  } else if (type === 'touchmove') {\n    if (POINTERSTATE.touch.scrollDecided) {\n      return;\n    }\n    POINTERSTATE.touch.scrollDecided = true;\n    const ta = firstTouchAction(ev);\n    let shouldPrevent = false;\n    const dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\n    const dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\n    if (!ev.cancelable) {\n      // Scrolling is happening\n    } else if (ta === 'none') {\n      shouldPrevent = true;\n    } else if (ta === 'pan-x') {\n      shouldPrevent = dy > dx;\n    } else if (ta === 'pan-y') {\n      shouldPrevent = dx > dy;\n    }\n    if (shouldPrevent) {\n      ev.preventDefault();\n    } else {\n      prevent('track');\n    }\n  }\n}\n\n/**\n * Adds an event listener to a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to add listener on\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function to call\n * @return {boolean} Returns true if a gesture event listener was added.\n */\nexport function addListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _add(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes an event listener from a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to remove listener from\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function previously passed to\n *  `addListener`.\n * @return {boolean} Returns true if a gesture event listener was removed.\n */\nexport function removeListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _remove(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Automate the event listeners for the native events\n *\n * @private\n * @param {!EventTarget} node Node on which to add the event.\n * @param {string} evType Event type to add.\n * @param {function(!Event)} handler Event handler function.\n * @return {void}\n */\nfunction _add(node, evType, handler) {\n  const recognizer = gestures[evType];\n  const deps = recognizer.deps;\n  const name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    node[GESTURE_KEY] = gobj = {};\n  }\n  for (let i = 0, dep, gd; i < deps.length; i++) {\n    dep = deps[i];\n    // Don't add mouse handlers on iOS because they cause gray selection overlays\n    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {\n      continue;\n    }\n    gd = gobj[dep];\n    if (!gd) {\n      gobj[dep] = gd = { _count: 0 };\n    }\n    if (gd._count === 0) {\n      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n    }\n    gd[name] = (gd[name] || 0) + 1;\n    gd._count = (gd._count || 0) + 1;\n  }\n  node.addEventListener(evType, handler);\n  if (recognizer.touchAction) {\n    setTouchAction(node, recognizer.touchAction);\n  }\n}\n\n/**\n * Automate event listener removal for native events\n *\n * @private\n * @param {!EventTarget} node Node on which to remove the event.\n * @param {string} evType Event type to remove.\n * @param {function(!Event): void} handler Event handler function.\n * @return {void}\n */\nfunction _remove(node, evType, handler) {\n  const recognizer = gestures[evType];\n  const deps = recognizer.deps;\n  const name = recognizer.name;\n  const gobj = node[GESTURE_KEY];\n  if (gobj) {\n    for (let i = 0, dep, gd; i < deps.length; i++) {\n      dep = deps[i];\n      gd = gobj[dep];\n      if (gd && gd[name]) {\n        gd[name] = (gd[name] || 1) - 1;\n        gd._count = (gd._count || 1) - 1;\n        if (gd._count === 0) {\n          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n        }\n      }\n    }\n  }\n  node.removeEventListener(evType, handler);\n}\n\n/**\n * Registers a new gesture event recognizer for adding new custom\n * gesture event types.\n *\n * @param {!GestureRecognizer} recog Gesture recognizer descriptor\n * @return {void}\n */\nexport function register(recog) {\n  recognizers.push(recog);\n  for (let i = 0; i < recog.emits.length; i++) {\n    gestures[recog.emits[i]] = recog;\n  }\n}\n\n/**\n * @private\n * @param {string} evName Event name.\n * @return {Object} Returns the gesture for the given event name.\n */\nfunction _findRecognizerByEvent(evName) {\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    for (let j = 0, n; j < r.emits.length; j++) {\n      n = r.emits[j];\n      if (n === evName) {\n        return r;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Sets scrolling direction on node.\n *\n * This value is checked on first move, thus it should be called prior to\n * adding event listeners.\n *\n * @param {!EventTarget} node Node to set touch action setting on\n * @param {string} value Touch action value\n * @return {void}\n */\nexport function setTouchAction(node, value) {\n  if (HAS_NATIVE_TA && node instanceof HTMLElement) {\n    // NOTE: add touchAction async so that events can be added in\n    // custom element constructors. Otherwise we run afoul of custom\n    // elements restriction against settings attributes (style) in the\n    // constructor.\n    microTask.run(() => {\n      node.style.touchAction = value;\n    });\n  }\n  node[TOUCH_ACTION] = value;\n}\n\n/**\n * Dispatches an event on the `target` element of `type` with the given\n * `detail`.\n * @private\n * @param {!EventTarget} target The element on which to fire an event.\n * @param {string} type The type of event to fire.\n * @param {!Object=} detail The detail object to populate on the event.\n * @return {void}\n */\nfunction _fire(target, type, detail) {\n  const ev = new Event(type, { bubbles: true, cancelable: true, composed: true });\n  ev.detail = detail;\n  wrap(/** @type {!Node} */ (target)).dispatchEvent(ev);\n  // Forward `preventDefault` in a clean way\n  if (ev.defaultPrevented) {\n    const preventer = detail.preventer || detail.sourceEvent;\n    if (preventer && preventer.preventDefault) {\n      preventer.preventDefault();\n    }\n  }\n}\n\n/**\n * Prevents the dispatch and default action of the given event name.\n *\n * @param {string} evName Event name.\n * @return {void}\n */\nexport function prevent(evName) {\n  const recognizer = _findRecognizerByEvent(evName);\n  if (recognizer.info) {\n    recognizer.info.prevent = true;\n  }\n}\n\nregister({\n  name: 'downup',\n  deps: ['mousedown', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend'],\n  },\n  emits: ['down', 'up'],\n\n  info: {\n    movefn: null,\n    upfn: null,\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset() {\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    const t = _findOriginalTarget(e);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const movefn = (e) => {\n      if (!hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n        untrackDocument(self.info);\n      }\n    };\n    const upfn = (e) => {\n      if (hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n      }\n      untrackDocument(self.info);\n    };\n    trackDocument(this.info, movefn, upfn);\n    downupFire('down', t, e);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart(e) {\n    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend(e) {\n    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n});\n\n/**\n * @param {string} type\n * @param {EventTarget} target\n * @param {Event|Touch} event\n * @param {Event=} preventer\n * @return {void}\n */\nfunction downupFire(type, target, event, preventer) {\n  if (!target) {\n    return;\n  }\n  _fire(target, type, {\n    x: event.clientX,\n    y: event.clientY,\n    sourceEvent: event,\n    preventer,\n    prevent(e) {\n      return prevent(e);\n    },\n  });\n}\n\nregister({\n  name: 'track',\n  touchAction: 'none',\n  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend'],\n  },\n  emits: ['track'],\n\n  info: {\n    x: 0,\n    y: 0,\n    state: 'start',\n    started: false,\n    moves: [],\n    /** @this {GestureInfo} */\n    addMove(move) {\n      if (this.moves.length > TRACK_LENGTH) {\n        this.moves.shift();\n      }\n      this.moves.push(move);\n    },\n    movefn: null,\n    upfn: null,\n    prevent: false,\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset() {\n    this.info.state = 'start';\n    this.info.started = false;\n    this.info.moves = [];\n    this.info.x = 0;\n    this.info.y = 0;\n    this.info.prevent = false;\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    const t = _findOriginalTarget(e);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const movefn = (e) => {\n      const x = e.clientX,\n        y = e.clientY;\n      if (trackHasMovedEnough(self.info, x, y)) {\n        // First move is 'start', subsequent moves are 'move', mouseup is 'end'\n        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';\n        if (self.info.state === 'start') {\n          // If and only if tracking, always prevent tap\n          prevent('tap');\n        }\n        self.info.addMove({ x, y });\n        if (!hasLeftMouseButton(e)) {\n          // Always fire \"end\"\n          self.info.state = 'end';\n          untrackDocument(self.info);\n        }\n        if (t) {\n          trackFire(self.info, t, e);\n        }\n        self.info.started = true;\n      }\n    };\n    const upfn = (e) => {\n      if (self.info.started) {\n        movefn(e);\n      }\n\n      // Remove the temporary listeners\n      untrackDocument(self.info);\n    };\n    // Add temporary document listeners as mouse retargets\n    trackDocument(this.info, movefn, upfn);\n    this.info.x = e.clientX;\n    this.info.y = e.clientY;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart(e) {\n    const ct = e.changedTouches[0];\n    this.info.x = ct.clientX;\n    this.info.y = ct.clientY;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchmove(e) {\n    const t = _findOriginalTarget(e);\n    const ct = e.changedTouches[0];\n    const x = ct.clientX,\n      y = ct.clientY;\n    if (trackHasMovedEnough(this.info, x, y)) {\n      if (this.info.state === 'start') {\n        // If and only if tracking, always prevent tap\n        prevent('tap');\n      }\n      this.info.addMove({ x, y });\n      trackFire(this.info, t, ct);\n      this.info.state = 'track';\n      this.info.started = true;\n    }\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend(e) {\n    const t = _findOriginalTarget(e);\n    const ct = e.changedTouches[0];\n    // Only trackend if track was started and not aborted\n    if (this.info.started) {\n      // Reset started state on up\n      this.info.state = 'end';\n      this.info.addMove({ x: ct.clientX, y: ct.clientY });\n      trackFire(this.info, t, ct);\n    }\n  },\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction trackHasMovedEnough(info, x, y) {\n  if (info.prevent) {\n    return false;\n  }\n  if (info.started) {\n    return true;\n  }\n  const dx = Math.abs(info.x - x);\n  const dy = Math.abs(info.y - y);\n  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;\n}\n\n/**\n * @param {!GestureInfo} info\n * @param {?EventTarget} target\n * @param {Touch} touch\n * @return {void}\n */\nfunction trackFire(info, target, touch) {\n  if (!target) {\n    return;\n  }\n  const secondlast = info.moves[info.moves.length - 2];\n  const lastmove = info.moves[info.moves.length - 1];\n  const dx = lastmove.x - info.x;\n  const dy = lastmove.y - info.y;\n  let ddx,\n    ddy = 0;\n  if (secondlast) {\n    ddx = lastmove.x - secondlast.x;\n    ddy = lastmove.y - secondlast.y;\n  }\n  _fire(target, 'track', {\n    state: info.state,\n    x: touch.clientX,\n    y: touch.clientY,\n    dx,\n    dy,\n    ddx,\n    ddy,\n    sourceEvent: touch,\n    hover() {\n      return deepTargetFind(touch.clientX, touch.clientY);\n    },\n  });\n}\n\nregister({\n  name: 'tap',\n  deps: ['mousedown', 'click', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['click', 'touchend'],\n  },\n  emits: ['tap'],\n  info: {\n    x: NaN,\n    y: NaN,\n    prevent: false,\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset() {\n    this.info.x = NaN;\n    this.info.y = NaN;\n    this.info.prevent = false;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown(e) {\n    if (hasLeftMouseButton(e)) {\n      this.info.x = e.clientX;\n      this.info.y = e.clientY;\n    }\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  click(e) {\n    if (hasLeftMouseButton(e)) {\n      trackForward(this.info, e);\n    }\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart(e) {\n    const touch = e.changedTouches[0];\n    this.info.x = touch.clientX;\n    this.info.y = touch.clientY;\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend(e) {\n    trackForward(this.info, e.changedTouches[0], e);\n  },\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {Event | Touch} e\n * @param {Event=} preventer\n * @return {void}\n */\nfunction trackForward(info, e, preventer) {\n  const dx = Math.abs(e.clientX - info.x);\n  const dy = Math.abs(e.clientY - info.y);\n  // Find original target from `preventer` for TouchEvents, or `e` for MouseEvents\n  const t = _findOriginalTarget(preventer || e);\n  if (!t || (canBeDisabled[/** @type {!HTMLElement} */ (t).localName] && t.hasAttribute('disabled'))) {\n    return;\n  }\n  // Dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`\n  if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {\n    // Prevent taps from being generated if an event has canceled them\n    if (!info.prevent) {\n      _fire(t, 'tap', {\n        x: e.clientX,\n        y: e.clientY,\n        sourceEvent: e,\n        preventer,\n      });\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["e"]
}
