import {
  flush,
  hideElementsGlobally
} from "./chunk-DKDV73LI.js";
import {
  Debouncer,
  enqueueDebouncer
} from "./chunk-JJXNSZ6B.js";
import {
  showHideChildren,
  templatize
} from "./chunk-VUBXZXWD.js";
import {
  PolymerElement,
  root,
  wrap
} from "./chunk-ZKSNVHJS.js";
import {
  fastDomIf,
  strictTemplatePolicy,
  suppressTemplateNotifications
} from "./chunk-A5QYNKPK.js";
import {
  microTask
} from "./chunk-NCN7ELFS.js";

// node_modules/@polymer/polymer/lib/elements/dom-if.js
var DomIfBase = class extends PolymerElement {
  static get is() {
    return "dom-if";
  }
  static get template() {
    return null;
  }
  static get properties() {
    return {
      if: {
        type: Boolean,
        observer: "__debounceRender"
      },
      restamp: {
        type: Boolean,
        observer: "__debounceRender"
      },
      notifyDomChange: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.__renderDebouncer = null;
    this._lastIf = false;
    this.__hideTemplateChildren__ = false;
    this.__template;
    this._templateInfo;
  }
  __debounceRender() {
    this.__renderDebouncer = Debouncer.debounce(
      this.__renderDebouncer,
      microTask,
      () => this.__render()
    );
    enqueueDebouncer(this.__renderDebouncer);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    const parent = wrap(this).parentNode;
    if (!parent || parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !wrap(parent).host) {
      this.__teardownInstance();
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (!hideElementsGlobally()) {
      this.style.display = "none";
    }
    if (this.if) {
      this.__debounceRender();
    }
  }
  __ensureTemplate() {
    if (!this.__template) {
      const thisAsTemplate = this;
      let template = thisAsTemplate._templateInfo ? thisAsTemplate : wrap(thisAsTemplate).querySelector("template");
      if (!template) {
        let observer = new MutationObserver(() => {
          if (wrap(this).querySelector("template")) {
            observer.disconnect();
            this.__render();
          } else {
            throw new Error("dom-if requires a <template> child");
          }
        });
        observer.observe(this, { childList: true });
        return false;
      }
      this.__template = template;
    }
    return true;
  }
  __ensureInstance() {
    let parentNode = wrap(this).parentNode;
    if (!this.__hasInstance()) {
      if (!parentNode) {
        return false;
      }
      if (!this.__ensureTemplate()) {
        return false;
      }
      this.__createAndInsertInstance(parentNode);
    } else {
      let children = this.__getInstanceNodes();
      if (children && children.length) {
        let lastChild = wrap(this).previousSibling;
        if (lastChild !== children[children.length - 1]) {
          for (let i = 0, n; i < children.length && (n = children[i]); i++) {
            wrap(parentNode).insertBefore(n, this);
          }
        }
      }
    }
    return true;
  }
  render() {
    flush();
  }
  __render() {
    if (this.if) {
      if (!this.__ensureInstance()) {
        return;
      }
    } else if (this.restamp) {
      this.__teardownInstance();
    }
    this._showHideChildren();
    if ((!suppressTemplateNotifications || this.notifyDomChange) && this.if != this._lastIf) {
      this.dispatchEvent(new CustomEvent("dom-change", {
        bubbles: true,
        composed: true
      }));
      this._lastIf = this.if;
    }
  }
  __hasInstance() {
  }
  __getInstanceNodes() {
  }
  __createAndInsertInstance(parentNode) {
  }
  __teardownInstance() {
  }
  _showHideChildren() {
  }
};
var DomIfFast = class extends DomIfBase {
  constructor() {
    super();
    this.__instance = null;
    this.__syncInfo = null;
  }
  __hasInstance() {
    return Boolean(this.__instance);
  }
  __getInstanceNodes() {
    return this.__instance.templateInfo.childNodes;
  }
  __createAndInsertInstance(parentNode) {
    const host = this.__dataHost || this;
    if (strictTemplatePolicy) {
      if (!this.__dataHost) {
        throw new Error("strictTemplatePolicy: template owner not trusted");
      }
    }
    const templateInfo = host._bindTemplate(
      this.__template,
      true
    );
    templateInfo.runEffects = (runEffects, changedProps, hasPaths) => {
      let syncInfo = this.__syncInfo;
      if (this.if) {
        if (syncInfo) {
          this.__syncInfo = null;
          this._showHideChildren();
          changedProps = Object.assign(syncInfo.changedProps, changedProps);
        }
        runEffects(changedProps, hasPaths);
      } else {
        if (this.__instance) {
          if (!syncInfo) {
            syncInfo = this.__syncInfo = { runEffects, changedProps: {} };
          }
          if (hasPaths) {
            for (const p in changedProps) {
              const rootProp = root(p);
              syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];
            }
          } else {
            Object.assign(syncInfo.changedProps, changedProps);
          }
        }
      }
    };
    this.__instance = host._stampTemplate(
      this.__template,
      templateInfo
    );
    wrap(parentNode).insertBefore(this.__instance, this);
  }
  __syncHostProperties() {
    const syncInfo = this.__syncInfo;
    if (syncInfo) {
      this.__syncInfo = null;
      syncInfo.runEffects(syncInfo.changedProps, false);
    }
  }
  __teardownInstance() {
    const host = this.__dataHost || this;
    if (this.__instance) {
      host._removeBoundDom(this.__instance);
      this.__instance = null;
      this.__syncInfo = null;
    }
  }
  _showHideChildren() {
    const hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
      this.__instance.__hidden = hidden;
      showHideChildren(hidden, this.__instance.templateInfo.childNodes);
    }
    if (!hidden) {
      this.__syncHostProperties();
    }
  }
};
var DomIfLegacy = class extends DomIfBase {
  constructor() {
    super();
    this.__ctor = null;
    this.__instance = null;
    this.__invalidProps = null;
  }
  __hasInstance() {
    return Boolean(this.__instance);
  }
  __getInstanceNodes() {
    return this.__instance.children;
  }
  __createAndInsertInstance(parentNode) {
    if (!this.__ctor) {
      this.__ctor = templatize(
        this.__template,
        this,
        {
          mutableData: true,
          forwardHostProp: function(prop, value) {
            if (this.__instance) {
              if (this.if) {
                this.__instance.forwardHostProp(prop, value);
              } else {
                this.__invalidProps = this.__invalidProps || /* @__PURE__ */ Object.create(null);
                this.__invalidProps[root(prop)] = true;
              }
            }
          }
        }
      );
    }
    this.__instance = new this.__ctor();
    wrap(parentNode).insertBefore(this.__instance.root, this);
  }
  __teardownInstance() {
    if (this.__instance) {
      let c$ = this.__instance.children;
      if (c$ && c$.length) {
        let parent = wrap(c$[0]).parentNode;
        if (parent) {
          parent = wrap(parent);
          for (let i = 0, n; i < c$.length && (n = c$[i]); i++) {
            parent.removeChild(n);
          }
        }
      }
      this.__invalidProps = null;
      this.__instance = null;
    }
  }
  __syncHostProperties() {
    let props = this.__invalidProps;
    if (props) {
      this.__invalidProps = null;
      for (let prop in props) {
        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
      }
      this.__instance._flushProperties();
    }
  }
  _showHideChildren() {
    const hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
      this.__instance.__hidden = hidden;
      this.__instance._showHideChildren(hidden);
    }
    if (!hidden) {
      this.__syncHostProperties();
    }
  }
};
var DomIf = fastDomIf ? DomIfFast : DomIfLegacy;
customElements.define(DomIf.is, DomIf);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
//# sourceMappingURL=chunk-RPLOOUJS.js.map
