import {
  processTemplates
} from "./chunk-CE2HX6X3.js";
import {
  MediaQueryController
} from "./chunk-WJZC25EU.js";
import {
  Item
} from "./chunk-S3HOX4GU.js";
import {
  ListBox
} from "./chunk-H44FQUHM.js";
import {
  menuOverlay
} from "./chunk-E2XIUAPG.js";
import {
  PositionMixin
} from "./chunk-BTTUSTOZ.js";
import {
  OverlayElement
} from "./chunk-LH2VMHWZ.js";
import {
  isIOS,
  isTouch
} from "./chunk-XAUSENF3.js";
import {
  ControllerMixin
} from "./chunk-SG4ORNH2.js";
import {
  addListener,
  gestures,
  prevent,
  register,
  removeListener
} from "./chunk-ZB6KQ55W.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import {
  ThemePropertyMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";

// node_modules/@vaadin/context-menu/theme/lumo/vaadin-context-menu-styles.js
var contextMenuOverlay = css`
  :host([phone]) {
    top: 0 !important;
    right: 0 !important;
    bottom: var(--vaadin-overlay-viewport-bottom) !important;
    left: 0 !important;
    align-items: stretch;
    justify-content: flex-end;
  }

  /* TODO These style overrides should not be needed.
   We should instead offer a way to have non-selectable items inside the context menu. */

  :host {
    --_lumo-list-box-item-selected-icon-display: none;
    --_lumo-list-box-item-padding-left: calc(var(--lumo-space-m) + var(--lumo-border-radius-m) / 4);
  }

  [part='overlay'] {
    outline: none;
  }
`;
registerStyles("vaadin-context-menu-overlay", [menuOverlay, contextMenuOverlay], {
  moduleId: "lumo-context-menu-overlay"
});
registerStyles(
  "vaadin-context-menu-list-box",
  css`
    :host(.vaadin-menu-list-box) {
      --_lumo-list-box-item-selected-icon-display: block;
    }

    /* Normal item */
    [part='items'] ::slotted(.vaadin-menu-item) {
      -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);
      cursor: default;
    }

    [part='items'] ::slotted(.vaadin-menu-item) {
      outline: none;
      border-radius: var(--lumo-border-radius-m);
      padding-left: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
      padding-right: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    }

    :host(.vaadin-menu-list-box) [part='items'] ::slotted(.vaadin-menu-item) {
      padding-left: calc(var(--lumo-border-radius-m) / 4);
      padding-right: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    }

    /* Hovered item */
    /* TODO a workaround until we have "focus-follows-mouse". After that, use the hover style for focus-ring as well */
    [part='items'] ::slotted(.vaadin-menu-item:hover:not([disabled])),
    [part='items'] ::slotted(.vaadin-menu-item[expanded]:not([disabled])) {
      background-color: var(--lumo-primary-color-10pct);
    }

    /* RTL styles */
    :host([dir='rtl'])[part='items'] ::slotted(.vaadin-menu-item) {
      padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
      padding-right: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
    }

    :host([dir='rtl'].vaadin-menu-list-box) [part='items'] ::slotted(.vaadin-menu-item) {
      padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
      padding-right: calc(var(--lumo-border-radius-m) / 4);
    }

    /* Focused item */
    @media (pointer: coarse) {
      [part='items'] ::slotted(.vaadin-menu-item:hover:not([expanded]):not([disabled])) {
        background-color: transparent;
      }
    }
  `,
  { moduleId: "lumo-context-menu-list-box" }
);
registerStyles(
  "vaadin-context-menu-item",
  css`
    /* :hover needed to workaround https://github.com/vaadin/web-components/issues/3133 */
    :host(:hover) {
      user-select: none;
      -ms-user-select: none;
      -webkit-user-select: none;
    }

    :host(.vaadin-menu-item[menu-item-checked]) [part='checkmark']::before {
      opacity: 1;
    }

    :host(.vaadin-menu-item.vaadin-context-menu-parent-item)::after {
      font-family: lumo-icons;
      font-size: var(--lumo-icon-size-xs);
      content: var(--lumo-icons-angle-right);
      color: var(--lumo-tertiary-text-color);
    }

    :host(:not([dir='rtl']).vaadin-menu-item.vaadin-context-menu-parent-item)::after {
      margin-right: calc(var(--lumo-space-m) * -1);
      padding-left: var(--lumo-space-m);
    }

    :host([expanded]) {
      background-color: var(--lumo-primary-color-10pct);
    }

    /* RTL styles */
    :host([dir='rtl'].vaadin-menu-item.vaadin-context-menu-parent-item)::after {
      content: var(--lumo-icons-angle-left);
      margin-left: calc(var(--lumo-space-m) * -1);
      padding-right: var(--lumo-space-m);
    }
  `,
  { moduleId: "lumo-context-menu-item" }
);

// node_modules/@vaadin/context-menu/src/vaadin-contextmenu-event.js
register({
  name: "vaadin-contextmenu",
  deps: ["touchstart", "touchmove", "touchend", "contextmenu"],
  flow: {
    start: ["touchstart", "contextmenu"],
    end: ["contextmenu"]
  },
  emits: ["vaadin-contextmenu"],
  info: {
    sourceEvent: null
  },
  reset() {
    this.info.sourceEvent = null;
    this._cancelTimer();
    this.info.touchJob = null;
    this.info.touchStartCoords = null;
  },
  _cancelTimer() {
    if (this._timerId) {
      clearTimeout(this._timerId);
      delete this._fired;
    }
  },
  _setSourceEvent(e) {
    this.info.sourceEvent = e;
    const path = e.composedPath();
    this.info.sourceEvent.__composedPath = path;
  },
  touchstart(e) {
    this._setSourceEvent(e);
    this.info.touchStartCoords = {
      x: e.changedTouches[0].clientX,
      y: e.changedTouches[0].clientY
    };
    const t = e.composedPath()[0] || e.target;
    this._timerId = setTimeout(() => {
      const ct = e.changedTouches[0];
      if (!e.shiftKey) {
        if (isIOS) {
          this._fired = true;
          this.fire(t, ct.clientX, ct.clientY);
        }
        prevent("tap");
      }
    }, 500);
  },
  touchmove(e) {
    const moveThreshold = 15;
    const touchStartCoords = this.info.touchStartCoords;
    if (Math.abs(touchStartCoords.x - e.changedTouches[0].clientX) > moveThreshold || Math.abs(touchStartCoords.y - e.changedTouches[0].clientY) > moveThreshold) {
      this._cancelTimer();
    }
  },
  touchend(e) {
    if (this._fired) {
      e.preventDefault();
    }
    this._cancelTimer();
  },
  contextmenu(e) {
    if (!e.shiftKey) {
      this._setSourceEvent(e);
      this.fire(e.target, e.clientX, e.clientY);
      prevent("tap");
    }
  },
  fire(target, x, y) {
    const sourceEvent = this.info.sourceEvent;
    const ev = new Event("vaadin-contextmenu", { bubbles: true, cancelable: true, composed: true });
    ev.detail = { x, y, sourceEvent };
    target.dispatchEvent(ev);
    if (ev.defaultPrevented && sourceEvent && sourceEvent.preventDefault) {
      sourceEvent.preventDefault();
    }
  }
});

// node_modules/@vaadin/context-menu/src/vaadin-context-menu-overlay.js
registerStyles(
  "vaadin-context-menu-overlay",
  css`
    :host {
      align-items: flex-start;
      justify-content: flex-start;
    }

    :host([right-aligned]),
    :host([end-aligned]) {
      align-items: flex-end;
    }

    :host([bottom-aligned]) {
      justify-content: flex-end;
    }

    [part='overlay'] {
      background-color: #fff;
    }
  `,
  { moduleId: "vaadin-context-menu-overlay-styles" }
);
var ContextMenuOverlay = class extends PositionMixin(OverlayElement) {
  static get is() {
    return "vaadin-context-menu-overlay";
  }
  static get properties() {
    return {
      parentOverlay: {
        type: Object,
        readOnly: true
      }
    };
  }
  static get observers() {
    return ["_themeChanged(_theme)"];
  }
  ready() {
    super.ready();
    this.addEventListener("keydown", (e) => {
      if (!e.defaultPrevented && e.composedPath()[0] === this.$.overlay && [38, 40].indexOf(e.keyCode) > -1) {
        const child = this.getFirstChild();
        if (child && Array.isArray(child.items) && child.items.length) {
          e.preventDefault();
          if (e.keyCode === 38) {
            child.items[child.items.length - 1].focus();
          } else {
            child.focus();
          }
        }
      }
    });
  }
  getFirstChild() {
    return this.content.querySelector(":not(style):not(slot)");
  }
  _themeChanged() {
    this.close();
  }
  getBoundaries() {
    const overlayRect = this.getBoundingClientRect();
    const contentRect = this.$.overlay.getBoundingClientRect();
    let yMax = overlayRect.bottom - contentRect.height;
    const parent = this.parentOverlay;
    if (parent && parent.hasAttribute("bottom-aligned")) {
      const parentStyle = getComputedStyle(parent);
      yMax = yMax - parseFloat(parentStyle.bottom) - parseFloat(parentStyle.height);
    }
    return {
      xMax: overlayRect.right - contentRect.width,
      xMin: overlayRect.left + contentRect.width,
      yMax
    };
  }
  _updatePosition() {
    super._updatePosition();
    if (this.positionTarget && this.parentOverlay) {
      const content = this.$.content;
      const style = getComputedStyle(content);
      const isLeftAligned = !!this.style.left;
      if (isLeftAligned) {
        this.style.left = `${parseFloat(this.style.left) + parseFloat(style.paddingLeft)}px`;
      } else {
        this.style.right = `${parseFloat(this.style.right) + parseFloat(style.paddingRight)}px`;
      }
      const isBottomAligned = !!this.style.bottom;
      if (isBottomAligned) {
        this.style.bottom = `${parseFloat(this.style.bottom) - parseFloat(style.paddingBottom)}px`;
      } else {
        this.style.top = `${parseFloat(this.style.top) - parseFloat(style.paddingTop)}px`;
      }
    }
  }
};
customElements.define(ContextMenuOverlay.is, ContextMenuOverlay);

// node_modules/@vaadin/context-menu/src/vaadin-contextmenu-items-mixin.js
var ContextMenuItemElement = class extends Item {
  static get is() {
    return "vaadin-context-menu-item";
  }
};
customElements.define(ContextMenuItemElement.is, ContextMenuItemElement);
var ContextMenuListBox = class extends ListBox {
  static get is() {
    return "vaadin-context-menu-list-box";
  }
};
customElements.define(ContextMenuListBox.is, ContextMenuListBox);
var ItemsMixin = (superClass) => class ItemsMixin extends superClass {
  static get properties() {
    return {
      items: Array
    };
  }
  ready() {
    super.ready();
    this.__itemsOutsideClickListener = (e) => {
      if (!e.composedPath().filter((el) => el.localName === "vaadin-context-menu-overlay")[0]) {
        this.dispatchEvent(new CustomEvent("items-outside-click"));
      }
    };
    this.addEventListener("items-outside-click", () => this.items && this.close());
  }
  connectedCallback() {
    super.connectedCallback();
    document.documentElement.addEventListener("click", this.__itemsOutsideClickListener);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.documentElement.removeEventListener("click", this.__itemsOutsideClickListener);
  }
  get __isRTL() {
    return this.getAttribute("dir") === "rtl";
  }
  __forwardFocus() {
    const overlay = this.$.overlay;
    const child = overlay.getFirstChild();
    if (overlay.parentOverlay) {
      const parent = overlay.parentOverlay.querySelector("[expanded]");
      if (parent && parent.hasAttribute("focused") && child) {
        child.focus();
      } else {
        overlay.$.overlay.focus();
      }
    } else if (child) {
      child.focus();
    }
  }
  __openSubMenu(subMenu, itemElement) {
    subMenu.items = itemElement._item.children;
    subMenu.listenOn = itemElement;
    const parent = this.$.overlay;
    const subMenuOverlay = subMenu.$.overlay;
    subMenuOverlay.positionTarget = itemElement;
    subMenuOverlay.noHorizontalOverlap = true;
    subMenuOverlay._setParentOverlay(parent);
    if (parent.hasAttribute("theme")) {
      subMenu.setAttribute("theme", parent.getAttribute("theme"));
    } else {
      subMenu.removeAttribute("theme");
    }
    const content = subMenu.$.overlay.$.content;
    content.style.minWidth = "";
    itemElement.dispatchEvent(
      new CustomEvent("opensubmenu", {
        detail: {
          children: itemElement._item.children
        }
      })
    );
  }
  __itemsRenderer(root, menu, context) {
    this.__initMenu(root, menu);
    const subMenu = root.querySelector(this.constructor.is);
    subMenu.closeOn = menu.closeOn;
    const listBox = root.querySelector("vaadin-context-menu-list-box");
    listBox.innerHTML = "";
    const items = Array.from(context.detail.children || menu.items);
    items.forEach((item) => {
      let component;
      if (item.component instanceof HTMLElement) {
        component = item.component;
      } else {
        component = document.createElement(item.component || "vaadin-context-menu-item");
      }
      if (component instanceof Item) {
        component.setAttribute("role", "menuitem");
        component.classList.add("vaadin-menu-item");
      } else if (component.localName === "hr") {
        component.setAttribute("role", "separator");
      }
      this._setMenuItemTheme(component, item, this._theme);
      component._item = item;
      if (item.text) {
        component.textContent = item.text;
      }
      this.__toggleMenuComponentAttribute(component, "menu-item-checked", item.checked);
      this.__toggleMenuComponentAttribute(component, "disabled", item.disabled);
      component.setAttribute("aria-haspopup", "false");
      component.classList.remove("vaadin-context-menu-parent-item");
      if (item.children && item.children.length) {
        component.classList.add("vaadin-context-menu-parent-item");
        component.setAttribute("aria-haspopup", "true");
        component.setAttribute("aria-expanded", "false");
        component.removeAttribute("expanded");
      }
      listBox.appendChild(component);
    });
  }
  _setMenuItemTheme(component, item, hostTheme) {
    let theme = component.getAttribute("theme") || hostTheme;
    if (item.theme != null) {
      theme = Array.isArray(item.theme) ? item.theme.join(" ") : item.theme;
    }
    if (theme) {
      component.setAttribute("theme", theme);
    } else {
      component.removeAttribute("theme");
    }
  }
  __toggleMenuComponentAttribute(component, attribute, on) {
    if (on) {
      component.setAttribute(attribute, "");
      component[`__has-${attribute}`] = true;
    } else if (component[`__has-${attribute}`]) {
      component.removeAttribute(attribute);
      component[`__has-${attribute}`] = false;
    }
  }
  __initMenu(root, menu) {
    if (!root.firstElementChild) {
      const listBox = document.createElement("vaadin-context-menu-list-box");
      root.appendChild(listBox);
      if (this._theme) {
        listBox.setAttribute("theme", this._theme);
      }
      listBox.classList.add("vaadin-menu-list-box");
      requestAnimationFrame(() => listBox.setAttribute("role", "menu"));
      const subMenu = document.createElement(this.constructor.is);
      subMenu.setAttribute("hidden", "");
      root.appendChild(subMenu);
      subMenu.$.overlay.modeless = true;
      subMenu.openOn = "opensubmenu";
      menu.addEventListener("opened-changed", (e) => !e.detail.value && subMenu.close());
      subMenu.addEventListener("opened-changed", (e) => {
        if (!e.detail.value) {
          const expandedItem = listBox.querySelector("[expanded]");
          if (expandedItem) {
            expandedItem.setAttribute("aria-expanded", "false");
            expandedItem.removeAttribute("expanded");
          }
        }
      });
      listBox.addEventListener("selected-changed", (e) => {
        if (typeof e.detail.value === "number") {
          const item = e.target.items[e.detail.value]._item;
          if (!item.children) {
            const detail = { value: item };
            menu.dispatchEvent(new CustomEvent("item-selected", { detail }));
          }
          listBox.selected = null;
        }
      });
      subMenu.addEventListener("item-selected", (e) => {
        menu.dispatchEvent(new CustomEvent("item-selected", { detail: e.detail }));
      });
      subMenu.addEventListener("close-all-menus", () => {
        menu.dispatchEvent(new CustomEvent("close-all-menus"));
      });
      menu.addEventListener("close-all-menus", menu.close);
      menu.addEventListener("item-selected", menu.close);
      menu.$.overlay.$.backdrop.addEventListener("click", () => menu.close());
      menu.$.overlay.addEventListener("keydown", (e) => {
        const isRTL = this.__isRTL;
        if (!isRTL && e.keyCode === 37 || isRTL && e.keyCode === 39) {
          menu.close();
          menu.listenOn.focus();
        } else if (e.key === "Escape" || e.key === "Tab") {
          menu.dispatchEvent(new CustomEvent("close-all-menus"));
        }
      });
      requestAnimationFrame(() => {
        this.__openListenerActive = true;
      });
      const openSubMenu = (e, itemElement = e.composedPath().filter((e2) => e2.localName === "vaadin-context-menu-item")[0]) => {
        if (!this.__openListenerActive) {
          return;
        }
        if (menu.$.overlay.hasAttribute("opening")) {
          requestAnimationFrame(() => openSubMenu(e, itemElement));
          return;
        }
        if (itemElement) {
          if (subMenu.items !== itemElement._item.children) {
            subMenu.close();
          }
          if (!menu.opened) {
            return;
          }
          if (itemElement._item.children && itemElement._item.children.length) {
            itemElement.setAttribute("aria-expanded", "true");
            itemElement.setAttribute("expanded", "");
            this.__openSubMenu(subMenu, itemElement);
          } else {
            subMenu.listenOn.focus();
          }
        }
      };
      menu.$.overlay.addEventListener(isTouch ? "click" : "mouseover", openSubMenu);
      menu.$.overlay.addEventListener("keydown", (e) => {
        const isRTL = this.__isRTL;
        const shouldOpenSubMenu = !isRTL && e.keyCode === 39 || isRTL && e.keyCode === 37 || e.keyCode === 13 || e.keyCode === 32;
        if (shouldOpenSubMenu) {
          openSubMenu(e);
        }
      });
    } else {
      const listBox = root.querySelector("vaadin-context-menu-list-box");
      if (this._theme) {
        listBox.setAttribute("theme", this._theme);
      } else {
        listBox.removeAttribute("theme");
      }
    }
  }
};

// node_modules/@vaadin/context-menu/src/vaadin-context-menu.js
var ContextMenu = class extends ControllerMixin(ElementMixin(ThemePropertyMixin(ItemsMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>

      <slot id="slot"></slot>

      <vaadin-context-menu-overlay
        id="overlay"
        on-opened-changed="_onOverlayOpened"
        on-vaadin-overlay-open="_onVaadinOverlayOpen"
        with-backdrop="[[_phone]]"
        phone$="[[_phone]]"
        model="[[_context]]"
        theme$="[[_theme]]"
      >
      </vaadin-context-menu-overlay>
    `;
  }
  static get is() {
    return "vaadin-context-menu";
  }
  static get properties() {
    return {
      selector: {
        type: String
      },
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },
      openOn: {
        type: String,
        value: "vaadin-contextmenu"
      },
      listenOn: {
        type: Object,
        value() {
          return this;
        }
      },
      closeOn: {
        type: String,
        value: "click",
        observer: "_closeOnChanged"
      },
      renderer: {
        type: Function
      },
      _context: Object,
      _boundClose: Object,
      _boundOpen: Object,
      _phone: {
        type: Boolean
      },
      _touch: {
        type: Boolean,
        value: isTouch
      },
      _wide: {
        type: Boolean
      },
      _wideMediaQuery: {
        type: String,
        value: "(min-device-width: 750px)"
      }
    };
  }
  static get observers() {
    return [
      "_openedChanged(opened)",
      "_targetOrOpenOnChanged(listenOn, openOn)",
      "_rendererChanged(renderer, items)",
      "_touchOrWideChanged(_touch, _wide)"
    ];
  }
  constructor() {
    super();
    this._boundOpen = this.open.bind(this);
    this._boundClose = this.close.bind(this);
    this._boundOnGlobalContextMenu = this._onGlobalContextMenu.bind(this);
  }
  connectedCallback() {
    super.connectedCallback();
    this.__boundOnScroll = this.__onScroll.bind(this);
    window.addEventListener("scroll", this.__boundOnScroll, true);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("scroll", this.__boundOnScroll, true);
    this.close();
  }
  ready() {
    super.ready();
    this.addController(
      new MediaQueryController(this._wideMediaQuery, (matches) => {
        this._wide = matches;
      })
    );
    processTemplates(this);
  }
  _onOverlayOpened(e) {
    this._setOpened(e.detail.value);
    this.__alignOverlayPosition();
  }
  _onVaadinOverlayOpen() {
    this.__alignOverlayPosition();
    this.$.overlay.style.opacity = "";
    this.__forwardFocus();
  }
  _targetOrOpenOnChanged(listenOn, openOn) {
    if (this._oldListenOn && this._oldOpenOn) {
      this._unlisten(this._oldListenOn, this._oldOpenOn, this._boundOpen);
      this._oldListenOn.style.webkitTouchCallout = "";
      this._oldListenOn.style.webkitUserSelect = "";
      this._oldListenOn.style.userSelect = "";
      this._oldListenOn = null;
      this._oldOpenOn = null;
    }
    if (listenOn && openOn) {
      this._listen(listenOn, openOn, this._boundOpen);
      this._oldListenOn = listenOn;
      this._oldOpenOn = openOn;
    }
  }
  _touchOrWideChanged(touch, wide) {
    this._phone = !wide && touch;
  }
  _setListenOnUserSelect(value) {
    this.listenOn.style.webkitTouchCallout = value;
    this.listenOn.style.webkitUserSelect = value;
    this.listenOn.style.userSelect = value;
    document.getSelection().removeAllRanges();
  }
  _closeOnChanged(closeOn, oldCloseOn) {
    const evtOverlay = "vaadin-overlay-outside-click";
    if (oldCloseOn) {
      this._unlisten(this.$.overlay, oldCloseOn, this._boundClose);
      this._unlisten(this.$.overlay.root, oldCloseOn, this._boundClose);
    }
    if (closeOn) {
      this._listen(this.$.overlay, closeOn, this._boundClose);
      this._listen(this.$.overlay.root, closeOn, this._boundClose);
      this._unlisten(this.$.overlay, evtOverlay, this._preventDefault);
    } else {
      this._listen(this.$.overlay, evtOverlay, this._preventDefault);
    }
  }
  _preventDefault(e) {
    e.preventDefault();
  }
  _openedChanged(opened) {
    if (opened) {
      document.documentElement.addEventListener("contextmenu", this._boundOnGlobalContextMenu, true);
      this._setListenOnUserSelect("none");
    } else {
      document.documentElement.removeEventListener("contextmenu", this._boundOnGlobalContextMenu, true);
      this._setListenOnUserSelect("");
    }
    this.$.overlay.opened = opened;
  }
  requestContentUpdate() {
    this.$.overlay.requestContentUpdate();
  }
  _rendererChanged(renderer, items) {
    if (items) {
      if (renderer) {
        throw new Error("The items API cannot be used together with a renderer");
      }
      if (this.closeOn === "click") {
        this.closeOn = "";
      }
      renderer = this.__itemsRenderer;
    }
    this.$.overlay.setProperties({ owner: this, renderer });
  }
  close() {
    this._setOpened(false);
  }
  _contextTarget(e) {
    if (this.selector) {
      const targets = this.listenOn.querySelectorAll(this.selector);
      return Array.prototype.filter.call(targets, (el) => {
        return e.composedPath().indexOf(el) > -1;
      })[0];
    }
    return e.target;
  }
  open(e) {
    if (e && !this.opened) {
      this._context = {
        detail: e.detail,
        target: this._contextTarget(e)
      };
      if (this._context.target) {
        this._preventDefault(e);
        e.stopPropagation();
        this.__x = this._getEventCoordinate(e, "x");
        this.__pageXOffset = window.pageXOffset;
        this.__y = this._getEventCoordinate(e, "y");
        this.__pageYOffset = window.pageYOffset;
        this.$.overlay.style.opacity = "0";
        this._setOpened(true);
      }
    }
  }
  __onScroll() {
    if (!this.opened) {
      return;
    }
    const yDiff = window.pageYOffset - this.__pageYOffset;
    const xDiff = window.pageXOffset - this.__pageXOffset;
    this.__adjustPosition("left", -xDiff);
    this.__adjustPosition("right", xDiff);
    this.__adjustPosition("top", -yDiff);
    this.__adjustPosition("bottom", yDiff);
    this.__pageYOffset += yDiff;
    this.__pageXOffset += xDiff;
  }
  __adjustPosition(coord, diff) {
    const overlay = this.$.overlay;
    const style = overlay.style;
    style[coord] = `${(parseInt(style[coord]) || 0) + diff}px`;
  }
  __alignOverlayPosition() {
    const overlay = this.$.overlay;
    if (overlay.positionTarget) {
      return;
    }
    const style = overlay.style;
    ["top", "right", "bottom", "left"].forEach((prop) => style.removeProperty(prop));
    ["right-aligned", "end-aligned", "bottom-aligned"].forEach((attr) => overlay.removeAttribute(attr));
    const { xMax, xMin, yMax } = overlay.getBoundaries();
    const x = this.__x;
    const y = this.__y;
    const wdthVport = document.documentElement.clientWidth;
    const hghtVport = document.documentElement.clientHeight;
    if (!this.__isRTL) {
      if (x < wdthVport / 2 || x < xMax) {
        style.left = `${x}px`;
      } else {
        style.right = `${Math.max(0, wdthVport - x)}px`;
        this._setEndAligned(overlay);
      }
    } else if (x > wdthVport / 2 || x > xMin) {
      style.right = `${Math.max(0, wdthVport - x)}px`;
    } else {
      style.left = `${x}px`;
      this._setEndAligned(overlay);
    }
    if (y < hghtVport / 2 || y < yMax) {
      style.top = `${y}px`;
    } else {
      style.bottom = `${Math.max(0, hghtVport - y)}px`;
      overlay.setAttribute("bottom-aligned", "");
    }
  }
  _setEndAligned(element) {
    element.setAttribute("end-aligned", "");
    if (!this.__isRTL) {
      element.setAttribute("right-aligned", "");
    }
  }
  _getEventCoordinate(event, coord) {
    if (event.detail instanceof Object) {
      if (event.detail[coord]) {
        return event.detail[coord];
      } else if (event.detail.sourceEvent) {
        return this._getEventCoordinate(event.detail.sourceEvent, coord);
      }
    } else {
      const prop = `client${coord.toUpperCase()}`;
      const position = event.changedTouches ? event.changedTouches[0][prop] : event[prop];
      if (position === 0) {
        const rect = event.target.getBoundingClientRect();
        return coord === "x" ? rect.left : rect.top + rect.height;
      }
      return position;
    }
  }
  _listen(node, evType, handler) {
    if (gestures[evType]) {
      addListener(node, evType, handler);
    } else {
      node.addEventListener(evType, handler);
    }
  }
  _unlisten(node, evType, handler) {
    if (gestures[evType]) {
      removeListener(node, evType, handler);
    } else {
      node.removeEventListener(evType, handler);
    }
  }
  _onGlobalContextMenu(e) {
    if (!e.shiftKey) {
      e.preventDefault();
      this.close();
    }
  }
};
customElements.define(ContextMenu.is, ContextMenu);

export {
  ContextMenu
};
/**
 * @license
 * Copyright (c) 2016 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-U7PZSMAM.js.map
