import {
  TimePicker
} from "./chunk-CMCACUBH.js";
import "./chunk-RTLPYO4G.js";
import "./chunk-T7QYKO45.js";
import "./chunk-3X24PFLT.js";
import "./chunk-BFM7G6QE.js";
import {
  SlotMixin
} from "./chunk-7B2Z55OT.js";
import "./chunk-CE2HX6X3.js";
import {
  customField
} from "./chunk-Z6AVP3IS.js";
import {
  DatePicker,
  dateEquals
} from "./chunk-JKXH2Q7N.js";
import "./chunk-LKZC625W.js";
import {
  inputFieldShared
} from "./chunk-KP6A4WLM.js";
import "./chunk-VED5C5P5.js";
import "./chunk-34PCHBPM.js";
import "./chunk-GGAGROPH.js";
import "./chunk-67AQUJJH.js";
import "./chunk-5THRPDE7.js";
import "./chunk-WJZC25EU.js";
import {
  FieldMixin,
  helper,
  requiredField
} from "./chunk-FXYB4AC6.js";
import "./chunk-5765XJOL.js";
import "./chunk-7ZAE2LQL.js";
import "./chunk-NEGQSXRC.js";
import "./chunk-26L5GZ27.js";
import "./chunk-Q6GVJPMX.js";
import "./chunk-E2XIUAPG.js";
import "./chunk-BTTUSTOZ.js";
import "./chunk-LH2VMHWZ.js";
import "./chunk-2FVEPLVQ.js";
import "./chunk-YOCIS3UP.js";
import "./chunk-DKDV73LI.js";
import "./chunk-JJXNSZ6B.js";
import "./chunk-VUBXZXWD.js";
import "./chunk-WE3EBNE7.js";
import "./chunk-XAUSENF3.js";
import "./chunk-SG4ORNH2.js";
import "./chunk-UMTV3SEQ.js";
import {
  FlattenedNodesObserver
} from "./chunk-4V7CPLV2.js";
import "./chunk-IOVQFHDT.js";
import "./chunk-5AS73FDI.js";
import "./chunk-DGKQRYYZ.js";
import "./chunk-NLOSRFQ7.js";
import "./chunk-37YVODLE.js";
import "./chunk-45DBWWZS.js";
import "./chunk-ZB6KQ55W.js";
import {
  DisabledMixin
} from "./chunk-PVLUQVE7.js";
import "./chunk-TXOUNVRU.js";
import {
  FocusMixin
} from "./chunk-ZCT3SKJI.js";
import "./chunk-DALKQVZ5.js";
import "./chunk-ZU2IWMPM.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import "./chunk-7OTQVW5F.js";
import "./chunk-D7TE3X7L.js";
import "./chunk-7S7VFRNQ.js";
import "./chunk-ZYZHRUSQ.js";
import "./chunk-2EAS4FPS.js";
import "./chunk-VUWTYCVF.js";
import "./chunk-RTIK5DCO.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import "./chunk-CQH3N2QY.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";
import "./chunk-A5QYNKPK.js";
import "./chunk-NCN7ELFS.js";
import "./chunk-CJPRR7ZF.js";

// node_modules/@vaadin/date-time-picker/theme/lumo/vaadin-date-time-picker-styles.js
registerStyles("vaadin-date-time-picker", [requiredField, helper, customField], {
  moduleId: "lumo-date-time-picker"
});
registerStyles(
  "vaadin-date-time-picker-date-picker",
  css`
    :host {
      margin-right: 2px;
    }

    /* RTL specific styles */
    :host([dir='rtl']) {
      margin-right: auto;
      margin-left: 2px;
    }

    [part~='input-field'] {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }

    /* RTL specific styles */
    :host([dir='rtl']) [part~='input-field'] {
      border-radius: var(--lumo-border-radius-m);
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }
  `,
  { moduleId: "lumo-date-time-picker-date-picker" }
);
registerStyles(
  "vaadin-date-time-picker-time-picker",
  css`
    [part~='input-field'] {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }

    /* RTL specific styles */
    :host([dir='rtl']) [part~='input-field'] {
      border-radius: var(--lumo-border-radius-m);
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
  `,
  { moduleId: "lumo-date-time-picker-time-picker" }
);

// node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker-date-picker.js
var DateTimePickerDatePicker = class extends DatePicker {
  static get is() {
    return "vaadin-date-time-picker-date-picker";
  }
};
customElements.define(DateTimePickerDatePicker.is, DateTimePickerDatePicker);

// node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker-time-picker.js
var DateTimePickerTimePicker = class extends TimePicker {
  static get is() {
    return "vaadin-date-time-picker-time-picker";
  }
};
customElements.define(DateTimePickerTimePicker.is, DateTimePickerTimePicker);

// node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker.js
registerStyles("vaadin-date-time-picker", inputFieldShared, { moduleId: "vaadin-date-time-picker" });
function getPropertyFromPrototype(clazz, prop) {
  while (clazz) {
    if (clazz.properties && clazz.properties[prop]) {
      return clazz.properties[prop];
    }
    clazz = Object.getPrototypeOf(clazz);
  }
}
var datePickerClass = customElements.get("vaadin-date-time-picker-date-picker");
var timePickerClass = customElements.get("vaadin-date-time-picker-time-picker");
var datePickerI18nDefaults = getPropertyFromPrototype(datePickerClass, "i18n").value();
var timePickerI18nDefaults = getPropertyFromPrototype(timePickerClass, "i18n").value();
var datePickerI18nProps = Object.keys(datePickerI18nDefaults);
var timePickerI18nProps = Object.keys(timePickerI18nDefaults);
var DateTimePicker = class extends FieldMixin(
  SlotMixin(DisabledMixin(FocusMixin(ThemableMixin(ElementMixin(PolymerElement)))))
) {
  static get template() {
    return html`
      <style>
        .vaadin-date-time-picker-container {
          --vaadin-field-default-width: auto;
        }

        .slots {
          display: flex;
          --vaadin-field-default-width: 12em;
        }

        .slots ::slotted([slot='date-picker']) {
          min-width: 0;
          flex: 1 1 auto;
        }

        .slots ::slotted([slot='time-picker']) {
          min-width: 0;
          flex: 1 1.65 auto;
        }
      </style>

      <div class="vaadin-date-time-picker-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="slots">
          <slot name="date-picker" id="dateSlot"></slot>
          <slot name="time-picker" id="timeSlot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-date-time-picker";
  }
  static get properties() {
    return {
      name: {
        type: String
      },
      value: {
        type: String,
        notify: true,
        value: "",
        observer: "__valueChanged"
      },
      min: {
        type: String,
        observer: "__minChanged"
      },
      max: {
        type: String,
        observer: "__maxChanged"
      },
      __minDateTime: {
        type: Date,
        value: ""
      },
      __maxDateTime: {
        type: Date,
        value: ""
      },
      datePlaceholder: {
        type: String
      },
      timePlaceholder: {
        type: String
      },
      step: {
        type: Number
      },
      initialPosition: String,
      showWeekNumbers: {
        type: Boolean
      },
      autoOpenDisabled: Boolean,
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      autofocus: {
        type: Boolean
      },
      __selectedDateTime: {
        type: Date
      },
      i18n: {
        type: Object,
        value: () => ({ ...datePickerI18nDefaults, ...timePickerI18nDefaults })
      },
      __datePicker: {
        type: HTMLElement,
        observer: "__datePickerChanged"
      },
      __timePicker: {
        type: HTMLElement,
        observer: "__timePickerChanged"
      }
    };
  }
  static get observers() {
    return [
      "__selectedDateTimeChanged(__selectedDateTime)",
      "__datePlaceholderChanged(datePlaceholder)",
      "__timePlaceholderChanged(timePlaceholder)",
      "__stepChanged(step)",
      "__initialPositionChanged(initialPosition)",
      "__showWeekNumbersChanged(showWeekNumbers)",
      "__requiredChanged(required)",
      "__invalidChanged(invalid)",
      "__disabledChanged(disabled)",
      "__readonlyChanged(readonly)",
      "__i18nChanged(i18n.*)",
      "__autoOpenDisabledChanged(autoOpenDisabled)",
      "__themeChanged(_theme, __datePicker, __timePicker)",
      "__pickersChanged(__datePicker, __timePicker)"
    ];
  }
  get slots() {
    return {
      ...super.slots,
      "date-picker": () => {
        const element = document.createElement("vaadin-date-time-picker-date-picker");
        element.__defaultPicker = true;
        return element;
      },
      "time-picker": () => {
        const element = document.createElement("vaadin-date-time-picker-time-picker");
        element.__defaultPicker = true;
        return element;
      }
    };
  }
  constructor() {
    super();
    this.__defaultDateMinMaxValue = void 0;
    this.__defaultTimeMinValue = "00:00:00.000";
    this.__defaultTimeMaxValue = "23:59:59.999";
    this.__changeEventHandler = this.__changeEventHandler.bind(this);
    this.__valueChangedEventHandler = this.__valueChangedEventHandler.bind(this);
    this._observer = new FlattenedNodesObserver(this, (info) => {
      this.__onDomChange(info.addedNodes);
    });
  }
  ready() {
    super.ready();
    this.__datePicker = this._getDirectSlotChild("date-picker");
    this.__timePicker = this._getDirectSlotChild("time-picker");
    if (this.autofocus && !this.disabled) {
      window.requestAnimationFrame(() => this.focus());
    }
    this.setAttribute("role", "group");
    this.ariaTarget = this;
  }
  focus() {
    this.__datePicker.focus();
  }
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.validate();
    }
  }
  _shouldRemoveFocus(event) {
    const target = event.relatedTarget;
    if (this.__datePicker.contains(target) || this.__timePicker.contains(target) || target === this.__datePicker.$.overlay) {
      return false;
    }
    return true;
  }
  __syncI18n(target, source, props) {
    props = props || Object.keys(source.i18n);
    props.forEach((prop) => {
      if (source.i18n && source.i18n.hasOwnProperty(prop)) {
        target.set(`i18n.${prop}`, source.i18n[prop]);
      }
    });
  }
  __changeEventHandler(event) {
    event.stopPropagation();
    if (this.__dispatchChangeForValue === this.value) {
      this.__dispatchChange();
      this.validate();
    }
    this.__dispatchChangeForValue = void 0;
  }
  __addInputListeners(node) {
    node.addEventListener("change", this.__changeEventHandler);
    node.addEventListener("value-changed", this.__valueChangedEventHandler);
  }
  __removeInputListeners(node) {
    node.removeEventListener("change", this.__changeEventHandler);
    node.removeEventListener("value-changed", this.__valueChangedEventHandler);
  }
  __onDomChange(addedNodes) {
    addedNodes.filter((node) => node.nodeType === Node.ELEMENT_NODE).forEach((node) => {
      const slotAttributeValue = node.getAttribute("slot");
      if (slotAttributeValue === "date-picker") {
        this.__datePicker = node;
      } else if (slotAttributeValue === "time-picker") {
        this.__timePicker = node;
      }
    });
    if (this.value && (this.min || this.max)) {
      this.validate();
    }
  }
  __datePickerChanged(newDatePicker, existingDatePicker) {
    if (!newDatePicker) {
      return;
    }
    if (existingDatePicker) {
      this.__removeInputListeners(existingDatePicker);
      existingDatePicker.remove();
    }
    this.__addInputListeners(newDatePicker);
    if (newDatePicker.__defaultPicker) {
      newDatePicker.placeholder = this.datePlaceholder;
      newDatePicker.invalid = this.invalid;
      newDatePicker.initialPosition = this.initialPosition;
      newDatePicker.showWeekNumbers = this.showWeekNumbers;
      this.__syncI18n(newDatePicker, this, datePickerI18nProps);
    } else {
      this.datePlaceholder = newDatePicker.placeholder;
      this.initialPosition = newDatePicker.initialPosition;
      this.showWeekNumbers = newDatePicker.showWeekNumbers;
      this.__syncI18n(this, newDatePicker, datePickerI18nProps);
    }
    newDatePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    newDatePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    newDatePicker.required = this.required;
    newDatePicker.disabled = this.disabled;
    newDatePicker.readonly = this.readonly;
    newDatePicker.autoOpenDisabled = this.autoOpenDisabled;
    newDatePicker.validate = () => {
    };
    newDatePicker._validateInput = () => {
    };
  }
  __timePickerChanged(newTimePicker, existingTimePicker) {
    if (!newTimePicker) {
      return;
    }
    if (existingTimePicker) {
      this.__removeInputListeners(existingTimePicker);
      existingTimePicker.remove();
    }
    this.__addInputListeners(newTimePicker);
    if (newTimePicker.__defaultPicker) {
      newTimePicker.placeholder = this.timePlaceholder;
      newTimePicker.step = this.step;
      newTimePicker.invalid = this.invalid;
      this.__syncI18n(newTimePicker, this, timePickerI18nProps);
    } else {
      this.timePlaceholder = newTimePicker.placeholder;
      this.step = newTimePicker.step;
      this.__syncI18n(this, newTimePicker, timePickerI18nProps);
    }
    this.__updateTimePickerMinMax();
    newTimePicker.required = this.required;
    newTimePicker.disabled = this.disabled;
    newTimePicker.readonly = this.readonly;
    newTimePicker.autoOpenDisabled = this.autoOpenDisabled;
    newTimePicker.validate = () => {
    };
  }
  __updateTimePickerMinMax() {
    if (this.__timePicker && this.__datePicker) {
      const selectedDate = this.__parseDate(this.__datePicker.value);
      const isMinMaxSameDay = dateEquals(this.__minDateTime, this.__maxDateTime);
      const oldTimeValue = this.__timePicker.value;
      if (this.__minDateTime && dateEquals(selectedDate, this.__minDateTime) || isMinMaxSameDay) {
        this.__timePicker.min = this.__dateToIsoTimeString(this.__minDateTime);
      } else {
        this.__timePicker.min = this.__defaultTimeMinValue;
      }
      if (this.__maxDateTime && dateEquals(selectedDate, this.__maxDateTime) || isMinMaxSameDay) {
        this.__timePicker.max = this.__dateToIsoTimeString(this.__maxDateTime);
      } else {
        this.__timePicker.max = this.__defaultTimeMaxValue;
      }
      if (this.__timePicker.value !== oldTimeValue) {
        this.__timePicker.value = oldTimeValue;
      }
    }
  }
  __i18nChanged(changeRecord) {
    if (this.__datePicker) {
      this.__datePicker.set(changeRecord.path, changeRecord.value);
    }
    if (this.__timePicker) {
      this.__timePicker.set(changeRecord.path, changeRecord.value);
    }
  }
  __datePlaceholderChanged(datePlaceholder) {
    if (this.__datePicker) {
      this.__datePicker.placeholder = datePlaceholder;
    }
  }
  __timePlaceholderChanged(timePlaceholder) {
    if (this.__timePicker) {
      this.__timePicker.placeholder = timePlaceholder;
    }
  }
  __stepChanged(step) {
    if (this.__timePicker && this.__timePicker.step !== step) {
      this.__timePicker.step = step;
    }
  }
  __initialPositionChanged(initialPosition) {
    if (this.__datePicker) {
      this.__datePicker.initialPosition = initialPosition;
    }
  }
  __showWeekNumbersChanged(showWeekNumbers) {
    if (this.__datePicker) {
      this.__datePicker.showWeekNumbers = showWeekNumbers;
    }
  }
  __invalidChanged(invalid) {
    if (this.__datePicker) {
      this.__datePicker.invalid = invalid;
    }
    if (this.__timePicker) {
      this.__timePicker.invalid = invalid;
    }
  }
  __requiredChanged(required) {
    if (this.__datePicker) {
      this.__datePicker.required = required;
    }
    if (this.__timePicker) {
      this.__timePicker.required = required;
    }
  }
  __disabledChanged(disabled) {
    if (this.__datePicker) {
      this.__datePicker.disabled = disabled;
    }
    if (this.__timePicker) {
      this.__timePicker.disabled = disabled;
    }
  }
  __readonlyChanged(readonly) {
    if (this.__datePicker) {
      this.__datePicker.readonly = readonly;
    }
    if (this.__timePicker) {
      this.__timePicker.readonly = readonly;
    }
  }
  __parseDate(str) {
    return datePickerClass.prototype._parseDate(str);
  }
  __formatDateISO(date, defaultValue) {
    if (!date) {
      return defaultValue;
    }
    return datePickerClass.prototype._formatISO(date);
  }
  __formatTimeISO(time) {
    return timePickerI18nDefaults.formatTime(time);
  }
  __parseTimeISO(str) {
    return timePickerI18nDefaults.parseTime(str);
  }
  __parseDateTime(str) {
    const [dateValue, timeValue] = str.split("T");
    if (!(dateValue && timeValue)) {
      return;
    }
    const date = this.__parseDate(dateValue);
    if (!date) {
      return;
    }
    const time = this.__parseTimeISO(timeValue);
    if (!time) {
      return;
    }
    date.setHours(parseInt(time.hours));
    date.setMinutes(parseInt(time.minutes || 0));
    date.setSeconds(parseInt(time.seconds || 0));
    date.setMilliseconds(parseInt(time.milliseconds || 0));
    return date;
  }
  __formatDateTime(date) {
    if (!date) {
      return "";
    }
    const dateValue = this.__formatDateISO(date, "");
    const timeValue = this.__dateToIsoTimeString(date);
    return `${dateValue}T${timeValue}`;
  }
  __dateToIsoTimeString(date) {
    return this.__formatTimeISO(
      this.__validateTime({
        hours: date.getHours(),
        minutes: date.getMinutes(),
        seconds: date.getSeconds(),
        milliseconds: date.getMilliseconds()
      })
    );
  }
  __validateTime(timeObject) {
    if (timeObject) {
      timeObject.seconds = this.__stepSegment < 3 ? void 0 : timeObject.seconds;
      timeObject.milliseconds = this.__stepSegment < 4 ? void 0 : timeObject.milliseconds;
    }
    return timeObject;
  }
  get __inputs() {
    return [this.__datePicker, this.__timePicker];
  }
  checkValidity() {
    const hasInvalidFields = this.__inputs.some((input) => !input.checkValidity());
    const hasEmptyFields = this.required && this.__inputs.some((el) => !el.value);
    if (hasInvalidFields || hasEmptyFields) {
      return false;
    }
    return true;
  }
  get __stepSegment() {
    const step = this.step == null ? 60 : parseFloat(this.step);
    if (step % 3600 === 0) {
      return 1;
    } else if (step % 60 === 0 || !step) {
      return 2;
    } else if (step % 1 === 0) {
      return 3;
    } else if (step < 1) {
      return 4;
    }
  }
  __dateTimeEquals(date1, date2) {
    if (!dateEquals(date1, date2)) {
      return false;
    }
    return date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes() && date1.getSeconds() === date2.getSeconds() && date1.getMilliseconds() === date2.getMilliseconds();
  }
  __handleDateTimeChange(property, parsedProperty, value, oldValue) {
    if (!value) {
      this[property] = "";
      this[parsedProperty] = "";
      return;
    }
    const dateTime = this.__parseDateTime(value);
    if (!dateTime) {
      this[property] = oldValue;
      return;
    }
    if (!this.__dateTimeEquals(this[parsedProperty], dateTime)) {
      this[parsedProperty] = dateTime;
    }
  }
  __valueChanged(value, oldValue) {
    this.__handleDateTimeChange("value", "__selectedDateTime", value, oldValue);
    if (oldValue !== void 0) {
      this.__dispatchChangeForValue = value;
    }
    this.toggleAttribute("has-value", !!value);
    this.__updateTimePickerMinMax();
  }
  __dispatchChange() {
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  __minChanged(value, oldValue) {
    this.__handleDateTimeChange("min", "__minDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
    if (this.__datePicker && this.__timePicker && this.value) {
      this.validate();
    }
  }
  __maxChanged(value, oldValue) {
    this.__handleDateTimeChange("max", "__maxDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
    if (this.__datePicker && this.__timePicker && this.value) {
      this.validate();
    }
  }
  __selectedDateTimeChanged(selectedDateTime) {
    const formattedValue = this.__formatDateTime(selectedDateTime);
    if (this.value !== formattedValue) {
      this.value = formattedValue;
    }
    const isDatePickerReady = Boolean(this.__datePicker && this.__datePicker.$);
    if (isDatePickerReady && !this.__ignoreInputValueChange) {
      this.__ignoreInputValueChange = true;
      const [dateValue, timeValue] = this.value.split("T");
      this.__datePicker.value = dateValue || "";
      this.__timePicker.value = timeValue || "";
      this.__ignoreInputValueChange = false;
    }
  }
  get __formattedValue() {
    const dateValue = this.__datePicker.value;
    const timeValue = this.__timePicker.value;
    if (dateValue && timeValue) {
      return [dateValue, timeValue].join("T");
    }
    return "";
  }
  __valueChangedEventHandler() {
    if (this.__ignoreInputValueChange) {
      return;
    }
    const value = this.__formattedValue;
    const [date, time] = value.split("T");
    this.__ignoreInputValueChange = true;
    this.__updateTimePickerMinMax();
    if (date && time) {
      if (value !== this.value) {
        this.value = value;
      }
    } else {
      this.value = "";
    }
    this.__ignoreInputValueChange = false;
  }
  __autoOpenDisabledChanged(autoOpenDisabled) {
    if (this.__datePicker) {
      this.__datePicker.autoOpenDisabled = autoOpenDisabled;
    }
    if (this.__timePicker) {
      this.__timePicker.autoOpenDisabled = autoOpenDisabled;
    }
  }
  __themeChanged(theme, datePicker, timePicker) {
    if (!datePicker || !timePicker) {
      return;
    }
    [datePicker, timePicker].forEach((picker) => {
      if (theme) {
        picker.setAttribute("theme", theme);
      } else {
        picker.removeAttribute("theme");
      }
    });
  }
  __pickersChanged(datePicker, timePicker) {
    if (!datePicker || !timePicker) {
      return;
    }
    if (datePicker.__defaultPicker !== timePicker.__defaultPicker) {
      return;
    }
    if (datePicker.value) {
      this.__valueChangedEventHandler();
    } else if (this.value) {
      this.__selectedDateTimeChanged(this.__selectedDateTime);
    }
  }
};
customElements.define(DateTimePicker.is, DateTimePicker);
/**
 * @license
 * Copyright (c) 2019 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_date-time-picker_theme_lumo_vaadin-date-time-picker__js.js.map
