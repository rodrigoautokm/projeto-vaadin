import {
  TemplateResultType,
  isTemplateResult
} from "./chunk-TCMLI3Z7.js";
import {
  Directive,
  PartType,
  directive
} from "./chunk-EH3S5RCB.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import {
  noChange,
  nothing,
  render,
  svg
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement
} from "./chunk-ZKSNVHJS.js";

// node_modules/lit-html/development/directives/unsafe-html.js
var HTML_RESULT = 1;
var UnsafeHTMLDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._value = nothing;
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
    }
  }
  render(value) {
    if (value === nothing || value == null) {
      this._templateResult = void 0;
      return this._value = value;
    }
    if (value === noChange) {
      return value;
    }
    if (typeof value != "string") {
      throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
    }
    if (value === this._value) {
      return this._templateResult;
    }
    this._value = value;
    const strings = [value];
    strings.raw = strings;
    return this._templateResult = {
      ["_$litType$"]: this.constructor.resultType,
      strings,
      values: []
    };
  }
};
UnsafeHTMLDirective.directiveName = "unsafeHTML";
UnsafeHTMLDirective.resultType = HTML_RESULT;
var unsafeHTML = directive(UnsafeHTMLDirective);

// node_modules/lit-html/development/directives/unsafe-svg.js
var SVG_RESULT = 2;
var UnsafeSVGDirective = class extends UnsafeHTMLDirective {
};
UnsafeSVGDirective.directiveName = "unsafeSVG";
UnsafeSVGDirective.resultType = SVG_RESULT;
var unsafeSVG = directive(UnsafeSVGDirective);

// node_modules/@vaadin/icon/src/vaadin-icon-svg.js
function cloneSvgNode(source) {
  let result = nothing;
  if (source) {
    const content = source.cloneNode(true);
    content.removeAttribute("id");
    result = svg`${unsafeSVG(content.outerHTML)}`;
  }
  return result;
}
function isValidSvg(source) {
  return isTemplateResult(source, TemplateResultType.SVG) || source === nothing;
}
function ensureSvgLiteral(source) {
  let result = source == null || source === "" ? nothing : source;
  if (!isValidSvg(result)) {
    console.error("[vaadin-icon] Invalid svg passed, please use Lit svg literal.");
    result = nothing;
  }
  return result;
}
function renderSvg(source, container) {
  const result = ensureSvgLiteral(source);
  render(result, container);
}
function unsafeSvgLiteral(source) {
  return svg`${unsafeSVG(source)}`;
}

// node_modules/@vaadin/icon/src/vaadin-iconset.js
var iconRegistry = {};
var Iconset = class extends ElementMixin(PolymerElement) {
  static get template() {
    return null;
  }
  static get is() {
    return "vaadin-iconset";
  }
  static get properties() {
    return {
      name: {
        type: String,
        observer: "__nameChanged"
      },
      size: {
        type: Number,
        value: 24
      }
    };
  }
  static getIconset(name) {
    let iconset = iconRegistry[name];
    if (!iconset) {
      iconset = document.createElement("vaadin-iconset");
      iconset.name = name;
      iconRegistry[name] = iconset;
    }
    return iconset;
  }
  connectedCallback() {
    super.connectedCallback();
    this.style.display = "none";
  }
  applyIcon(name) {
    this._icons = this._icons || this.__createIconMap();
    const icon = this._icons[this.__getIconId(name)];
    return {
      svg: cloneSvgNode(icon),
      size: this.size,
      viewBox: icon ? icon.getAttribute("viewBox") : null
    };
  }
  __createIconMap() {
    const icons = {};
    this.querySelectorAll("[id]").forEach((icon) => {
      icons[this.__getIconId(icon.id)] = icon;
    });
    return icons;
  }
  __getIconId(id) {
    return (id || "").replace(`${this.name}:`, "");
  }
  __nameChanged(name, oldName) {
    if (oldName) {
      iconRegistry[name] = Iconset.getIconset(oldName);
      delete iconRegistry[oldName];
    }
    if (name) {
      iconRegistry[name] = this;
      document.dispatchEvent(new CustomEvent("vaadin-iconset-registered", { detail: name }));
    }
  }
};
customElements.define(Iconset.is, Iconset);

export {
  cloneSvgNode,
  isValidSvg,
  ensureSvgLiteral,
  renderSvg,
  unsafeSvgLiteral,
  Iconset
};
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
//# sourceMappingURL=chunk-S5DBGBVD.js.map
