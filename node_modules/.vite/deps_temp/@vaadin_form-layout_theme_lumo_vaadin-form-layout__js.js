import {
  ResizeMixin
} from "./chunk-C2K2GOEG.js";
import {
  FlattenedNodesObserver
} from "./chunk-4V7CPLV2.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import "./chunk-D7TE3X7L.js";
import "./chunk-2EAS4FPS.js";
import "./chunk-VUWTYCVF.js";
import "./chunk-RTIK5DCO.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import "./chunk-CQH3N2QY.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";
import "./chunk-A5QYNKPK.js";
import "./chunk-NCN7ELFS.js";
import "./chunk-CJPRR7ZF.js";

// node_modules/@vaadin/form-layout/theme/lumo/vaadin-form-layout-styles.js
registerStyles(
  "vaadin-form-layout",
  css`
    :host {
      --vaadin-form-layout-column-spacing: var(--lumo-space-l);
    }
  `,
  { moduleId: "lumo-form-layout" }
);

// node_modules/@vaadin/form-layout/src/vaadin-form-layout.js
var FormLayout = class extends ResizeMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          max-width: 100%;
          animation: 1ms vaadin-form-layout-appear;
          /* CSS API for host */
          --vaadin-form-item-label-width: 8em;
          --vaadin-form-item-label-spacing: 1em;
          --vaadin-form-item-row-spacing: 1em;
          --vaadin-form-layout-column-spacing: 2em; /* (default) */
          align-self: stretch;
        }

        @keyframes vaadin-form-layout-appear {
          to {
            opacity: 1 !important; /* stylelint-disable-line keyframe-declaration-no-important */
          }
        }

        :host([hidden]) {
          display: none !important;
        }

        #layout {
          display: flex;

          align-items: baseline; /* default \`stretch\` is not appropriate */

          flex-wrap: wrap; /* the items should wrap */
        }

        #layout ::slotted(*) {
          /* Items should neither grow nor shrink. */
          flex-grow: 0;
          flex-shrink: 0;

          /* Margins make spacing between the columns */
          margin-left: calc(0.5 * var(--vaadin-form-layout-column-spacing));
          margin-right: calc(0.5 * var(--vaadin-form-layout-column-spacing));
        }

        #layout ::slotted(br) {
          display: none;
        }
      </style>
      <div id="layout">
        <slot id="slot"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-form-layout";
  }
  static get properties() {
    return {
      responsiveSteps: {
        type: Array,
        value() {
          return [
            { minWidth: 0, columns: 1, labelsPosition: "top" },
            { minWidth: "20em", columns: 1 },
            { minWidth: "40em", columns: 2 }
          ];
        },
        observer: "_responsiveStepsChanged"
      },
      _columnCount: {
        type: Number
      },
      _labelsOnTop: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["_invokeUpdateLayout(_columnCount, _labelsOnTop)"];
  }
  ready() {
    this._styleElement = document.createElement("style");
    this.appendChild(this._styleElement);
    this._styleElement.textContent = " ";
    super.ready();
    this.addEventListener("animationend", this.__onAnimationEnd);
  }
  connectedCallback() {
    super.connectedCallback();
    requestAnimationFrame(() => this._selectResponsiveStep());
    requestAnimationFrame(() => this._updateLayout());
    this._observeChildrenColspanChange();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__mutationObserver.disconnect();
    this.__childObserver.disconnect();
  }
  _observeChildrenColspanChange() {
    const mutationObserverConfig = { attributes: true };
    this.__mutationObserver = new MutationObserver((mutationRecord) => {
      mutationRecord.forEach((mutation) => {
        if (mutation.type === "attributes" && (mutation.attributeName === "colspan" || mutation.attributeName === "hidden")) {
          this._updateLayout();
        }
      });
    });
    this.__childObserver = new FlattenedNodesObserver(this, (info) => {
      const addedNodes = this._getObservableNodes(info.addedNodes);
      const removedNodes = this._getObservableNodes(info.removedNodes);
      addedNodes.forEach((child) => {
        this.__mutationObserver.observe(child, mutationObserverConfig);
      });
      if (addedNodes.length > 0 || removedNodes.length > 0) {
        this._updateLayout();
      }
    });
  }
  _getObservableNodes(nodeList) {
    const ignore = ["template", "style", "dom-repeat", "dom-if"];
    return Array.from(nodeList).filter(
      (node) => node.nodeType === Node.ELEMENT_NODE && ignore.indexOf(node.localName.toLowerCase()) === -1
    );
  }
  _naturalNumberOrOne(n) {
    if (typeof n === "number" && n >= 1 && n < Infinity) {
      return Math.floor(n);
    }
    return 1;
  }
  _isValidCSSLength(value) {
    if (value === "inherit" || value === "normal") {
      return false;
    }
    this._styleElement.firstChild.nodeValue = `#styleElement { word-spacing: ${value}; }`;
    if (!this._styleElement.sheet) {
      return true;
    }
    return ["", null].indexOf(this._styleElement.sheet.cssRules[0].style.getPropertyValue("word-spacing")) < 0;
  }
  _responsiveStepsChanged(responsiveSteps, oldResponsiveSteps) {
    try {
      if (!Array.isArray(responsiveSteps)) {
        throw new Error('Invalid "responsiveSteps" type, an Array is required.');
      }
      if (responsiveSteps.length < 1) {
        throw new Error('Invalid empty "responsiveSteps" array, at least one item is required.');
      }
      responsiveSteps.forEach((step) => {
        if (this._naturalNumberOrOne(step.columns) !== step.columns) {
          throw new Error(`Invalid 'columns' value of ${step.columns}, a natural number is required.`);
        }
        if (step.minWidth !== void 0 && !this._isValidCSSLength(step.minWidth)) {
          throw new Error(`Invalid 'minWidth' value of ${step.minWidth}, a valid CSS length required.`);
        }
        if (step.labelsPosition !== void 0 && ["aside", "top"].indexOf(step.labelsPosition) === -1) {
          throw new Error(
            `Invalid 'labelsPosition' value of ${step.labelsPosition}, 'aside' or 'top' string is required.`
          );
        }
      });
    } catch (e) {
      if (oldResponsiveSteps && oldResponsiveSteps !== responsiveSteps) {
        console.warn(`${e.message} Using previously set 'responsiveSteps' instead.`);
        this.responsiveSteps = oldResponsiveSteps;
      } else {
        console.warn(`${e.message} Using default 'responsiveSteps' instead.`);
        this.responsiveSteps = [
          { minWidth: 0, columns: 1, labelsPosition: "top" },
          { minWidth: "20em", columns: 1 },
          { minWidth: "40em", columns: 2 }
        ];
      }
    }
    this._selectResponsiveStep();
  }
  __onAnimationEnd(e) {
    if (e.animationName.indexOf("vaadin-form-layout-appear") === 0) {
      this._selectResponsiveStep();
    }
  }
  _selectResponsiveStep() {
    let selectedStep;
    const tmpStyleProp = "background-position";
    this.responsiveSteps.forEach((step) => {
      this.$.layout.style.setProperty(tmpStyleProp, step.minWidth);
      const stepMinWidthPx = parseFloat(getComputedStyle(this.$.layout).getPropertyValue(tmpStyleProp));
      if (stepMinWidthPx <= this.offsetWidth) {
        selectedStep = step;
      }
    });
    this.$.layout.style.removeProperty(tmpStyleProp);
    if (selectedStep) {
      this._columnCount = selectedStep.columns;
      this._labelsOnTop = selectedStep.labelsPosition === "top";
    }
  }
  _invokeUpdateLayout() {
    this._updateLayout();
  }
  updateStyles(properties = {}) {
    console.warn(
      `WARNING: Since Vaadin 23, updateStyles() is deprecated. Use the native element.style.setProperty API to set custom CSS property values.`
    );
    Object.entries(properties).forEach(([key, value]) => {
      this.style.setProperty(key, value);
    });
    this._updateLayout();
  }
  _updateLayout() {
    const style = getComputedStyle(this);
    const columnSpacing = style.getPropertyValue("--vaadin-form-layout-column-spacing");
    const direction = style.direction;
    const marginStartProp = `margin-${direction === "ltr" ? "left" : "right"}`;
    const marginEndProp = `margin-${direction === "ltr" ? "right" : "left"}`;
    const containerWidth = this.offsetWidth;
    let col = 0;
    Array.from(this.children).filter((child) => child.localName === "br" || getComputedStyle(child).display !== "none").forEach((child, index, children) => {
      if (child.localName === "br") {
        col = 0;
        return;
      }
      let colspan;
      colspan = this._naturalNumberOrOne(parseFloat(child.getAttribute("colspan")));
      colspan = Math.min(colspan, this._columnCount);
      const childRatio = colspan / this._columnCount;
      child.style.width = `calc(${childRatio * 99.9}% - ${1 - childRatio} * ${columnSpacing})`;
      if (col + colspan > this._columnCount) {
        col = 0;
      }
      if (col === 0) {
        child.style.setProperty(marginStartProp, "0px");
      } else {
        child.style.removeProperty(marginStartProp);
      }
      const nextIndex = index + 1;
      const nextLineBreak = nextIndex < children.length && children[nextIndex].localName === "br";
      if (col + colspan === this._columnCount) {
        child.style.setProperty(marginEndProp, "0px");
      } else if (nextLineBreak) {
        const colspanRatio = (this._columnCount - col - colspan) / this._columnCount;
        child.style.setProperty(
          marginEndProp,
          `calc(${colspanRatio * containerWidth}px + ${colspanRatio} * ${columnSpacing})`
        );
      } else {
        child.style.removeProperty(marginEndProp);
      }
      col = (col + colspan) % this._columnCount;
      if (child.localName === "vaadin-form-item") {
        if (this._labelsOnTop) {
          if (child.getAttribute("label-position") !== "top") {
            child.__useLayoutLabelPosition = true;
            child.setAttribute("label-position", "top");
          }
        } else if (child.__useLayoutLabelPosition) {
          delete child.__useLayoutLabelPosition;
          child.removeAttribute("label-position");
        }
      }
    });
  }
  _onResize() {
    this._selectResponsiveStep();
  }
};
customElements.define(FormLayout.is, FormLayout);
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_form-layout_theme_lumo_vaadin-form-layout__js.js.map
