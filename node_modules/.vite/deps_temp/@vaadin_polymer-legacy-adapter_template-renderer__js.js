import {
  templatize
} from "./chunk-VUBXZXWD.js";
import {
  FlattenedNodesObserver
} from "./chunk-4V7CPLV2.js";
import {
  PolymerElement
} from "./chunk-ZKSNVHJS.js";
import "./chunk-A5QYNKPK.js";
import "./chunk-NCN7ELFS.js";
import "./chunk-CJPRR7ZF.js";

// node_modules/@vaadin/polymer-legacy-adapter/src/template-renderer-templatizer.js
var Templatizer = class extends PolymerElement {
  static create(component, template) {
    const templatizer = new this();
    templatizer.__template = template;
    templatizer.__component = component;
    return templatizer;
  }
  static get is() {
    return "vaadin-template-renderer-templatizer";
  }
  constructor() {
    super();
    this.__template = null;
    this.__component = null;
    this.__TemplateClass = null;
    this.__templateInstances = /* @__PURE__ */ new Set();
  }
  render(element, properties = {}) {
    let instance = element.__templateInstance;
    if (this.__hasTemplateInstance(instance) && this.__isTemplateInstanceAttachedToDOM(instance)) {
      this.__updateProperties(instance, properties);
      return;
    }
    if (this.__hasTemplateInstance(instance)) {
      this.__disposeOfTemplateInstance(instance);
    }
    instance = this.__createTemplateInstance(properties);
    element.__templateInstance = instance;
    element.innerHTML = "";
    element.appendChild(instance.root);
  }
  __updateProperties(instance, properties) {
    if (instance.item === properties.item) {
      instance._setPendingProperty("item");
    }
    instance.__properties = properties;
    instance.setProperties(properties);
  }
  __createTemplateInstance(properties) {
    this.__createTemplateClass(properties);
    const instance = new this.__TemplateClass(properties);
    instance.__properties = properties;
    this.__templateInstances.add(instance);
    return instance;
  }
  __disposeOfTemplateInstance(instance) {
    this.__templateInstances.delete(instance);
  }
  __hasTemplateInstance(instance) {
    return this.__templateInstances.has(instance);
  }
  __isTemplateInstanceAttachedToDOM(instance) {
    if (instance.children.length === 0) {
      return false;
    }
    return !!instance.children[0].parentElement;
  }
  __createTemplateClass(properties) {
    if (this.__TemplateClass) {
      return;
    }
    const instanceProps = Object.keys(properties).reduce((accum, key) => {
      return { ...accum, [key]: true };
    }, {});
    this.__TemplateClass = templatize(this.__template, this, {
      parentModel: true,
      instanceProps,
      forwardHostProp(prop, value) {
        this.__templateInstances.forEach((instance) => {
          instance.forwardHostProp(prop, value);
        });
      },
      notifyInstanceProp(instance, path, value) {
        let rootProperty;
        rootProperty = path.split(".")[0];
        rootProperty = rootProperty[0].toUpperCase() + rootProperty.slice(1);
        const callback = `_on${rootProperty}PropertyChanged`;
        if (this[callback]) {
          this[callback](instance, path, value);
        }
      }
    });
  }
};
customElements.define(Templatizer.is, Templatizer);

// node_modules/@vaadin/polymer-legacy-adapter/src/template-renderer-grid-templatizer.js
var GridTemplatizer = class extends Templatizer {
  static get is() {
    return "vaadin-template-renderer-grid-templatizer";
  }
  _onItemPropertyChanged(instance, path, value) {
    if (path === "item") {
      return;
    }
    if (!Array.isArray(this.__grid.items)) {
      return;
    }
    const index = this.__grid.items.indexOf(instance.item);
    path = path.replace(/^item\./, "");
    path = `items.${index}.${path}`;
    this.__grid.notifyPath(path, value);
  }
  _onExpandedPropertyChanged(instance, _path, value) {
    if (instance.__properties.expanded === value) {
      return;
    }
    if (value) {
      this.__grid.expandItem(instance.item);
    } else {
      this.__grid.collapseItem(instance.item);
    }
  }
  _onSelectedPropertyChanged(instance, _path, value) {
    if (instance.__properties.selected === value) {
      return;
    }
    if (value) {
      this.__grid.selectItem(instance.item);
    } else {
      this.__grid.deselectItem(instance.item);
    }
  }
  _onDetailsOpenedPropertyChanged(instance, _path, value) {
    if (instance.__properties.detailsOpened === value) {
      return;
    }
    if (value) {
      this.__grid.openItemDetails(instance.item);
    } else {
      this.__grid.closeItemDetails(instance.item);
    }
  }
  get __grid() {
    if (this.__component.__gridElement) {
      return this.__component;
    }
    return this.__component._grid;
  }
};
customElements.define(GridTemplatizer.is, GridTemplatizer);

// node_modules/@vaadin/polymer-legacy-adapter/src/template-renderer.js
function createRenderer(component, template, TemplatizerClass = Templatizer) {
  const templatizer = TemplatizerClass.create(component, template);
  const renderer = (root, _owner, model) => {
    templatizer.render(root, model);
  };
  template.__templatizer = templatizer;
  renderer.__templatized = true;
  return renderer;
}
function assignRenderer(component, rendererName, renderer) {
  const oldRenderer = component[rendererName];
  if (oldRenderer && !oldRenderer.__templatized) {
    const tag = component.localName;
    throw new Error(`Cannot use both a template and a renderer for <${tag} />.`);
  }
  component[rendererName] = renderer;
}
function showTemplateWarning(component) {
  if (component.__suppressTemplateWarning) {
    return;
  }
  if (component.hasAttribute("suppress-template-warning")) {
    return;
  }
  console.warn(
    `WARNING: <template> inside <${component.localName}> is deprecated. Use a renderer function instead (see https://vaad.in/template-renderer)`
  );
  component.__suppressTemplateWarning = true;
}
function processGridTemplate(grid, template) {
  if (template.matches(".row-details")) {
    const renderer = createRenderer(grid, template, GridTemplatizer);
    assignRenderer(grid, "rowDetailsRenderer", renderer);
  }
}
function processGridColumnTemplate(column, template) {
  if (template.matches(".header")) {
    const renderer2 = createRenderer(column, template);
    assignRenderer(column, "headerRenderer", renderer2);
    return;
  }
  if (template.matches(".footer")) {
    const renderer2 = createRenderer(column, template);
    assignRenderer(column, "footerRenderer", renderer2);
    return;
  }
  if (template.matches(".editor")) {
    const renderer2 = createRenderer(column, template, GridTemplatizer);
    assignRenderer(column, "editModeRenderer", renderer2);
    return;
  }
  const renderer = createRenderer(column, template, GridTemplatizer);
  assignRenderer(column, "renderer", renderer);
}
function processTemplate(component, template) {
  showTemplateWarning(component);
  if (component.__gridElement) {
    processGridTemplate(component, template);
    return;
  }
  if (component.__gridColumnElement) {
    processGridColumnTemplate(component, template);
    return;
  }
  const renderer = createRenderer(component, template);
  assignRenderer(component, "renderer", renderer);
}
function processTemplates(component) {
  FlattenedNodesObserver.getFlattenedNodes(component).filter((child) => {
    return child instanceof HTMLTemplateElement;
  }).forEach((template) => {
    if (template.__templatizer) {
      return;
    }
    processTemplate(component, template);
  });
}
function observeTemplates(component) {
  if (component.__templateObserver) {
    return;
  }
  component.__templateObserver = new FlattenedNodesObserver(component, () => {
    processTemplates(component);
  });
}
window.Vaadin = window.Vaadin || {};
window.Vaadin.templateRendererCallback = (component) => {
  processTemplates(component);
  observeTemplates(component);
};
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_polymer-legacy-adapter_template-renderer__js.js.map
