import {
  processTemplates
} from "./chunk-CE2HX6X3.js";
import {
  Debouncer
} from "./chunk-VUWTYCVF.js";
import {
  DirMixin
} from "./chunk-RTIK5DCO.js";
import {
  animationFrame
} from "./chunk-CQH3N2QY.js";
import {
  PolymerElement
} from "./chunk-ZKSNVHJS.js";

// node_modules/@vaadin/grid/src/vaadin-grid-column.js
var ColumnBaseMixin = (superClass) => class ColumnBaseMixin extends superClass {
  static get properties() {
    return {
      resizable: {
        type: Boolean,
        value() {
          if (this.localName === "vaadin-grid-column-group") {
            return;
          }
          const parent = this.parentNode;
          if (parent && parent.localName === "vaadin-grid-column-group") {
            return parent.resizable || false;
          }
          return false;
        }
      },
      frozen: {
        type: Boolean,
        value: false
      },
      frozenToEnd: {
        type: Boolean,
        value: false
      },
      hidden: {
        type: Boolean,
        value: false
      },
      header: {
        type: String
      },
      textAlign: {
        type: String
      },
      _lastFrozen: {
        type: Boolean,
        value: false
      },
      _firstFrozenToEnd: {
        type: Boolean,
        value: false
      },
      _order: Number,
      _reorderStatus: Boolean,
      _emptyCells: Array,
      _headerCell: Object,
      _footerCell: Object,
      _grid: Object,
      __initialized: {
        type: Boolean,
        value: true
      },
      headerRenderer: Function,
      _headerRenderer: {
        type: Function,
        computed: "_computeHeaderRenderer(headerRenderer, header, __initialized)"
      },
      footerRenderer: Function,
      _footerRenderer: {
        type: Function,
        computed: "_computeFooterRenderer(footerRenderer, __initialized)"
      },
      __gridColumnElement: {
        type: Boolean,
        value: true
      }
    };
  }
  static get observers() {
    return [
      "_widthChanged(width, _headerCell, _footerCell, _cells.*)",
      "_frozenChanged(frozen, _headerCell, _footerCell, _cells.*)",
      "_frozenToEndChanged(frozenToEnd, _headerCell, _footerCell, _cells.*)",
      "_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells.*)",
      "_textAlignChanged(textAlign, _cells.*, _headerCell, _footerCell)",
      "_orderChanged(_order, _headerCell, _footerCell, _cells.*)",
      "_lastFrozenChanged(_lastFrozen)",
      "_firstFrozenToEndChanged(_firstFrozenToEnd)",
      "_onRendererOrBindingChanged(_renderer, _cells, _cells.*, path)",
      "_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header)",
      "_onFooterRendererOrBindingChanged(_footerRenderer, _footerCell)",
      "_resizableChanged(resizable, _headerCell)",
      "_reorderStatusChanged(_reorderStatus, _headerCell, _footerCell, _cells.*)",
      "_hiddenChanged(hidden, _headerCell, _footerCell, _cells.*)"
    ];
  }
  connectedCallback() {
    super.connectedCallback();
    requestAnimationFrame(() => {
      if (!this._grid) {
        return;
      }
      this._allCells.forEach((cell) => {
        if (!cell._content.parentNode) {
          this._grid.appendChild(cell._content);
        }
      });
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    requestAnimationFrame(() => {
      if (this._grid) {
        return;
      }
      this._allCells.forEach((cell) => {
        if (cell._content.parentNode) {
          cell._content.parentNode.removeChild(cell._content);
        }
      });
    });
    this._gridValue = void 0;
  }
  ready() {
    super.ready();
    processTemplates(this);
  }
  _findHostGrid() {
    let el = this;
    while (el && !/^vaadin.*grid(-pro)?$/.test(el.localName)) {
      el = el.assignedSlot ? el.assignedSlot.parentNode : el.parentNode;
    }
    return el || void 0;
  }
  get _grid() {
    if (!this._gridValue) {
      this._gridValue = this._findHostGrid();
    }
    return this._gridValue;
  }
  get _allCells() {
    return [].concat(this._cells || []).concat(this._emptyCells || []).concat(this._headerCell).concat(this._footerCell).filter((cell) => cell);
  }
  _renderHeaderAndFooter() {
    this._renderHeaderCellContent(this._headerRenderer, this._headerCell);
    this._renderFooterCellContent(this._footerRenderer, this._footerCell);
  }
  _flexGrowChanged(flexGrow) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("flexGrow");
    }
    this._allCells.forEach((cell) => {
      cell.style.flexGrow = flexGrow;
    });
  }
  _orderChanged(order) {
    this._allCells.forEach((cell) => {
      cell.style.order = order;
    });
  }
  _widthChanged(width) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("width");
    }
    this._allCells.forEach((cell) => {
      cell.style.width = width;
    });
  }
  _frozenChanged(frozen) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("frozen", frozen);
    }
    this._allCells.forEach((cell) => cell.toggleAttribute("frozen", frozen));
    if (this._grid && this._grid._frozenCellsChanged) {
      this._grid._frozenCellsChanged();
    }
  }
  _frozenToEndChanged(frozenToEnd) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("frozenToEnd", frozenToEnd);
    }
    this._allCells.forEach((cell) => {
      if (this._grid && cell.parentElement === this._grid.$.sizer) {
        return;
      }
      cell.toggleAttribute("frozen-to-end", frozenToEnd);
    });
    if (this._grid && this._grid._frozenCellsChanged) {
      this._grid._frozenCellsChanged();
    }
  }
  _lastFrozenChanged(lastFrozen) {
    this._allCells.forEach((cell) => cell.toggleAttribute("last-frozen", lastFrozen));
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._lastFrozen = lastFrozen;
    }
  }
  _firstFrozenToEndChanged(firstFrozenToEnd) {
    this._allCells.forEach((cell) => {
      if (this._grid && cell.parentElement === this._grid.$.sizer) {
        return;
      }
      cell.toggleAttribute("first-frozen-to-end", firstFrozenToEnd);
    });
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._firstFrozenToEnd = firstFrozenToEnd;
    }
  }
  _generateHeader(path) {
    return path.substr(path.lastIndexOf(".") + 1).replace(/([A-Z])/g, "-$1").toLowerCase().replace(/-/g, " ").replace(/^./, (match) => match.toUpperCase());
  }
  _reorderStatusChanged(reorderStatus) {
    this._allCells.forEach((cell) => cell.setAttribute("reorder-status", reorderStatus));
  }
  _resizableChanged(resizable, headerCell) {
    if (resizable === void 0 || headerCell === void 0) {
      return;
    }
    if (headerCell) {
      [headerCell].concat(this._emptyCells).forEach((cell) => {
        if (cell) {
          const existingHandle = cell.querySelector('[part~="resize-handle"]');
          if (existingHandle) {
            cell.removeChild(existingHandle);
          }
          if (resizable) {
            const handle = document.createElement("div");
            handle.setAttribute("part", "resize-handle");
            cell.appendChild(handle);
          }
        }
      });
    }
  }
  _textAlignChanged(textAlign) {
    if (textAlign === void 0) {
      return;
    }
    if (["start", "end", "center"].indexOf(textAlign) === -1) {
      console.warn('textAlign can only be set as "start", "end" or "center"');
      return;
    }
    let textAlignFallback;
    if (getComputedStyle(this._grid).direction === "ltr") {
      if (textAlign === "start") {
        textAlignFallback = "left";
      } else if (textAlign === "end") {
        textAlignFallback = "right";
      }
    } else if (textAlign === "start") {
      textAlignFallback = "right";
    } else if (textAlign === "end") {
      textAlignFallback = "left";
    }
    this._allCells.forEach((cell) => {
      cell._content.style.textAlign = textAlign;
      if (getComputedStyle(cell._content).textAlign !== textAlign) {
        cell._content.style.textAlign = textAlignFallback;
      }
    });
  }
  _hiddenChanged(hidden) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("hidden", hidden);
    }
    if (!!hidden !== !!this._previousHidden && this._grid) {
      if (hidden === true) {
        this._allCells.forEach((cell) => {
          if (cell._content.parentNode) {
            cell._content.parentNode.removeChild(cell._content);
          }
        });
      }
      this._grid._debouncerHiddenChanged = Debouncer.debounce(
        this._grid._debouncerHiddenChanged,
        animationFrame,
        () => {
          if (this._grid && this._grid._renderColumnTree) {
            this._grid._renderColumnTree(this._grid._columnTree);
          }
        }
      );
      if (this._grid._updateFrozenColumn) {
        this._grid._updateFrozenColumn();
      }
      if (this._grid._resetKeyboardNavigation) {
        this._grid._resetKeyboardNavigation();
      }
    }
    this._previousHidden = hidden;
  }
  _runRenderer(renderer, cell, model) {
    const args = [cell._content, this];
    if (model && model.item) {
      args.push(model);
    }
    renderer.apply(this, args);
  }
  __renderCellsContent(renderer, cells) {
    if (this.hidden || !this._grid) {
      return;
    }
    cells.forEach((cell) => {
      if (!cell.parentElement) {
        return;
      }
      const model = this._grid.__getRowModel(cell.parentElement);
      if (!renderer) {
        return;
      }
      if (cell._renderer !== renderer) {
        this._clearCellContent(cell);
      }
      cell._renderer = renderer;
      if (model.item || renderer === this._headerRenderer || renderer === this._footerRenderer) {
        this._runRenderer(renderer, cell, model);
      }
    });
  }
  _clearCellContent(cell) {
    cell._content.innerHTML = "";
    delete cell._content._$litPart$;
  }
  _renderHeaderCellContent(headerRenderer, headerCell) {
    if (!headerCell || !headerRenderer) {
      return;
    }
    this.__renderCellsContent(headerRenderer, [headerCell]);
    if (this._grid) {
      this._grid.__updateHeaderFooterRowVisibility(headerCell.parentElement);
    }
  }
  _onHeaderRendererOrBindingChanged(headerRenderer, headerCell, ..._bindings) {
    this._renderHeaderCellContent(headerRenderer, headerCell);
  }
  _renderBodyCellsContent(renderer, cells) {
    if (!cells || !renderer) {
      return;
    }
    this.__renderCellsContent(renderer, cells);
  }
  _onRendererOrBindingChanged(renderer, cells, ..._bindings) {
    this._renderBodyCellsContent(renderer, cells);
  }
  _renderFooterCellContent(footerRenderer, footerCell) {
    if (!footerCell || !footerRenderer) {
      return;
    }
    this.__renderCellsContent(footerRenderer, [footerCell]);
    if (this._grid) {
      this._grid.__updateHeaderFooterRowVisibility(footerCell.parentElement);
    }
  }
  _onFooterRendererOrBindingChanged(footerRenderer, footerCell) {
    this._renderFooterCellContent(footerRenderer, footerCell);
  }
  __setTextContent(node, textContent) {
    if (node.textContent !== textContent) {
      node.textContent = textContent;
    }
  }
  __textHeaderRenderer() {
    this.__setTextContent(this._headerCell._content, this.header);
  }
  _defaultHeaderRenderer() {
    if (!this.path) {
      return;
    }
    this.__setTextContent(this._headerCell._content, this._generateHeader(this.path));
  }
  _defaultRenderer(root, _owner, { item }) {
    if (!this.path) {
      return;
    }
    this.__setTextContent(root, this.get(this.path, item));
  }
  _defaultFooterRenderer() {
  }
  _computeHeaderRenderer(headerRenderer, header) {
    if (headerRenderer) {
      return headerRenderer;
    }
    if (header !== void 0 && header !== null) {
      return this.__textHeaderRenderer;
    }
    return this._defaultHeaderRenderer;
  }
  _computeRenderer(renderer) {
    if (renderer) {
      return renderer;
    }
    return this._defaultRenderer;
  }
  _computeFooterRenderer(footerRenderer) {
    if (footerRenderer) {
      return footerRenderer;
    }
    return this._defaultFooterRenderer;
  }
};
var GridColumn = class extends ColumnBaseMixin(DirMixin(PolymerElement)) {
  static get is() {
    return "vaadin-grid-column";
  }
  static get properties() {
    return {
      width: {
        type: String,
        value: "100px"
      },
      flexGrow: {
        type: Number,
        value: 1
      },
      renderer: Function,
      _renderer: {
        type: Function,
        computed: "_computeRenderer(renderer, __initialized)"
      },
      path: {
        type: String
      },
      autoWidth: {
        type: Boolean,
        value: false
      },
      _cells: Array
    };
  }
};
customElements.define(GridColumn.is, GridColumn);

export {
  ColumnBaseMixin,
  GridColumn
};
/**
 * @license
 * Copyright (c) 2016 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-5C7USDBP.js.map
