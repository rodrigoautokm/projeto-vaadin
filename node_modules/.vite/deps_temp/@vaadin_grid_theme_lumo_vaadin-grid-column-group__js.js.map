{
  "version": 3,
  "sources": ["../../@vaadin/grid/src/vaadin-grid-column-group.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2016 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { animationFrame, microTask } from '@vaadin/component-base/src/async.js';\nimport { Debouncer } from '@vaadin/component-base/src/debounce.js';\nimport { ColumnBaseMixin } from './vaadin-grid-column.js';\nimport { updateColumnOrders } from './vaadin-grid-helpers.js';\n\n/**\n * A `<vaadin-grid-column-group>` is used to make groups of columns in `<vaadin-grid>` and\n * to configure additional headers and footers.\n *\n * Groups can be nested to create complex header and footer configurations.\n *\n * #### Example:\n * ```html\n * <vaadin-grid-column-group resizable id=\"columnGroup\">\n *   <vaadin-grid-column id=\"column1\"></vaadin-grid-column>\n *   <vaadin-grid-column id=\"column2\"></vaadin-grid-column>\n * </vaadin-grid-column-group>\n * ```\n *\n * ```js\n * const columnGroup = document.querySelector('#columnGroup');\n * columnGroup.headerRenderer = (root, columnGroup) => {\n *   root.textContent = 'header';\n * }\n *\n * const column1 = document.querySelector('#column1');\n * column1.headerRenderer = (root, column) => { ... };\n * column1.renderer = (root, column, model) => { ... };\n *\n * const column2 = document.querySelector('#column2');\n * column2.headerRenderer = (root, column) => { ... };\n * column2.renderer = (root, column, model) => { ... };\n * ```\n *\n * @extends HTMLElement\n * @mixes ColumnBaseMixin\n */\nclass GridColumnGroup extends ColumnBaseMixin(PolymerElement) {\n  static get is() {\n    return 'vaadin-grid-column-group';\n  }\n\n  static get properties() {\n    return {\n      /** @private */\n      _childColumns: {\n        value() {\n          return this._getChildColumns(this);\n        },\n      },\n\n      /**\n       * Flex grow ratio for the column group as the sum of the ratios of its child columns.\n       * @attr {number} flex-grow\n       */\n      flexGrow: {\n        type: Number,\n        readOnly: true,\n      },\n\n      /**\n       * Width of the column group as the sum of the widths of its child columns.\n       */\n      width: {\n        type: String,\n        readOnly: true,\n      },\n\n      /** @private */\n      _visibleChildColumns: Array,\n\n      /** @private */\n      _colSpan: Number,\n\n      /** @private */\n      _rootColumns: Array,\n    };\n  }\n\n  static get observers() {\n    return [\n      '_groupFrozenChanged(frozen, _rootColumns)',\n      '_groupFrozenToEndChanged(frozenToEnd, _rootColumns)',\n      '_groupHiddenChanged(hidden)',\n      '_colSpanChanged(_colSpan, _headerCell, _footerCell)',\n      '_groupOrderChanged(_order, _rootColumns)',\n      '_groupReorderStatusChanged(_reorderStatus, _rootColumns)',\n      '_groupResizableChanged(resizable, _rootColumns)',\n    ];\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n    this._addNodeObserver();\n    this._updateFlexAndWidth();\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n  }\n\n  /**\n   * @param {string} path\n   * @param {unknown=} value\n   * @protected\n   */\n  _columnPropChanged(path, value) {\n    if (path === 'hidden') {\n      // Prevent synchronization of the hidden state to child columns.\n      // If the group is currently auto-hidden, and one column is made visible,\n      // we don't want the other columns to become visible as well.\n      this._preventHiddenSynchronization = true;\n      this._updateVisibleChildColumns(this._childColumns);\n      this._preventHiddenSynchronization = false;\n    }\n\n    if (/flexGrow|width|hidden|_childColumns/.test(path)) {\n      this._updateFlexAndWidth();\n    }\n\n    if (path === 'frozen') {\n      // Don\u2019t unfreeze the frozen group because of a non-frozen child\n      this.frozen = this.frozen || value;\n    }\n\n    if (path === 'lastFrozen') {\n      // Don\u2019t unfreeze the frozen group because of a non-frozen child\n      this._lastFrozen = this._lastFrozen || value;\n    }\n\n    if (path === 'frozenToEnd') {\n      // Don\u2019t unfreeze the frozen group because of a non-frozen child\n      this.frozenToEnd = this.frozenToEnd || value;\n    }\n\n    if (path === 'firstFrozenToEnd') {\n      // Don\u2019t unfreeze the frozen group because of a non-frozen child\n      this._firstFrozenToEnd = this._firstFrozenToEnd || value;\n    }\n  }\n\n  /** @private */\n  _groupOrderChanged(order, rootColumns) {\n    if (rootColumns) {\n      const _rootColumns = rootColumns.slice(0);\n\n      if (!order) {\n        _rootColumns.forEach((column) => {\n          column._order = 0;\n        });\n        return;\n      }\n      // The parent column order number cascades downwards to it's children\n      // so that the resulting order numbering constructs as follows:\n      // [             1000              ]\n      // [     1100    ] | [     1200    ]\n      // [1110] | [1120] | [1210] | [1220]\n\n      // Trailing zeros are counted so we know the level on which we're working on.\n      const trailingZeros = /(0+)$/.exec(order).pop().length;\n\n      // In an unlikely situation where a group has more than 9 child columns,\n      // the child scope must have 1 digit less...\n      // Log^a_b = Ln(a)/Ln(b)\n      // Number of digits of a number is equal to floor(Log(number)_10) + 1\n      const childCountDigits = ~~(Math.log(rootColumns.length) / Math.LN10) + 1;\n\n      // Final scope for the child columns needs to mind both factors.\n      const scope = 10 ** (trailingZeros - childCountDigits);\n\n      if (_rootColumns[0] && _rootColumns[0]._order) {\n        _rootColumns.sort((a, b) => a._order - b._order);\n      }\n      updateColumnOrders(_rootColumns, scope, order);\n    }\n  }\n\n  /** @private */\n  _groupReorderStatusChanged(reorderStatus, rootColumns) {\n    if (reorderStatus === undefined || rootColumns === undefined) {\n      return;\n    }\n\n    rootColumns.forEach((column) => {\n      column._reorderStatus = reorderStatus;\n    });\n  }\n\n  /** @private */\n  _groupResizableChanged(resizable, rootColumns) {\n    if (resizable === undefined || rootColumns === undefined) {\n      return;\n    }\n\n    rootColumns.forEach((column) => {\n      column.resizable = resizable;\n    });\n  }\n\n  /** @private */\n  _updateVisibleChildColumns(childColumns) {\n    this._visibleChildColumns = Array.prototype.filter.call(childColumns, (col) => !col.hidden);\n    this._colSpan = this._visibleChildColumns.length;\n    this._updateAutoHidden();\n  }\n\n  /** @protected */\n  _updateFlexAndWidth() {\n    if (!this._visibleChildColumns) {\n      return;\n    }\n\n    if (this._visibleChildColumns.length > 0) {\n      const width = this._visibleChildColumns\n        .reduce((prev, curr) => {\n          prev += ` + ${(curr.width || '0px').replace('calc', '')}`;\n          return prev;\n        }, '')\n        .substring(3);\n      this._setWidth(`calc(${width})`);\n    } else {\n      this._setWidth('0px');\n    }\n\n    this._setFlexGrow(Array.prototype.reduce.call(this._visibleChildColumns, (prev, curr) => prev + curr.flexGrow, 0));\n  }\n\n  /**\n   * This method is called before the group's frozen value is being propagated to the child columns.\n   * In case some of the child columns are frozen, while others are not, the non-frozen ones\n   * will get automatically frozen as well. As this may sometimes be unintended, this method\n   * shows a warning in the console in such cases.\n   * @private\n   */\n  __scheduleAutoFreezeWarning(columns, frozenProp) {\n    if (this._grid) {\n      // Derive the attribute name from the property name\n      const frozenAttr = frozenProp.replace(/([A-Z])/g, '-$1').toLowerCase();\n\n      // Check if all the columns have the same frozen value\n      const firstColumnFrozen = columns[0][frozenProp] || columns[0].hasAttribute(frozenAttr);\n      const allSameFrozen = columns.every((column) => {\n        return (column[frozenProp] || column.hasAttribute(frozenAttr)) === firstColumnFrozen;\n      });\n\n      if (!allSameFrozen) {\n        // Some of the child columns are frozen, some are not. Show a warning.\n        this._grid.__autoFreezeWarningDebouncer = Debouncer.debounce(\n          this._grid.__autoFreezeWarningDebouncer,\n          animationFrame,\n          () => {\n            console.warn(\n              `WARNING: Joining ${frozenProp} and non-${frozenProp} Grid columns inside the same column group! ` +\n                `This will automatically freeze all the joined columns to avoid rendering issues. ` +\n                `If this was intentional, consider marking each joined column explicitly as ${frozenProp}. ` +\n                `Otherwise, exclude the ${frozenProp} columns from the joined group.`,\n            );\n          },\n        );\n      }\n    }\n  }\n\n  /** @private */\n  _groupFrozenChanged(frozen, rootColumns) {\n    if (rootColumns === undefined || frozen === undefined) {\n      return;\n    }\n\n    // Don\u2019t propagate the default `false` value.\n    if (frozen !== false) {\n      this.__scheduleAutoFreezeWarning(rootColumns, 'frozen');\n\n      Array.from(rootColumns).forEach((col) => {\n        col.frozen = frozen;\n      });\n    }\n  }\n\n  /** @private */\n  _groupFrozenToEndChanged(frozenToEnd, rootColumns) {\n    if (rootColumns === undefined || frozenToEnd === undefined) {\n      return;\n    }\n\n    // Don\u2019t propagate the default `false` value.\n    if (frozenToEnd !== false) {\n      this.__scheduleAutoFreezeWarning(rootColumns, 'frozenToEnd');\n\n      Array.from(rootColumns).forEach((col) => {\n        col.frozenToEnd = frozenToEnd;\n      });\n    }\n  }\n\n  /** @private */\n  _groupHiddenChanged(hidden) {\n    // When initializing the hidden property, only sync hidden state to columns\n    // if group is actually hidden. Otherwise, we could override a hidden column\n    // to be visible.\n    // We always want to run this though if the property is actually changed.\n    if (hidden || this.__groupHiddenInitialized) {\n      this._synchronizeHidden();\n    }\n    this.__groupHiddenInitialized = true;\n  }\n\n  /** @private */\n  _updateAutoHidden() {\n    const wasAutoHidden = this._autoHidden;\n    this._autoHidden = (this._visibleChildColumns || []).length === 0;\n    // Only modify hidden state if group was auto-hidden, or becomes auto-hidden\n    if (wasAutoHidden || this._autoHidden) {\n      this.hidden = this._autoHidden;\n    }\n  }\n\n  /** @private */\n  _synchronizeHidden() {\n    if (this._childColumns && !this._preventHiddenSynchronization) {\n      this._childColumns.forEach((column) => {\n        column.hidden = this.hidden;\n      });\n    }\n  }\n\n  /** @private */\n  _colSpanChanged(colSpan, headerCell, footerCell) {\n    if (headerCell) {\n      headerCell.setAttribute('colspan', colSpan);\n      if (this._grid) {\n        this._grid._a11yUpdateCellColspan(headerCell, colSpan);\n      }\n    }\n    if (footerCell) {\n      footerCell.setAttribute('colspan', colSpan);\n      if (this._grid) {\n        this._grid._a11yUpdateCellColspan(footerCell, colSpan);\n      }\n    }\n  }\n\n  /**\n   * @param {!GridColumnGroup} el\n   * @return {!Array<!GridColumn>}\n   * @protected\n   */\n  _getChildColumns(el) {\n    return FlattenedNodesObserver.getFlattenedNodes(el).filter(this._isColumnElement);\n  }\n\n  /** @private */\n  _addNodeObserver() {\n    this._observer = new FlattenedNodesObserver(this, (info) => {\n      if (\n        info.addedNodes.filter(this._isColumnElement).length > 0 ||\n        info.removedNodes.filter(this._isColumnElement).length > 0\n      ) {\n        // Prevent synchronization of the hidden state to child columns.\n        // If the group is currently auto-hidden, and a visible column is added,\n        // we don't want the other columns to become visible as well.\n        this._preventHiddenSynchronization = true;\n        this._rootColumns = this._getChildColumns(this);\n        this._childColumns = this._rootColumns;\n        this._updateVisibleChildColumns(this._childColumns);\n        this._preventHiddenSynchronization = false;\n\n        // Update the column tree with microtask timing to avoid shady style scope issues\n        microTask.run(() => {\n          if (this._grid && this._grid._updateColumnTree) {\n            this._grid._updateColumnTree();\n          }\n        });\n      }\n    });\n    this._observer.flush();\n  }\n\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   * @protected\n   */\n  _isColumnElement(node) {\n    return node.nodeType === Node.ELEMENT_NODE && /\\bcolumn\\b/.test(node.localName);\n  }\n}\n\ncustomElements.define(GridColumnGroup.is, GridColumnGroup);\n\nexport { GridColumnGroup };\n"],
  "mappings": "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",
  "names": []
}
