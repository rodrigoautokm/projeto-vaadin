import {
  fieldShared,
  inputFieldContainer
} from "./chunk-VED5C5P5.js";
import {
  InputMixin
} from "./chunk-67AQUJJH.js";
import {
  DelegateStateMixin
} from "./chunk-5THRPDE7.js";
import {
  FieldMixin,
  ValidateMixin
} from "./chunk-FXYB4AC6.js";
import {
  DelegateFocusMixin
} from "./chunk-NEGQSXRC.js";
import {
  KeyboardMixin
} from "./chunk-TXOUNVRU.js";
import {
  Debouncer
} from "./chunk-VUWTYCVF.js";
import {
  timeOut
} from "./chunk-CQH3N2QY.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  dedupingMixin
} from "./chunk-NCN7ELFS.js";

// node_modules/@vaadin/field-base/src/input-constraints-mixin.js
var InputConstraintsMixin = dedupingMixin(
  (superclass) => class InputConstraintsMixinClass extends DelegateStateMixin(ValidateMixin(InputMixin(superclass))) {
    static get constraints() {
      return ["required"];
    }
    static get delegateAttrs() {
      return [...super.delegateAttrs, "required"];
    }
    ready() {
      super.ready();
      this._createConstraintsObserver();
    }
    checkValidity() {
      if (this.inputElement && this._hasValidConstraints(this.constructor.constraints.map((c) => this[c]))) {
        return this.inputElement.checkValidity();
      }
      return !this.invalid;
    }
    _hasValidConstraints(constraints) {
      return constraints.some((c) => this.__isValidConstraint(c));
    }
    _createConstraintsObserver() {
      this._createMethodObserver(`_constraintsChanged(stateTarget, ${this.constructor.constraints.join(", ")})`);
    }
    _constraintsChanged(stateTarget, ...constraints) {
      if (!stateTarget) {
        return;
      }
      const hasConstraints = this._hasValidConstraints(constraints);
      const isLastConstraintRemoved = this.__previousHasConstraints && !hasConstraints;
      if ((this._hasValue || this.invalid) && hasConstraints) {
        this.validate();
      } else if (isLastConstraintRemoved) {
        this._setInvalid(false);
      }
      this.__previousHasConstraints = hasConstraints;
    }
    _onChange(event) {
      event.stopPropagation();
      this.validate();
      this.dispatchEvent(
        new CustomEvent("change", {
          detail: {
            sourceEvent: event
          },
          bubbles: event.bubbles,
          cancelable: event.cancelable
        })
      );
    }
    __isValidConstraint(constraint) {
      return Boolean(constraint) || constraint === 0;
    }
  }
);

// node_modules/@vaadin/field-base/src/slot-styles-mixin.js
var stylesMap = /* @__PURE__ */ new WeakMap();
function getRootStyles(root) {
  if (!stylesMap.has(root)) {
    stylesMap.set(root, /* @__PURE__ */ new Set());
  }
  return stylesMap.get(root);
}
function insertStyles(styles, root) {
  const style = document.createElement("style");
  style.textContent = styles;
  if (root === document) {
    document.head.appendChild(style);
  } else {
    root.insertBefore(style, root.firstChild);
  }
}
var SlotStylesMixin = dedupingMixin(
  (superclass) => class SlotStylesMixinClass extends superclass {
    get slotStyles() {
      return {};
    }
    connectedCallback() {
      super.connectedCallback();
      this.__applySlotStyles();
    }
    __applySlotStyles() {
      const root = this.getRootNode();
      const rootStyles = getRootStyles(root);
      this.slotStyles.forEach((styles) => {
        if (!rootStyles.has(styles)) {
          insertStyles(styles, root);
          rootStyles.add(styles);
        }
      });
    }
  }
);

// node_modules/@vaadin/field-base/src/input-control-mixin.js
var InputControlMixin = (superclass) => class InputControlMixinClass extends SlotStylesMixin(
  DelegateFocusMixin(InputConstraintsMixin(FieldMixin(KeyboardMixin(superclass))))
) {
  static get properties() {
    return {
      allowedCharPattern: {
        type: String,
        observer: "_allowedCharPatternChanged"
      },
      autoselect: {
        type: Boolean,
        value: false
      },
      clearButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },
      name: {
        type: String,
        reflectToAttribute: true
      },
      placeholder: {
        type: String,
        reflectToAttribute: true
      },
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      title: {
        type: String,
        reflectToAttribute: true
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name", "type", "placeholder", "readonly", "invalid", "title"];
  }
  constructor() {
    super();
    this._boundOnPaste = this._onPaste.bind(this);
    this._boundOnDrop = this._onDrop.bind(this);
    this._boundOnBeforeInput = this._onBeforeInput.bind(this);
  }
  get clearElement() {
    console.warn(`Please implement the 'clearElement' property in <${this.localName}>`);
    return null;
  }
  get slotStyles() {
    return [
      `
          :is(input[slot='input'], textarea[slot='textarea'])::placeholder {
            font: inherit;
            color: inherit;
          }
        `
    ];
  }
  ready() {
    super.ready();
    if (this.clearElement) {
      this.clearElement.addEventListener("click", (e) => this._onClearButtonClick(e));
    }
  }
  _onClearButtonClick(event) {
    event.preventDefault();
    this.inputElement.focus();
    this.__clear();
  }
  _onFocus(event) {
    super._onFocus(event);
    if (this.autoselect && this.inputElement) {
      this.inputElement.select();
    }
  }
  _onEscape(event) {
    super._onEscape(event);
    if (this.clearButtonVisible && !!this.value) {
      event.stopPropagation();
      this.__clear();
    }
  }
  _onChange(event) {
    event.stopPropagation();
    this.validate();
    this.dispatchEvent(
      new CustomEvent("change", {
        detail: {
          sourceEvent: event
        },
        bubbles: event.bubbles,
        cancelable: event.cancelable
      })
    );
  }
  __clear() {
    this.clear();
    this.inputElement.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    this.inputElement.dispatchEvent(new Event("change", { bubbles: true }));
  }
  _addInputListeners(input) {
    super._addInputListeners(input);
    input.addEventListener("paste", this._boundOnPaste);
    input.addEventListener("drop", this._boundOnDrop);
    input.addEventListener("beforeinput", this._boundOnBeforeInput);
  }
  _removeInputListeners(input) {
    super._removeInputListeners(input);
    input.removeEventListener("paste", this._boundOnPaste);
    input.removeEventListener("drop", this._boundOnDrop);
    input.removeEventListener("beforeinput", this._boundOnBeforeInput);
  }
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (this.allowedCharPattern && !this.__shouldAcceptKey(event)) {
      event.preventDefault();
      this._markInputPrevented();
    }
  }
  _markInputPrevented() {
    this.setAttribute("input-prevented", "");
    this._preventInputDebouncer = Debouncer.debounce(this._preventInputDebouncer, timeOut.after(200), () => {
      this.removeAttribute("input-prevented");
    });
  }
  __shouldAcceptKey(event) {
    return event.metaKey || event.ctrlKey || !event.key || event.key.length !== 1 || this.__allowedCharRegExp.test(event.key);
  }
  _onPaste(e) {
    if (this.allowedCharPattern) {
      const pastedText = e.clipboardData.getData("text");
      if (!this.__allowedTextRegExp.test(pastedText)) {
        e.preventDefault();
        this._markInputPrevented();
      }
    }
  }
  _onDrop(e) {
    if (this.allowedCharPattern) {
      const draggedText = e.dataTransfer.getData("text");
      if (!this.__allowedTextRegExp.test(draggedText)) {
        e.preventDefault();
        this._markInputPrevented();
      }
    }
  }
  _onBeforeInput(e) {
    if (this.allowedCharPattern && e.data && !this.__allowedTextRegExp.test(e.data)) {
      e.preventDefault();
      this._markInputPrevented();
    }
  }
  _allowedCharPatternChanged(charPattern) {
    if (charPattern) {
      try {
        this.__allowedCharRegExp = new RegExp(`^${charPattern}$`);
        this.__allowedTextRegExp = new RegExp(`^${charPattern}*$`);
      } catch (e) {
        console.error(e);
      }
    }
  }
};

// node_modules/@vaadin/field-base/src/styles/clear-button-styles.js
var clearButton = css`
  [part='clear-button'] {
    display: none;
    cursor: default;
  }

  [part='clear-button']::before {
    content: 'âœ•';
  }

  :host([clear-button-visible][has-value]:not([disabled]):not([readonly])) [part='clear-button'] {
    display: block;
  }
`;

// node_modules/@vaadin/field-base/src/styles/input-field-shared-styles.js
var inputFieldShared = [fieldShared, inputFieldContainer, clearButton];

export {
  InputConstraintsMixin,
  InputControlMixin,
  inputFieldShared
};
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-KP6A4WLM.js.map
