import {
  ComboBoxPlaceholder
} from "./chunk-BFM7G6QE.js";

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js
var ComboBoxDataProviderMixin = (superClass) => class DataProviderMixin extends superClass {
  static get properties() {
    return {
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged"
      },
      size: {
        type: Number,
        observer: "_sizeChanged"
      },
      dataProvider: {
        type: Object,
        observer: "_dataProviderChanged"
      },
      _pendingRequests: {
        value: () => {
          return {};
        }
      },
      __placeHolder: {
        value: new ComboBoxPlaceholder()
      },
      __previousDataProviderFilter: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "_dataProviderFilterChanged(filter)",
      "_warnDataProviderValue(dataProvider, value)",
      "_ensureFirstPage(opened)"
    ];
  }
  ready() {
    super.ready();
    this._scroller.addEventListener("index-requested", (e) => {
      const index = e.detail.index;
      const currentScrollerPos = e.detail.currentScrollerPos;
      const allowedIndexRange = Math.floor(this.pageSize * 1.5);
      if (this._shouldSkipIndex(index, allowedIndexRange, currentScrollerPos)) {
        return;
      }
      if (index !== void 0) {
        const page = this._getPageForIndex(index);
        if (this._shouldLoadPage(page)) {
          this._loadPage(page);
        }
      }
    });
  }
  _dataProviderFilterChanged(filter) {
    if (this.__previousDataProviderFilter === void 0 && filter === "") {
      this.__previousDataProviderFilter = filter;
      return;
    }
    if (this.__previousDataProviderFilter !== filter) {
      this.__previousDataProviderFilter = filter;
      this._pendingRequests = {};
      this.loading = this._shouldFetchData();
      this.size = void 0;
      this.clearCache();
    }
  }
  _shouldFetchData() {
    if (!this.dataProvider) {
      return false;
    }
    return this.opened || this.filter && this.filter.length;
  }
  _ensureFirstPage(opened) {
    if (opened && this._shouldLoadPage(0)) {
      this._loadPage(0);
    }
  }
  _shouldSkipIndex(index, allowedIndexRange, currentScrollerPos) {
    return currentScrollerPos !== 0 && index >= currentScrollerPos - allowedIndexRange && index <= currentScrollerPos + allowedIndexRange;
  }
  _shouldLoadPage(page) {
    if (!this.filteredItems || this._forceNextRequest) {
      this._forceNextRequest = false;
      return true;
    }
    const loadedItem = this.filteredItems[page * this.pageSize];
    if (loadedItem !== void 0) {
      return loadedItem instanceof ComboBoxPlaceholder;
    }
    return this.size === void 0;
  }
  _loadPage(page) {
    if (this._pendingRequests[page] || !this.dataProvider) {
      return;
    }
    const params = {
      page,
      pageSize: this.pageSize,
      filter: this.filter
    };
    const callback = (items, size) => {
      if (this._pendingRequests[page] !== callback) {
        return;
      }
      const filteredItems = this.filteredItems ? [...this.filteredItems] : [];
      filteredItems.splice(params.page * params.pageSize, items.length, ...items);
      this.filteredItems = filteredItems;
      if (!this.opened && !this._isInputFocused()) {
        this._commitValue();
      }
      if (size !== void 0) {
        this.size = size;
      }
      delete this._pendingRequests[page];
      if (Object.keys(this._pendingRequests).length === 0) {
        this.loading = false;
      }
    };
    this._pendingRequests[page] = callback;
    this.loading = true;
    this.dataProvider(params, callback);
  }
  _getPageForIndex(index) {
    return Math.floor(index / this.pageSize);
  }
  clearCache() {
    if (!this.dataProvider) {
      return;
    }
    this._pendingRequests = {};
    const filteredItems = [];
    for (let i = 0; i < (this.size || 0); i++) {
      filteredItems.push(this.__placeHolder);
    }
    this.filteredItems = filteredItems;
    if (this._shouldFetchData()) {
      this._forceNextRequest = false;
      this._loadPage(0);
    } else {
      this._forceNextRequest = true;
    }
  }
  _sizeChanged(size = 0) {
    const filteredItems = (this.filteredItems || []).slice(0, size);
    for (let i = 0; i < size; i++) {
      filteredItems[i] = filteredItems[i] !== void 0 ? filteredItems[i] : this.__placeHolder;
    }
    this.filteredItems = filteredItems;
    this._flushPendingRequests(size);
  }
  _pageSizeChanged(pageSize, oldPageSize) {
    if (Math.floor(pageSize) !== pageSize || pageSize < 1) {
      this.pageSize = oldPageSize;
      throw new Error("`pageSize` value must be an integer > 0");
    }
    this.clearCache();
  }
  _dataProviderChanged(dataProvider, oldDataProvider) {
    this._ensureItemsOrDataProvider(() => {
      this.dataProvider = oldDataProvider;
    });
    this.clearCache();
  }
  _ensureItemsOrDataProvider(restoreOldValueCallback) {
    if (this.items !== void 0 && this.dataProvider !== void 0) {
      restoreOldValueCallback();
      throw new Error("Using `items` and `dataProvider` together is not supported");
    } else if (this.dataProvider && !this.filteredItems) {
      this.filteredItems = [];
    }
  }
  _warnDataProviderValue(dataProvider, value) {
    if (dataProvider && value !== "" && (this.selectedItem === void 0 || this.selectedItem === null)) {
      const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);
      if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {
        console.warn(
          "Warning: unable to determine the label for the provided `value`. Nothing to display in the text field. This usually happens when setting an initial `value` before any items are returned from the `dataProvider` callback. Consider setting `selectedItem` instead of `value`"
        );
      }
    }
  }
  _flushPendingRequests(size) {
    if (this._pendingRequests) {
      const lastPage = Math.ceil(size / this.pageSize);
      const pendingRequestsKeys = Object.keys(this._pendingRequests);
      for (let reqIdx = 0; reqIdx < pendingRequestsKeys.length; reqIdx++) {
        const page = parseInt(pendingRequestsKeys[reqIdx]);
        if (page >= lastPage) {
          this._pendingRequests[page]([], size);
        }
      }
    }
  }
};

export {
  ComboBoxDataProviderMixin
};
/**
 * @license
 * Copyright (c) 2015 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-QJITDA57.js.map
