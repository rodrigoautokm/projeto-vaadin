import {
  Virtualizer
} from "./chunk-T7QYKO45.js";
import {
  ComboBoxPlaceholder
} from "./chunk-BFM7G6QE.js";
import {
  processTemplates
} from "./chunk-CE2HX6X3.js";
import {
  VirtualKeyboardController
} from "./chunk-LKZC625W.js";
import {
  InputMixin
} from "./chunk-67AQUJJH.js";
import {
  generateUniqueId
} from "./chunk-26L5GZ27.js";
import {
  item
} from "./chunk-Q6GVJPMX.js";
import {
  menuOverlayCore
} from "./chunk-E2XIUAPG.js";
import {
  PositionMixin
} from "./chunk-BTTUSTOZ.js";
import {
  OverlayElement,
  overlay
} from "./chunk-LH2VMHWZ.js";
import {
  isTouch
} from "./chunk-XAUSENF3.js";
import {
  ControllerMixin
} from "./chunk-SG4ORNH2.js";
import {
  DisabledMixin
} from "./chunk-PVLUQVE7.js";
import {
  KeyboardMixin
} from "./chunk-TXOUNVRU.js";
import {
  isElementFocused
} from "./chunk-7OTQVW5F.js";
import {
  DirMixin
} from "./chunk-RTIK5DCO.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";

// node_modules/@vaadin/vaadin-lumo-styles/mixins/loader.js
var loader = css`
  [part~='loader'] {
    box-sizing: border-box;
    width: var(--lumo-icon-size-s);
    height: var(--lumo-icon-size-s);
    border: 2px solid transparent;
    border-color: var(--lumo-primary-color-10pct) var(--lumo-primary-color-10pct) var(--lumo-primary-color)
      var(--lumo-primary-color);
    border-radius: calc(0.5 * var(--lumo-icon-size-s));
    opacity: 0;
    pointer-events: none;
  }

  :host(:not([loading])) [part~='loader'] {
    display: none;
  }

  :host([loading]) [part~='loader'] {
    animation: 1s linear infinite lumo-loader-rotate, 0.3s 0.1s lumo-loader-fade-in both;
  }

  @keyframes lumo-loader-fade-in {
    0% {
      opacity: 0;
    }

    100% {
      opacity: 1;
    }
  }

  @keyframes lumo-loader-rotate {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }
`;

// node_modules/@vaadin/combo-box/theme/lumo/vaadin-combo-box-dropdown-styles.js
var comboBoxOverlay = css`
  [part='content'] {
    padding: 0;
  }

  :host {
    --_vaadin-combo-box-items-container-border-width: var(--lumo-space-xs);
    --_vaadin-combo-box-items-container-border-style: solid;
    --_vaadin-combo-box-items-container-border-color: transparent;
  }

  /* Loading state */

  /* When items are empty, the spinner needs some room */
  :host(:not([closing])) [part~='content'] {
    min-height: calc(2 * var(--lumo-space-s) + var(--lumo-icon-size-s));
  }

  [part~='overlay'] {
    position: relative;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }

  [part~='loader'] {
    position: absolute;
    z-index: 1;
    left: var(--lumo-space-s);
    right: var(--lumo-space-s);
    top: var(--lumo-space-s);
    margin-left: auto;
    margin-inline-start: auto;
    margin-inline-end: 0;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part~='loader'] {
    left: auto;
    margin-left: 0;
    margin-right: auto;
    margin-inline-start: 0;
    margin-inline-end: auto;
  }
`;
registerStyles("vaadin-combo-box-overlay", [overlay, menuOverlayCore, comboBoxOverlay, loader], {
  moduleId: "lumo-combo-box-overlay"
});

// node_modules/@vaadin/combo-box/theme/lumo/vaadin-combo-box-item-styles.js
var comboBoxItem = css`
  :host {
    transition: background-color 100ms;
    overflow: hidden;
    --_lumo-item-selected-icon-display: block;
  }

  @media (any-hover: hover) {
    :host([focused]:not([disabled])) {
      box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);
    }
  }
`;
registerStyles("vaadin-combo-box-item", [item, comboBoxItem], {
  moduleId: "lumo-combo-box-item"
});

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js
var ComboBoxItem = class extends ThemableMixin(DirMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-combo-box-item";
  }
  static get properties() {
    return {
      index: Number,
      item: Object,
      label: String,
      selected: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      focused: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      renderer: Function,
      _oldRenderer: Function
    };
  }
  static get observers() {
    return ["__rendererOrItemChanged(renderer, index, item.*, selected, focused)", "__updateLabel(label, renderer)"];
  }
  connectedCallback() {
    super.connectedCallback();
    this._comboBox = this.parentNode.comboBox;
    const hostDir = this._comboBox.getAttribute("dir");
    if (hostDir) {
      this.setAttribute("dir", hostDir);
    }
  }
  requestContentUpdate() {
    if (!this.renderer) {
      return;
    }
    const model = {
      index: this.index,
      item: this.item,
      focused: this.focused,
      selected: this.selected
    };
    this.renderer(this, this._comboBox, model);
  }
  __rendererOrItemChanged(renderer, index, item2) {
    if (item2 === void 0 || index === void 0) {
      return;
    }
    if (this._oldRenderer !== renderer) {
      this.innerHTML = "";
      delete this._$litPart$;
    }
    if (renderer) {
      this._oldRenderer = renderer;
      this.requestContentUpdate();
    }
  }
  __updateLabel(label, renderer) {
    if (renderer) {
      return;
    }
    this.textContent = label;
  }
};
customElements.define(ComboBoxItem.is, ComboBoxItem);

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js
registerStyles(
  "vaadin-combo-box-overlay",
  css`
    #overlay {
      width: var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));
    }

    [part='content'] {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
  `,
  { moduleId: "vaadin-combo-box-overlay-styles" }
);
var memoizedTemplate;
var ComboBoxOverlay = class extends PositionMixin(OverlayElement) {
  static get is() {
    return "vaadin-combo-box-overlay";
  }
  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = super.template.cloneNode(true);
      memoizedTemplate.content.querySelector('[part~="overlay"]').removeAttribute("tabindex");
    }
    return memoizedTemplate;
  }
  static get observers() {
    return ["_setOverlayWidth(positionTarget, opened)"];
  }
  connectedCallback() {
    super.connectedCallback();
    const comboBox = this._comboBox;
    const hostDir = comboBox && comboBox.getAttribute("dir");
    if (hostDir) {
      this.setAttribute("dir", hostDir);
    }
  }
  ready() {
    super.ready();
    const loader2 = document.createElement("div");
    loader2.setAttribute("part", "loader");
    const content = this.shadowRoot.querySelector('[part~="content"]');
    content.parentNode.insertBefore(loader2, content);
  }
  _outsideClickListener(event) {
    const eventPath = event.composedPath();
    if (!eventPath.includes(this.positionTarget) && !eventPath.includes(this)) {
      this.close();
    }
  }
  _setOverlayWidth(positionTarget, opened) {
    if (positionTarget && opened) {
      const propPrefix = this.localName;
      this.style.setProperty(`--_${propPrefix}-default-width`, `${positionTarget.clientWidth}px`);
      const customWidth = getComputedStyle(this._comboBox).getPropertyValue(`--${propPrefix}-width`);
      if (customWidth === "") {
        this.style.removeProperty(`--${propPrefix}-width`);
      } else {
        this.style.setProperty(`--${propPrefix}-width`, customWidth);
      }
      this._updatePosition();
    }
  }
};
customElements.define(ComboBoxOverlay.is, ComboBoxOverlay);

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js
var ComboBoxScroller = class extends PolymerElement {
  static get is() {
    return "vaadin-combo-box-scroller";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-combo-box-items-container-border-width);
          border-style: var(--_vaadin-combo-box-items-container-border-style);
          border-color: var(--_vaadin-combo-box-items-container-border-color);
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      items: {
        type: Array,
        observer: "__itemsChanged"
      },
      focusedIndex: {
        type: Number,
        observer: "__focusedIndexChanged"
      },
      loading: {
        type: Boolean,
        observer: "__loadingChanged"
      },
      opened: {
        type: Boolean,
        observer: "__openedChanged"
      },
      selectedItem: {
        type: Object,
        observer: "__selectedItemChanged"
      },
      itemIdPath: {
        type: String
      },
      comboBox: {
        type: Object
      },
      getItemLabel: {
        type: Object
      },
      renderer: {
        type: Object,
        observer: "__rendererChanged"
      },
      theme: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.__boundOnItemClick = this.__onItemClick.bind(this);
  }
  __openedChanged(opened) {
    if (opened) {
      this.requestContentUpdate();
    }
  }
  ready() {
    super.ready();
    this.id = `${this.localName}-${generateUniqueId()}`;
    this.__hostTagName = this.constructor.is.replace("-scroller", "");
    this.setAttribute("role", "listbox");
    this.addEventListener("click", (e) => e.stopPropagation());
    this.__patchWheelOverScrolling();
    this.__virtualizer = new Virtualizer({
      createElements: this.__createElements.bind(this),
      updateElement: this.__updateElement.bind(this),
      elementsContainer: this,
      scrollTarget: this,
      scrollContainer: this.$.selector
    });
  }
  requestContentUpdate() {
    if (this.__virtualizer) {
      this.__virtualizer.update();
    }
  }
  scrollIntoView(index) {
    if (!(this.opened && index >= 0)) {
      return;
    }
    const visibleItemsCount = this._visibleItemsCount();
    let targetIndex = index;
    if (index > this.__virtualizer.lastVisibleIndex - 1) {
      this.__virtualizer.scrollToIndex(index);
      targetIndex = index - visibleItemsCount + 1;
    } else if (index > this.__virtualizer.firstVisibleIndex) {
      targetIndex = this.__virtualizer.firstVisibleIndex;
    }
    this.__virtualizer.scrollToIndex(Math.max(0, targetIndex));
    const lastPhysicalItem = [...this.children].find(
      (el) => !el.hidden && el.index === this.__virtualizer.lastVisibleIndex
    );
    if (!lastPhysicalItem || index !== lastPhysicalItem.index) {
      return;
    }
    const lastPhysicalItemRect = lastPhysicalItem.getBoundingClientRect();
    const scrollerRect = this.getBoundingClientRect();
    const scrollTopAdjust = lastPhysicalItemRect.bottom - scrollerRect.bottom + this._viewportTotalPaddingBottom;
    if (scrollTopAdjust > 0) {
      this.scrollTop += scrollTopAdjust;
    }
  }
  __getAriaRole(itemIndex) {
    return itemIndex !== void 0 ? "option" : false;
  }
  __getAriaSelected(focusedIndex, itemIndex) {
    return this.__isItemFocused(focusedIndex, itemIndex).toString();
  }
  __isItemFocused(focusedIndex, itemIndex) {
    return !this.loading && focusedIndex === itemIndex;
  }
  __isItemSelected(item2, selectedItem, itemIdPath) {
    if (item2 instanceof ComboBoxPlaceholder) {
      return false;
    } else if (itemIdPath && item2 !== void 0 && selectedItem !== void 0) {
      return this.get(itemIdPath, item2) === this.get(itemIdPath, selectedItem);
    }
    return item2 === selectedItem;
  }
  __itemsChanged(items) {
    if (this.__virtualizer && items) {
      this.__virtualizer.size = items.length;
      this.__virtualizer.flush();
      this.setAttribute("aria-setsize", items.length);
      this.requestContentUpdate();
    }
  }
  __loadingChanged() {
    if (this.__virtualizer) {
      this.requestContentUpdate();
    }
  }
  __selectedItemChanged() {
    if (this.__virtualizer) {
      this.requestContentUpdate();
    }
  }
  __focusedIndexChanged(index, oldIndex) {
    if (!this.__virtualizer) {
      return;
    }
    if (index !== oldIndex) {
      this.requestContentUpdate();
    }
    if (index >= 0 && !this.loading) {
      this.scrollIntoView(index);
    }
  }
  __rendererChanged(renderer, oldRenderer) {
    if (renderer || oldRenderer) {
      this.requestContentUpdate();
    }
  }
  __createElements(count) {
    return [...Array(count)].map(() => {
      const item2 = document.createElement(`${this.__hostTagName}-item`);
      item2.addEventListener("click", this.__boundOnItemClick);
      item2.tabIndex = "-1";
      item2.style.width = "100%";
      return item2;
    });
  }
  __updateElement(el, index) {
    const item2 = this.items[index];
    const focusedIndex = this.focusedIndex;
    el.setProperties({
      item: item2,
      index,
      label: this.getItemLabel(item2),
      selected: this.__isItemSelected(item2, this.selectedItem, this.itemIdPath),
      renderer: this.renderer,
      focused: this.__isItemFocused(focusedIndex, index)
    });
    el.id = `${this.__hostTagName}-item-${index}`;
    el.setAttribute("role", this.__getAriaRole(index));
    el.setAttribute("aria-selected", this.__getAriaSelected(focusedIndex, index));
    el.setAttribute("aria-posinset", index + 1);
    if (this.theme) {
      el.setAttribute("theme", this.theme);
    } else {
      el.removeAttribute("theme");
    }
    if (item2 instanceof ComboBoxPlaceholder) {
      this.__requestItemByIndex(index);
    }
  }
  __onItemClick(e) {
    this.dispatchEvent(new CustomEvent("selection-changed", { detail: { item: e.currentTarget.item } }));
  }
  __patchWheelOverScrolling() {
    this.$.selector.addEventListener("wheel", (e) => {
      const scrolledToTop = this.scrollTop === 0;
      const scrolledToBottom = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;
      if (scrolledToTop && e.deltaY < 0) {
        e.preventDefault();
      } else if (scrolledToBottom && e.deltaY > 0) {
        e.preventDefault();
      }
    });
  }
  get _viewportTotalPaddingBottom() {
    if (this._cachedViewportTotalPaddingBottom === void 0) {
      const itemsStyle = window.getComputedStyle(this.$.selector);
      this._cachedViewportTotalPaddingBottom = [itemsStyle.paddingBottom, itemsStyle.borderBottomWidth].map((v) => {
        return parseInt(v, 10);
      }).reduce((sum, v) => {
        return sum + v;
      });
    }
    return this._cachedViewportTotalPaddingBottom;
  }
  __requestItemByIndex(index) {
    requestAnimationFrame(() => {
      this.dispatchEvent(
        new CustomEvent("index-requested", {
          detail: {
            index,
            currentScrollerPos: this._oldScrollerPosition
          }
        })
      );
    });
  }
  _visibleItemsCount() {
    this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex);
    const hasItems = this.__virtualizer.size > 0;
    return hasItems ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;
  }
};
customElements.define(ComboBoxScroller.is, ComboBoxScroller);

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js
function isValidValue(value) {
  return value !== void 0 && value !== null;
}
function findItemIndex(items, callback) {
  return items.findIndex((item2) => {
    if (item2 instanceof ComboBoxPlaceholder) {
      return false;
    }
    return callback(item2);
  });
}
var ComboBoxMixin = (subclass) => class VaadinComboBoxMixinElement extends ControllerMixin(KeyboardMixin(InputMixin(DisabledMixin(subclass)))) {
  static get properties() {
    return {
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true,
        observer: "_openedChanged"
      },
      autoOpenDisabled: {
        type: Boolean
      },
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      renderer: Function,
      items: {
        type: Array,
        observer: "_itemsChanged"
      },
      allowCustomValue: {
        type: Boolean,
        value: false
      },
      filteredItems: {
        type: Array,
        observer: "_filteredItemsChanged"
      },
      _lastCommittedValue: String,
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      _focusedIndex: {
        type: Number,
        observer: "_focusedIndexChanged",
        value: -1
      },
      filter: {
        type: String,
        value: "",
        notify: true
      },
      selectedItem: {
        type: Object,
        notify: true
      },
      itemLabelPath: {
        type: String,
        value: "label",
        observer: "_itemLabelPathChanged"
      },
      itemValuePath: {
        type: String,
        value: "value"
      },
      itemIdPath: String,
      _toggleElement: {
        type: Object,
        observer: "_toggleElementChanged"
      },
      _closeOnBlurIsPrevented: Boolean,
      _scroller: Object,
      _overlayOpened: {
        type: Boolean,
        observer: "_overlayOpenedChanged"
      }
    };
  }
  static get observers() {
    return [
      "_selectedItemChanged(selectedItem, itemValuePath, itemLabelPath)",
      "_openedOrItemsChanged(opened, filteredItems, loading)",
      "_updateScroller(_scroller, filteredItems, opened, loading, selectedItem, itemIdPath, _focusedIndex, renderer, theme)"
    ];
  }
  constructor() {
    super();
    this._boundOnFocusout = this._onFocusout.bind(this);
    this._boundOverlaySelectedItemChanged = this._overlaySelectedItemChanged.bind(this);
    this._boundOnClearButtonMouseDown = this.__onClearButtonMouseDown.bind(this);
    this._boundOnClick = this._onClick.bind(this);
    this._boundOnOverlayTouchAction = this._onOverlayTouchAction.bind(this);
    this._boundOnTouchend = this._onTouchend.bind(this);
  }
  get _tagNamePrefix() {
    return "vaadin-combo-box";
  }
  get _inputElementValue() {
    return this.inputElement ? this.inputElement[this._propertyForValue] : void 0;
  }
  set _inputElementValue(value) {
    if (this.inputElement) {
      this.inputElement[this._propertyForValue] = value;
    }
  }
  get _nativeInput() {
    return this.inputElement;
  }
  _inputElementChanged(inputElement) {
    super._inputElementChanged(inputElement);
    const input = this._nativeInput;
    if (input) {
      input.autocomplete = "off";
      input.autocapitalize = "off";
      input.setAttribute("role", "combobox");
      input.setAttribute("aria-autocomplete", "list");
      input.setAttribute("aria-expanded", !!this.opened);
      input.setAttribute("spellcheck", "false");
      input.setAttribute("autocorrect", "off");
      this._revertInputValueToValue();
      if (this.clearElement) {
        this.clearElement.addEventListener("mousedown", this._boundOnClearButtonMouseDown);
      }
    }
  }
  ready() {
    super.ready();
    this._initOverlay();
    this._initScroller();
    this.addEventListener("focusout", this._boundOnFocusout);
    this._lastCommittedValue = this.value;
    this.addEventListener("click", this._boundOnClick);
    this.addEventListener("touchend", this._boundOnTouchend);
    const bringToFrontListener = () => {
      requestAnimationFrame(() => {
        this.$.overlay.bringToFront();
      });
    };
    this.addEventListener("mousedown", bringToFrontListener);
    this.addEventListener("touchstart", bringToFrontListener);
    processTemplates(this);
    this.addController(new VirtualKeyboardController(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.close();
  }
  requestContentUpdate() {
    if (!this._scroller) {
      return;
    }
    this._scroller.requestContentUpdate();
    this._getItemElements().forEach((item2) => {
      item2.requestContentUpdate();
    });
  }
  open() {
    if (!this.disabled && !this.readonly) {
      this.opened = true;
    }
  }
  close() {
    this.opened = false;
  }
  _propertiesChanged(currentProps, changedProps, oldProps) {
    super._propertiesChanged(currentProps, changedProps, oldProps);
    if (changedProps.filter !== void 0) {
      this._filterChanged(changedProps.filter);
    }
  }
  _initOverlay() {
    const overlay2 = this.$.overlay;
    overlay2._comboBox = this;
    overlay2.addEventListener("touchend", this._boundOnOverlayTouchAction);
    overlay2.addEventListener("touchmove", this._boundOnOverlayTouchAction);
    overlay2.addEventListener("mousedown", (e) => e.preventDefault());
    overlay2.addEventListener("opened-changed", (e) => {
      this._overlayOpened = e.detail.value;
    });
  }
  _initScroller(host) {
    const scrollerTag = `${this._tagNamePrefix}-scroller`;
    const overlay2 = this.$.overlay;
    overlay2.renderer = (root) => {
      if (!root.firstChild) {
        root.appendChild(document.createElement(scrollerTag));
      }
    };
    overlay2.requestContentUpdate();
    const scroller = overlay2.querySelector(scrollerTag);
    scroller.comboBox = host || this;
    scroller.getItemLabel = this._getItemLabel.bind(this);
    scroller.addEventListener("selection-changed", this._boundOverlaySelectedItemChanged);
    this._scroller = scroller;
  }
  _updateScroller(scroller, items, opened, loading, selectedItem, itemIdPath, focusedIndex, renderer, theme) {
    if (scroller) {
      if (opened) {
        scroller.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this._tagNamePrefix}-overlay-max-height`) || "65vh";
      }
      scroller.setProperties({
        items: opened ? items : [],
        opened,
        loading,
        selectedItem,
        itemIdPath,
        focusedIndex,
        renderer,
        theme
      });
    }
  }
  _openedOrItemsChanged(opened, items, loading) {
    this._overlayOpened = !!(opened && (loading || items && items.length));
  }
  _overlayOpenedChanged(opened, wasOpened) {
    if (opened) {
      this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-opened", { bubbles: true, composed: true }));
      this._onOpened();
    } else if (wasOpened && this.filteredItems && this.filteredItems.length) {
      this.close();
      this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-closed", { bubbles: true, composed: true }));
    }
  }
  _focusedIndexChanged(index, oldIndex) {
    if (oldIndex === void 0) {
      return;
    }
    this._updateActiveDescendant(index);
  }
  _isInputFocused() {
    return this.inputElement && isElementFocused(this.inputElement);
  }
  _updateActiveDescendant(index) {
    const input = this._nativeInput;
    if (!input) {
      return;
    }
    const item2 = this._getItemElements().find((el) => el.index === index);
    if (item2) {
      input.setAttribute("aria-activedescendant", item2.id);
    } else {
      input.removeAttribute("aria-activedescendant");
    }
  }
  _openedChanged(opened, wasOpened) {
    if (wasOpened === void 0) {
      return;
    }
    if (opened) {
      this._openedWithFocusRing = this.hasAttribute("focus-ring");
      if (!this._isInputFocused() && !isTouch) {
        this.focus();
      }
      this.$.overlay.restoreFocusOnClose = true;
    } else {
      this._onClosed();
      if (this._openedWithFocusRing && this._isInputFocused()) {
        this.setAttribute("focus-ring", "");
      }
    }
    const input = this._nativeInput;
    if (input) {
      input.setAttribute("aria-expanded", !!opened);
      if (opened) {
        input.setAttribute("aria-controls", this._scroller.id);
      } else {
        input.removeAttribute("aria-controls");
      }
    }
  }
  _onOverlayTouchAction() {
    this._closeOnBlurIsPrevented = true;
    this.inputElement.blur();
    this._closeOnBlurIsPrevented = false;
  }
  _isClearButton(event) {
    return event.composedPath()[0] === this.clearElement;
  }
  _handleClearButtonClick(event) {
    event.preventDefault();
    this._clear();
    if (this.opened) {
      this.requestContentUpdate();
    }
  }
  _onToggleButtonClick(event) {
    event.preventDefault();
    if (this.opened) {
      this.close();
    } else {
      this.open();
    }
  }
  _onHostClick(event) {
    if (!this.autoOpenDisabled) {
      event.preventDefault();
      this.open();
    }
  }
  _onClick(e) {
    const path = e.composedPath();
    if (this._isClearButton(e)) {
      this._handleClearButtonClick(e);
    } else if (path.indexOf(this._toggleElement) > -1) {
      this._onToggleButtonClick(e);
    } else {
      this._onHostClick(e);
    }
  }
  _onKeyDown(e) {
    super._onKeyDown(e);
    if (e.key === "Tab") {
      this.$.overlay.restoreFocusOnClose = false;
    } else if (e.key === "ArrowDown") {
      this._onArrowDown();
      e.preventDefault();
    } else if (e.key === "ArrowUp") {
      this._onArrowUp();
      e.preventDefault();
    }
  }
  _getItemLabel(item2) {
    let label = item2 && this.itemLabelPath ? this.get(this.itemLabelPath, item2) : void 0;
    if (label === void 0 || label === null) {
      label = item2 ? item2.toString() : "";
    }
    return label;
  }
  _getItemValue(item2) {
    let value = item2 && this.itemValuePath ? this.get(this.itemValuePath, item2) : void 0;
    if (value === void 0) {
      value = item2 ? item2.toString() : "";
    }
    return value;
  }
  _onArrowDown() {
    if (this.opened) {
      const items = this.filteredItems;
      if (items) {
        this._focusedIndex = Math.min(items.length - 1, this._focusedIndex + 1);
        this._prefillFocusedItemLabel();
      }
    } else {
      this.open();
    }
  }
  _onArrowUp() {
    if (this.opened) {
      if (this._focusedIndex > -1) {
        this._focusedIndex = Math.max(0, this._focusedIndex - 1);
      } else {
        const items = this.filteredItems;
        if (items) {
          this._focusedIndex = items.length - 1;
        }
      }
      this._prefillFocusedItemLabel();
    } else {
      this.open();
    }
  }
  _prefillFocusedItemLabel() {
    if (this._focusedIndex > -1) {
      const focusedItem = this.filteredItems[this._focusedIndex];
      this._inputElementValue = this._getItemLabel(focusedItem);
      this._markAllSelectionRange();
    }
  }
  _setSelectionRange(start, end) {
    if (this._isInputFocused() && this.inputElement.setSelectionRange) {
      this.inputElement.setSelectionRange(start, end);
    }
  }
  _markAllSelectionRange() {
    if (this._inputElementValue !== void 0) {
      this._setSelectionRange(0, this._inputElementValue.length);
    }
  }
  _clearSelectionRange() {
    if (this._inputElementValue !== void 0) {
      const pos = this._inputElementValue ? this._inputElementValue.length : 0;
      this._setSelectionRange(pos, pos);
    }
  }
  _closeOrCommit() {
    if (!this.opened && !this.loading) {
      this._commitValue();
    } else {
      this.close();
    }
  }
  _onEnter(e) {
    if (!this.allowCustomValue && this._inputElementValue !== "" && this._focusedIndex < 0) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    if (this.opened) {
      e.preventDefault();
      e.stopPropagation();
    }
    this._closeOrCommit();
  }
  _onEscape(e) {
    if (this.autoOpenDisabled) {
      if (this.opened || this.value !== this._inputElementValue && this._inputElementValue.length > 0) {
        e.stopPropagation();
        this._focusedIndex = -1;
        this.cancel();
      } else if (this.clearButtonVisible && !this.opened && !!this.value) {
        e.stopPropagation();
        this._clear();
      }
    } else if (this.opened) {
      e.stopPropagation();
      if (this._focusedIndex > -1) {
        this._focusedIndex = -1;
        this._revertInputValue();
      } else {
        this.cancel();
      }
    } else if (this.clearButtonVisible && !!this.value) {
      e.stopPropagation();
      this._clear();
    }
  }
  _toggleElementChanged(toggleElement) {
    if (toggleElement) {
      toggleElement.addEventListener("mousedown", (e) => e.preventDefault());
      toggleElement.addEventListener("click", () => {
        if (isTouch && !this._isInputFocused()) {
          document.activeElement.blur();
        }
      });
    }
  }
  _clear() {
    this.selectedItem = null;
    if (this.allowCustomValue) {
      this.value = "";
    }
    this._detectAndDispatchChange();
  }
  cancel() {
    this._revertInputValueToValue();
    this._lastCommittedValue = this.value;
    this._closeOrCommit();
  }
  _onOpened() {
    requestAnimationFrame(() => {
      this._scrollIntoView(this._focusedIndex);
      this._updateActiveDescendant(this._focusedIndex);
    });
    this._lastCommittedValue = this.value;
  }
  _onClosed() {
    if (!this.loading || this.allowCustomValue) {
      this._commitValue();
    }
  }
  _commitValue() {
    if (this._focusedIndex > -1) {
      const focusedItem = this.filteredItems[this._focusedIndex];
      if (this.selectedItem !== focusedItem) {
        this.selectedItem = focusedItem;
      }
      this._inputElementValue = this._getItemLabel(this.selectedItem);
    } else if (this._inputElementValue === "" || this._inputElementValue === void 0) {
      this.selectedItem = null;
      if (this.allowCustomValue) {
        this.value = "";
      }
    } else {
      const items = [...this.filteredItems || [], this.selectedItem];
      const itemMatchingInputValue = items[this.__getItemIndexByLabel(items, this._inputElementValue)];
      if (this.allowCustomValue && !itemMatchingInputValue) {
        const customValue = this._inputElementValue;
        this._lastCustomValue = customValue;
        const e = new CustomEvent("custom-value-set", {
          detail: customValue,
          composed: true,
          cancelable: true,
          bubbles: true
        });
        this.dispatchEvent(e);
        if (!e.defaultPrevented) {
          this.value = customValue;
        }
      } else if (!this.allowCustomValue && !this.opened && itemMatchingInputValue) {
        this.value = this._getItemValue(itemMatchingInputValue);
      } else {
        this._inputElementValue = this.selectedItem ? this._getItemLabel(this.selectedItem) : this.value || "";
      }
    }
    this._detectAndDispatchChange();
    this._clearSelectionRange();
    this.filter = "";
  }
  get _propertyForValue() {
    return "value";
  }
  _onInput(event) {
    const filter = this._inputElementValue;
    const props = {};
    if (this.filter === filter) {
      this._filterChanged(this.filter);
    } else {
      props.filter = filter;
    }
    if (!this.opened && !this._isClearButton(event) && !this.autoOpenDisabled) {
      props.opened = true;
    }
    this.setProperties(props);
  }
  _onChange(event) {
    event.stopPropagation();
  }
  _itemLabelPathChanged(itemLabelPath) {
    if (typeof itemLabelPath !== "string") {
      console.error("You should set itemLabelPath to a valid string");
    }
  }
  _filterChanged(filter) {
    this._scrollIntoView(0);
    this._focusedIndex = -1;
    if (this.items) {
      this.filteredItems = this._filterItems(this.items, filter);
    } else {
      this._filteredItemsChanged(this.filteredItems);
    }
  }
  _revertInputValue() {
    if (this.filter !== "") {
      this._inputElementValue = this.filter;
    } else {
      this._revertInputValueToValue();
    }
    this._clearSelectionRange();
  }
  _revertInputValueToValue() {
    if (this.allowCustomValue && !this.selectedItem) {
      this._inputElementValue = this.value;
    } else {
      this._inputElementValue = this._getItemLabel(this.selectedItem);
    }
  }
  _selectedItemChanged(selectedItem) {
    if (selectedItem === null || selectedItem === void 0) {
      if (this.filteredItems) {
        if (!this.allowCustomValue) {
          this.value = "";
        }
        this._toggleHasValue(this._hasValue);
        this._inputElementValue = this.value;
      }
    } else {
      const value = this._getItemValue(selectedItem);
      if (this.value !== value) {
        this.value = value;
        if (this.value !== value) {
          return;
        }
      }
      this._toggleHasValue(true);
      this._inputElementValue = this._getItemLabel(selectedItem);
    }
    if (this.filteredItems) {
      this._focusedIndex = this.filteredItems.indexOf(selectedItem);
    }
  }
  _valueChanged(value, oldVal) {
    if (value === "" && oldVal === void 0) {
      return;
    }
    if (isValidValue(value)) {
      if (this._getItemValue(this.selectedItem) !== value) {
        this._selectItemForValue(value);
      }
      if (!this.selectedItem && this.allowCustomValue) {
        this._inputElementValue = value;
      }
      this._toggleHasValue(this._hasValue);
    } else {
      this.selectedItem = null;
    }
    this.filter = "";
    this._lastCommittedValue = void 0;
  }
  _detectAndDispatchChange() {
    if (this.value !== this._lastCommittedValue) {
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      this._lastCommittedValue = this.value;
    }
  }
  _itemsChanged(items, oldItems) {
    this._ensureItemsOrDataProvider(() => {
      this.items = oldItems;
    });
    if (items) {
      this.filteredItems = items.slice(0);
    } else if (oldItems) {
      this.filteredItems = null;
    }
  }
  _filteredItemsChanged(filteredItems, oldFilteredItems) {
    const focusedItem = oldFilteredItems ? oldFilteredItems[this._focusedIndex] : null;
    const valueIndex = this.__getItemIndexByValue(filteredItems, this.value);
    if ((this.selectedItem === null || this.selectedItem === void 0) && valueIndex >= 0) {
      this.selectedItem = filteredItems[valueIndex];
    }
    const focusedItemIndex = this.__getItemIndexByValue(filteredItems, this._getItemValue(focusedItem));
    if (focusedItemIndex > -1) {
      this._focusedIndex = focusedItemIndex;
    } else {
      this.__setInitialFocusedIndex();
    }
  }
  __setInitialFocusedIndex() {
    const inputValue = this._inputElementValue;
    if (inputValue === void 0 || inputValue === this._getItemLabel(this.selectedItem)) {
      this._focusedIndex = this.__getItemIndexByLabel(this.filteredItems, this._getItemLabel(this.selectedItem));
    } else {
      this._focusedIndex = this.__getItemIndexByLabel(this.filteredItems, this.filter);
    }
  }
  _filterItems(arr, filter) {
    if (!arr) {
      return arr;
    }
    const filteredItems = arr.filter((item2) => {
      filter = filter ? filter.toString().toLowerCase() : "";
      return this._getItemLabel(item2).toString().toLowerCase().indexOf(filter) > -1;
    });
    return filteredItems;
  }
  _selectItemForValue(value) {
    const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);
    const previouslySelectedItem = this.selectedItem;
    if (valueIndex >= 0) {
      this.selectedItem = this.filteredItems[valueIndex];
    } else if (this.dataProvider && this.selectedItem === void 0) {
      this.selectedItem = void 0;
    } else {
      this.selectedItem = null;
    }
    if (this.selectedItem === null && previouslySelectedItem === null) {
      this._selectedItemChanged(this.selectedItem);
    }
  }
  _getItemElements() {
    return Array.from(this._scroller.querySelectorAll(`${this._tagNamePrefix}-item`));
  }
  _scrollIntoView(index) {
    if (!this._scroller) {
      return;
    }
    this._scroller.scrollIntoView(index);
  }
  __getItemIndexByValue(items, value) {
    if (!items || !isValidValue(value)) {
      return -1;
    }
    return findItemIndex(items, (item2) => {
      return this._getItemValue(item2) === value;
    });
  }
  __getItemIndexByLabel(items, label) {
    if (!items || !label) {
      return -1;
    }
    return findItemIndex(items, (item2) => {
      return this._getItemLabel(item2).toString().toLowerCase() === label.toString().toLowerCase();
    });
  }
  _overlaySelectedItemChanged(e) {
    e.stopPropagation();
    if (e.detail.item instanceof ComboBoxPlaceholder) {
      return;
    }
    if (this.opened) {
      this._focusedIndex = this.filteredItems.indexOf(e.detail.item);
      this.close();
    }
  }
  __onClearButtonMouseDown(event) {
    event.preventDefault();
    this.inputElement.focus();
  }
  _onFocusout(event) {
    if (event.relatedTarget && event.relatedTarget.localName === `${this._tagNamePrefix}-item`) {
      return;
    }
    if (event.relatedTarget === this.$.overlay) {
      event.composedPath()[0].focus();
      return;
    }
    if (!this.readonly && !this._closeOnBlurIsPrevented) {
      if (!this.opened && this.allowCustomValue && this._inputElementValue === this._lastCustomValue) {
        delete this._lastCustomValue;
        return;
      }
      this._closeOrCommit();
    }
  }
  _onTouchend(event) {
    if (!this.clearElement || event.composedPath()[0] !== this.clearElement) {
      return;
    }
    event.preventDefault();
    this._clear();
  }
};

export {
  ComboBoxItem,
  ComboBoxOverlay,
  ComboBoxScroller,
  ComboBoxMixin
};
/**
 * @license
 * Copyright (c) 2015 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
/**
 * @license
 * Copyright (c) 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-RTLPYO4G.js.map
