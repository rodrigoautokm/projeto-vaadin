import {
  generateUniqueId
} from "./chunk-26L5GZ27.js";
import {
  ControllerMixin
} from "./chunk-SG4ORNH2.js";
import {
  FlattenedNodesObserver
} from "./chunk-4V7CPLV2.js";
import {
  dedupingMixin
} from "./chunk-NCN7ELFS.js";

// node_modules/@vaadin/component-base/src/slot-controller.js
var SlotController = class extends EventTarget {
  static generateId(slotName, host) {
    const prefix = slotName || "default";
    return `${prefix}-${host.localName}-${generateUniqueId()}`;
  }
  constructor(host, slotName, slotFactory, slotInitializer, useUniqueId) {
    super();
    this.host = host;
    this.slotName = slotName;
    this.slotFactory = slotFactory;
    this.slotInitializer = slotInitializer;
    if (useUniqueId) {
      this.defaultId = SlotController.generateId(slotName, host);
    }
  }
  hostConnected() {
    if (!this.initialized) {
      let node = this.getSlotChild();
      if (!node) {
        node = this.attachDefaultNode();
      } else {
        this.node = node;
        this.initCustomNode(node);
      }
      this.initNode(node);
      this.observe();
      this.initialized = true;
    }
  }
  attachDefaultNode() {
    const { host, slotName, slotFactory } = this;
    let node = this.defaultNode;
    if (!node && slotFactory) {
      node = slotFactory(host);
      if (node instanceof Element) {
        if (slotName !== "") {
          node.setAttribute("slot", slotName);
        }
        this.node = node;
        this.defaultNode = node;
      }
    }
    if (node) {
      host.appendChild(node);
    }
    return node;
  }
  getSlotChild() {
    const { slotName } = this;
    return Array.from(this.host.childNodes).find((node) => {
      return node.nodeType === Node.ELEMENT_NODE && node.slot === slotName || node.nodeType === Node.TEXT_NODE && node.textContent.trim() && slotName === "";
    });
  }
  initNode(node) {
    const { slotInitializer } = this;
    if (slotInitializer) {
      slotInitializer(this.host, node);
    }
  }
  initCustomNode(_node) {
  }
  teardownNode(_node) {
  }
  observe() {
    const { slotName } = this;
    const selector = slotName === "" ? "slot:not([name])" : `slot[name=${slotName}]`;
    const slot = this.host.shadowRoot.querySelector(selector);
    this.__slotObserver = new FlattenedNodesObserver(slot, (info) => {
      const current = this.node;
      const newNode = info.addedNodes.find((node) => node !== current);
      if (info.removedNodes.length) {
        info.removedNodes.forEach((node) => {
          this.teardownNode(node);
        });
      }
      if (newNode) {
        if (current && current.isConnected) {
          this.host.removeChild(current);
        }
        this.node = newNode;
        if (newNode !== this.defaultNode) {
          this.initCustomNode(newNode);
          this.initNode(newNode);
        }
      }
    });
  }
};

// node_modules/@vaadin/field-base/src/label-controller.js
var LabelController = class extends SlotController {
  constructor(host) {
    super(
      host,
      "label",
      () => document.createElement("label"),
      (_host, node) => {
        this.__updateLabelId(node);
        this.__updateDefaultLabel(this.label);
        this.__observeLabel(node);
      },
      true
    );
  }
  get labelId() {
    return this.node.id;
  }
  initCustomNode(labelNode) {
    this.__updateLabelId(labelNode);
    const hasLabel = this.__hasLabel(labelNode);
    this.__toggleHasLabel(hasLabel);
  }
  teardownNode(node) {
    if (this.__labelObserver) {
      this.__labelObserver.disconnect();
    }
    let labelNode = this.getSlotChild();
    if (!labelNode && node !== this.defaultNode) {
      labelNode = this.attachDefaultNode();
      this.initNode(labelNode);
    }
    const hasLabel = this.__hasLabel(labelNode);
    this.__toggleHasLabel(hasLabel);
  }
  setLabel(label) {
    this.label = label;
    this.__updateDefaultLabel(label);
  }
  __hasLabel(labelNode) {
    if (!labelNode) {
      return false;
    }
    return labelNode.children.length > 0 || this.__isNotEmpty(labelNode.textContent);
  }
  __isNotEmpty(label) {
    return Boolean(label && label.trim() !== "");
  }
  __observeLabel(labelNode) {
    this.__labelObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        const target = mutation.target;
        const isLabelMutation = target === this.node;
        if (mutation.type === "attributes") {
          if (isLabelMutation && target.id !== this.defaultId) {
            this.__updateLabelId(target);
          }
        } else if (isLabelMutation || target.parentElement === this.node) {
          const hasLabel = this.__hasLabel(this.node);
          this.__toggleHasLabel(hasLabel);
        }
      });
    });
    this.__labelObserver.observe(labelNode, {
      attributes: true,
      attributeFilter: ["id"],
      childList: true,
      subtree: true,
      characterData: true
    });
  }
  __toggleHasLabel(hasLabel) {
    this.host.toggleAttribute("has-label", hasLabel);
    this.dispatchEvent(
      new CustomEvent("label-changed", {
        detail: {
          hasLabel,
          node: this.node
        }
      })
    );
  }
  __updateDefaultLabel(label) {
    if (this.defaultNode) {
      this.defaultNode.textContent = label;
      if (this.defaultNode === this.node) {
        const hasLabel = this.__isNotEmpty(label);
        this.__toggleHasLabel(hasLabel);
      }
    }
  }
  __updateLabelId(labelNode) {
    if (!labelNode.id) {
      labelNode.id = this.defaultId;
    }
  }
};

// node_modules/@vaadin/field-base/src/label-mixin.js
var LabelMixin = dedupingMixin(
  (superclass) => class LabelMixinClass extends ControllerMixin(superclass) {
    static get properties() {
      return {
        label: {
          type: String,
          observer: "_labelChanged"
        }
      };
    }
    get _labelId() {
      return this._labelController.labelId;
    }
    get _labelNode() {
      return this._labelController.node;
    }
    constructor() {
      super();
      this._labelController = new LabelController(this);
    }
    ready() {
      super.ready();
      this.addController(this._labelController);
    }
    _labelChanged(label) {
      this._labelController.setLabel(label);
    }
  }
);

export {
  SlotController,
  LabelMixin
};
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-5765XJOL.js.map
