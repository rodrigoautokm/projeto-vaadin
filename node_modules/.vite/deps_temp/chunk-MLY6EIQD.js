import {
  processTemplates
} from "./chunk-CE2HX6X3.js";
import {
  OverlayElement,
  overlay
} from "./chunk-LH2VMHWZ.js";
import {
  isTouch
} from "./chunk-XAUSENF3.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import {
  ThemePropertyMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";

// node_modules/@vaadin/dialog/theme/lumo/vaadin-dialog-styles.js
var dialogOverlay = css`
  /* Optical centering */
  :host::before,
  :host::after {
    content: '';
    flex-basis: 0;
    flex-grow: 1;
  }

  :host::after {
    flex-grow: 1.1;
  }

  [part='overlay'] {
    border-radius: var(--lumo-border-radius-l);
    box-shadow: 0 0 0 1px var(--lumo-shade-5pct), var(--lumo-box-shadow-xl);
    background-image: none;
    outline: none;
    -webkit-tap-highlight-color: transparent;
  }

  [part='content'] {
    padding: var(--lumo-space-l);
  }

  :host(:is([has-header], [has-title])) [part='header'] + [part='content'] {
    padding-top: 0;
  }

  [part='header'],
  [part='header-content'],
  [part='footer'] {
    gap: var(--lumo-space-xs) var(--lumo-space-s);
    line-height: var(--lumo-line-height-s);
  }

  [part='header'] {
    padding: var(--lumo-space-m);
    background-color: var(--lumo-base-color);
    border-radius: var(--lumo-border-radius-l) var(--lumo-border-radius-l) 0 0; /* Needed for Safari */
  }

  [part='footer'] {
    padding: var(--lumo-space-s) var(--lumo-space-m);
    background-color: var(--lumo-contrast-5pct);
    border-radius: 0 0 var(--lumo-border-radius-l) var(--lumo-border-radius-l); /* Needed for Safari */
  }

  [part='title'] {
    font-size: var(--lumo-font-size-xl);
    font-weight: 600;
    color: var(--lumo-header-text-color);
    margin-inline-start: calc(var(--lumo-space-l) - var(--lumo-space-m));
  }

  /* No padding */
  :host([theme~='no-padding']) [part='content'] {
    padding: 0;
  }

  @media (min-height: 320px) {
    :host([overflow~='top']) [part='header'] {
      box-shadow: 0 1px 0 0 var(--lumo-contrast-10pct);
    }
  }

  /* Animations */

  :host([opening]),
  :host([closing]) {
    animation: 0.25s lumo-overlay-dummy-animation;
  }

  :host([opening]) [part='overlay'] {
    animation: 0.12s 0.05s vaadin-dialog-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;
  }

  @keyframes vaadin-dialog-enter {
    0% {
      opacity: 0;
      transform: scale(0.95);
    }
  }

  :host([closing]) [part='overlay'] {
    animation: 0.1s 0.03s vaadin-dialog-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;
  }

  :host([closing]) [part='backdrop'] {
    animation-delay: 0.05s;
  }

  @keyframes vaadin-dialog-exit {
    100% {
      opacity: 0;
      transform: scale(1.02);
    }
  }
`;
registerStyles("vaadin-dialog-overlay", [overlay, dialogOverlay], { moduleId: "lumo-dialog" });

// node_modules/@vaadin/dialog/src/vaadin-dialog-utils.js
function getMouseOrFirstTouchEvent(e) {
  return e.touches ? e.touches[0] : e;
}
function eventInWindow(e) {
  return e.clientX >= 0 && e.clientX <= window.innerWidth && e.clientY >= 0 && e.clientY <= window.innerHeight;
}

// node_modules/@vaadin/dialog/src/vaadin-dialog-draggable-mixin.js
var DialogDraggableMixin = (superClass) => class VaadinDialogDraggableMixin extends superClass {
  static get properties() {
    return {
      draggable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      _touchDevice: {
        type: Boolean,
        value: isTouch
      },
      __dragHandleClassName: {
        type: String
      }
    };
  }
  ready() {
    super.ready();
    this._originalBounds = {};
    this._originalMouseCoords = {};
    this._startDrag = this._startDrag.bind(this);
    this._drag = this._drag.bind(this);
    this._stopDrag = this._stopDrag.bind(this);
    this.$.overlay.$.overlay.addEventListener("mousedown", this._startDrag);
    this.$.overlay.$.overlay.addEventListener("touchstart", this._startDrag);
  }
  _startDrag(e) {
    if (e.type === "touchstart" && e.touches.length > 1) {
      return;
    }
    if (this.draggable && (e.button === 0 || e.touches)) {
      const resizerContainer = this.$.overlay.$.resizerContainer;
      const isResizerContainer = e.target === resizerContainer;
      const isResizerContainerScrollbar = e.offsetX > resizerContainer.clientWidth || e.offsetY > resizerContainer.clientHeight;
      const isContentPart = e.target === this.$.overlay.$.content;
      const isDraggable = e.composedPath().some((node, index) => {
        if (!node.classList) {
          return false;
        }
        const isDraggableNode = node.classList.contains(this.__dragHandleClassName || "draggable");
        const isDraggableLeafOnly = node.classList.contains("draggable-leaf-only");
        const isLeafNode = index === 0;
        return isDraggableLeafOnly && isLeafNode || isDraggableNode && (!isDraggableLeafOnly || isLeafNode);
      });
      if (isResizerContainer && !isResizerContainerScrollbar || isContentPart || isDraggable) {
        if (!isDraggable) {
          e.preventDefault();
        }
        this._originalBounds = this.$.overlay.getBounds();
        const event = getMouseOrFirstTouchEvent(e);
        this._originalMouseCoords = { top: event.pageY, left: event.pageX };
        window.addEventListener("mouseup", this._stopDrag);
        window.addEventListener("touchend", this._stopDrag);
        window.addEventListener("mousemove", this._drag);
        window.addEventListener("touchmove", this._drag);
        if (this.$.overlay.$.overlay.style.position !== "absolute") {
          this.$.overlay.setBounds(this._originalBounds);
        }
      }
    }
  }
  _drag(e) {
    const event = getMouseOrFirstTouchEvent(e);
    if (eventInWindow(event)) {
      const top = this._originalBounds.top + (event.pageY - this._originalMouseCoords.top);
      const left = this._originalBounds.left + (event.pageX - this._originalMouseCoords.left);
      this.$.overlay.setBounds({ top, left });
    }
  }
  _stopDrag() {
    window.removeEventListener("mouseup", this._stopDrag);
    window.removeEventListener("touchend", this._stopDrag);
    window.removeEventListener("mousemove", this._drag);
    window.removeEventListener("touchmove", this._drag);
  }
};

// node_modules/@vaadin/dialog/src/vaadin-dialog-resizable-mixin.js
registerStyles(
  "vaadin-dialog-overlay",
  css`
    [part='overlay'] {
      position: relative;
      overflow: visible;
      max-height: 100%;
      display: flex;
    }

    [part='content'] {
      box-sizing: border-box;
      height: 100%;
    }

    .resizer-container {
      overflow: auto;
      flex-grow: 1;
      border-radius: inherit; /* prevent child elements being drawn outside part=overlay */
    }

    [part='overlay'][style] .resizer-container {
      min-height: 100%;
      width: 100%;
    }

    :host(:not([resizable])) .resizer {
      display: none;
    }

    :host([resizable]) [part='title'] {
      cursor: move;
      -webkit-user-select: none;
      user-select: none;
    }

    .resizer {
      position: absolute;
      height: 16px;
      width: 16px;
    }

    .resizer.edge {
      height: 8px;
      width: 8px;
      top: -4px;
      right: -4px;
      bottom: -4px;
      left: -4px;
    }

    .resizer.edge.n {
      width: auto;
      bottom: auto;
      cursor: ns-resize;
    }

    .resizer.ne {
      top: -4px;
      right: -4px;
      cursor: nesw-resize;
    }

    .resizer.edge.e {
      height: auto;
      left: auto;
      cursor: ew-resize;
    }

    .resizer.se {
      bottom: -4px;
      right: -4px;
      cursor: nwse-resize;
    }

    .resizer.edge.s {
      width: auto;
      top: auto;
      cursor: ns-resize;
    }

    .resizer.sw {
      bottom: -4px;
      left: -4px;
      cursor: nesw-resize;
    }

    .resizer.edge.w {
      height: auto;
      right: auto;
      cursor: ew-resize;
    }

    .resizer.nw {
      top: -4px;
      left: -4px;
      cursor: nwse-resize;
    }
  `,
  { moduleId: "vaadin-dialog-resizable-overlay-styles" }
);
var DialogResizableMixin = (superClass) => class VaadinDialogResizableMixin extends superClass {
  static get properties() {
    return {
      resizable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  ready() {
    super.ready();
    this._originalBounds = {};
    this._originalMouseCoords = {};
    this._resizeListeners = { start: {}, resize: {}, stop: {} };
    this._addResizeListeners();
  }
  _addResizeListeners() {
    ["n", "e", "s", "w", "nw", "ne", "se", "sw"].forEach((direction) => {
      const resizer = document.createElement("div");
      this._resizeListeners.start[direction] = (e) => this._startResize(e, direction);
      this._resizeListeners.resize[direction] = (e) => this._resize(e, direction);
      this._resizeListeners.stop[direction] = () => this._stopResize(direction);
      if (direction.length === 1) {
        resizer.classList.add("edge");
      }
      resizer.classList.add("resizer");
      resizer.classList.add(direction);
      resizer.addEventListener("mousedown", this._resizeListeners.start[direction]);
      resizer.addEventListener("touchstart", this._resizeListeners.start[direction]);
      this.$.overlay.$.resizerContainer.appendChild(resizer);
    });
  }
  _startResize(e, direction) {
    if (e.type === "touchstart" && e.touches.length > 1) {
      return;
    }
    if (e.button === 0 || e.touches) {
      e.preventDefault();
      this._originalBounds = this.$.overlay.getBounds();
      const event = getMouseOrFirstTouchEvent(e);
      this._originalMouseCoords = { top: event.pageY, left: event.pageX };
      window.addEventListener("mousemove", this._resizeListeners.resize[direction]);
      window.addEventListener("touchmove", this._resizeListeners.resize[direction]);
      window.addEventListener("mouseup", this._resizeListeners.stop[direction]);
      window.addEventListener("touchend", this._resizeListeners.stop[direction]);
      if (this.$.overlay.$.overlay.style.position !== "absolute") {
        this.$.overlay.setBounds(this._originalBounds);
      }
    }
  }
  _resize(e, resizer) {
    const event = getMouseOrFirstTouchEvent(e);
    if (eventInWindow(event)) {
      const minimumSize = 40;
      resizer.split("").forEach((direction) => {
        switch (direction) {
          case "n": {
            const height = this._originalBounds.height - (event.pageY - this._originalMouseCoords.top);
            const top = this._originalBounds.top + (event.pageY - this._originalMouseCoords.top);
            if (height > minimumSize) {
              this.$.overlay.setBounds({ top, height });
            }
            break;
          }
          case "e": {
            const width = this._originalBounds.width + (event.pageX - this._originalMouseCoords.left);
            if (width > minimumSize) {
              this.$.overlay.setBounds({ width });
            }
            break;
          }
          case "s": {
            const height = this._originalBounds.height + (event.pageY - this._originalMouseCoords.top);
            if (height > minimumSize) {
              this.$.overlay.setBounds({ height });
            }
            break;
          }
          case "w": {
            const width = this._originalBounds.width - (event.pageX - this._originalMouseCoords.left);
            const left = this._originalBounds.left + (event.pageX - this._originalMouseCoords.left);
            if (width > minimumSize) {
              this.$.overlay.setBounds({ left, width });
            }
            break;
          }
          default:
            break;
        }
      });
    }
  }
  _stopResize(direction) {
    window.removeEventListener("mousemove", this._resizeListeners.resize[direction]);
    window.removeEventListener("touchmove", this._resizeListeners.resize[direction]);
    window.removeEventListener("mouseup", this._resizeListeners.stop[direction]);
    window.removeEventListener("touchend", this._resizeListeners.stop[direction]);
    this.dispatchEvent(new CustomEvent("resize", { detail: this._getResizeDimensions() }));
  }
  _getResizeDimensions() {
    const scrollPosition = this.$.overlay.$.resizerContainer.scrollTop;
    const { width, height } = getComputedStyle(this.$.overlay.$.overlay);
    const content = this.$.overlay.$.content;
    content.setAttribute(
      "style",
      "position: absolute; top: 0; right: 0; bottom: 0; left: 0; box-sizing: content-box; height: auto;"
    );
    const { width: contentWidth, height: contentHeight } = getComputedStyle(content);
    content.removeAttribute("style");
    this.$.overlay.$.resizerContainer.scrollTop = scrollPosition;
    return { width, height, contentWidth, contentHeight };
  }
};

// node_modules/@vaadin/dialog/src/vaadin-dialog.js
registerStyles(
  "vaadin-dialog-overlay",
  css`
    [part='header'],
    [part='header-content'],
    [part='footer'] {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      flex: none;
      pointer-events: none;
      z-index: 1;
    }

    [part='header'] {
      flex-wrap: nowrap;
    }

    ::slotted([slot='header-content']),
    ::slotted([slot='title']),
    ::slotted([slot='footer']) {
      display: contents;
      pointer-events: auto;
    }

    ::slotted([slot='title']) {
      font: inherit !important;
      overflow-wrap: anywhere;
    }

    [part='header-content'] {
      flex: 1;
    }

    :host([has-title]) [part='header-content'],
    [part='footer'] {
      justify-content: flex-end;
    }

    :host(:not([has-title]):not([has-header])) [part='header'],
    :host(:not([has-header])) [part='header-content'],
    :host(:not([has-title])) [part='title'],
    :host(:not([has-footer])) [part='footer'] {
      display: none !important;
    }

    :host(:is([has-title], [has-header], [has-footer])) [part='content'] {
      height: auto;
    }

    @media (min-height: 320px) {
      :host(:is([has-title], [has-header], [has-footer])) .resizer-container {
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      :host(:is([has-title], [has-header], [has-footer])) [part='content'] {
        flex: 1;
        overflow: auto;
      }
    }

    /*
      NOTE(platosha): Make some min-width to prevent collapsing of the content
      taking the parent width, e. g., <vaadin-grid> and such.
    */
    [part='content'] {
      min-width: 12em; /* matches the default <vaadin-text-field> width */
    }

    :host([has-bounds-set]) [part='overlay'] {
      max-width: none;
    }
  `,
  { moduleId: "vaadin-dialog-overlay-styles" }
);
var memoizedTemplate;
var DialogOverlay = class extends OverlayElement {
  static get is() {
    return "vaadin-dialog-overlay";
  }
  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = super.template.cloneNode(true);
      const contentPart = memoizedTemplate.content.querySelector('[part="content"]');
      const overlayPart = memoizedTemplate.content.querySelector('[part="overlay"]');
      const resizerContainer = document.createElement("section");
      resizerContainer.id = "resizerContainer";
      resizerContainer.classList.add("resizer-container");
      resizerContainer.appendChild(contentPart);
      overlayPart.appendChild(resizerContainer);
      const headerContainer = document.createElement("header");
      headerContainer.setAttribute("part", "header");
      resizerContainer.insertBefore(headerContainer, contentPart);
      const titleContainer = document.createElement("div");
      titleContainer.setAttribute("part", "title");
      headerContainer.appendChild(titleContainer);
      const titleSlot = document.createElement("slot");
      titleSlot.setAttribute("name", "title");
      titleContainer.appendChild(titleSlot);
      const headerContentContainer = document.createElement("div");
      headerContentContainer.setAttribute("part", "header-content");
      headerContainer.appendChild(headerContentContainer);
      const headerSlot = document.createElement("slot");
      headerSlot.setAttribute("name", "header-content");
      headerContentContainer.appendChild(headerSlot);
      const footerContainer = document.createElement("footer");
      footerContainer.setAttribute("part", "footer");
      resizerContainer.appendChild(footerContainer);
      const footerSlot = document.createElement("slot");
      footerSlot.setAttribute("name", "footer");
      footerContainer.appendChild(footerSlot);
    }
    return memoizedTemplate;
  }
  static get observers() {
    return [
      "_headerFooterRendererChange(headerRenderer, footerRenderer, opened)",
      "_headerTitleChanged(headerTitle, opened)"
    ];
  }
  static get properties() {
    return {
      modeless: Boolean,
      withBackdrop: Boolean,
      headerTitle: String,
      headerRenderer: Function,
      footerRenderer: Function
    };
  }
  ready() {
    super.ready();
    this.__resizeObserver = new ResizeObserver(() => {
      this.__updateOverflow();
    });
    this.__resizeObserver.observe(this.$.resizerContainer);
    this.$.content.addEventListener("scroll", () => {
      this.__updateOverflow();
    });
  }
  __createContainer(slot) {
    const container = document.createElement("div");
    container.setAttribute("slot", slot);
    return container;
  }
  __clearContainer(container) {
    container.innerHTML = "";
    delete container._$litPart$;
  }
  __initContainer(container, slot) {
    if (container) {
      this.__clearContainer(container);
    } else {
      container = this.__createContainer(slot);
    }
    return container;
  }
  _headerFooterRendererChange(headerRenderer, footerRenderer, opened) {
    const headerRendererChanged = this.__oldHeaderRenderer !== headerRenderer;
    this.__oldHeaderRenderer = headerRenderer;
    const footerRendererChanged = this.__oldFooterRenderer !== footerRenderer;
    this.__oldFooterRenderer = footerRenderer;
    const openedChanged = this._oldOpenedFooterHeader !== opened;
    this._oldOpenedFooterHeader = opened;
    this.toggleAttribute("has-header", !!headerRenderer);
    this.toggleAttribute("has-footer", !!footerRenderer);
    if (headerRendererChanged) {
      if (headerRenderer) {
        this.headerContainer = this.__initContainer(this.headerContainer, "header-content");
      } else if (this.headerContainer) {
        this.headerContainer.remove();
        this.headerContainer = null;
        this.__updateOverflow();
      }
    }
    if (footerRendererChanged) {
      if (footerRenderer) {
        this.footerContainer = this.__initContainer(this.footerContainer, "footer");
      } else if (this.footerContainer) {
        this.footerContainer.remove();
        this.footerContainer = null;
        this.__updateOverflow();
      }
    }
    if (headerRenderer && (headerRendererChanged || openedChanged) || footerRenderer && (footerRendererChanged || openedChanged)) {
      if (opened) {
        this.requestContentUpdate();
      }
    }
  }
  _headerTitleChanged(headerTitle, opened) {
    this.toggleAttribute("has-title", !!headerTitle);
    if (opened && (headerTitle || this._oldHeaderTitle)) {
      this.requestContentUpdate();
    }
    this._oldHeaderTitle = headerTitle;
  }
  _headerTitleRenderer() {
    if (this.headerTitle) {
      if (!this.headerTitleElement) {
        this.headerTitleElement = document.createElement("h2");
        this.headerTitleElement.setAttribute("slot", "title");
        this.headerTitleElement.classList.add("draggable");
      }
      this.appendChild(this.headerTitleElement);
      this.headerTitleElement.textContent = this.headerTitle;
    } else if (this.headerTitleElement) {
      this.headerTitleElement.remove();
      this.headerTitleElement = null;
    }
  }
  requestContentUpdate() {
    super.requestContentUpdate();
    if (this.headerContainer) {
      if (!this.headerContainer.parentElement) {
        this.appendChild(this.headerContainer);
      }
      if (this.headerRenderer) {
        this.headerRenderer.call(this.owner, this.headerContainer, this.owner);
      }
    }
    if (this.footerContainer) {
      if (!this.footerContainer.parentElement) {
        this.appendChild(this.footerContainer);
      }
      if (this.footerRenderer) {
        this.footerRenderer.call(this.owner, this.footerContainer, this.owner);
      }
    }
    this._headerTitleRenderer();
    this.__updateOverflow();
  }
  setBounds(bounds) {
    const overlay2 = this.$.overlay;
    const parsedBounds = { ...bounds };
    if (overlay2.style.position !== "absolute") {
      overlay2.style.position = "absolute";
      this.setAttribute("has-bounds-set", "");
      this.__forceSafariReflow();
    }
    Object.keys(parsedBounds).forEach((arg) => {
      if (typeof parsedBounds[arg] === "number") {
        parsedBounds[arg] = `${parsedBounds[arg]}px`;
      }
    });
    Object.assign(overlay2.style, parsedBounds);
  }
  getBounds() {
    const overlayBounds = this.$.overlay.getBoundingClientRect();
    const containerBounds = this.getBoundingClientRect();
    const top = overlayBounds.top - containerBounds.top;
    const left = overlayBounds.left - containerBounds.left;
    const width = overlayBounds.width;
    const height = overlayBounds.height;
    return { top, left, width, height };
  }
  __forceSafariReflow() {
    const scrollPosition = this.$.resizerContainer.scrollTop;
    const overlay2 = this.$.overlay;
    overlay2.style.display = "block";
    requestAnimationFrame(() => {
      overlay2.style.display = "";
      this.$.resizerContainer.scrollTop = scrollPosition;
    });
  }
  __updateOverflow() {
    let overflow = "";
    if (this.hasAttribute("has-header") || this.hasAttribute("has-footer") || this.headerTitle) {
      const content = this.$.content;
      if (content.scrollTop > 0) {
        overflow += " top";
      }
      if (content.scrollTop < content.scrollHeight - content.clientHeight) {
        overflow += " bottom";
      }
    }
    const value = overflow.trim();
    if (value.length > 0 && this.getAttribute("overflow") !== value) {
      this.setAttribute("overflow", value);
    } else if (value.length === 0 && this.hasAttribute("overflow")) {
      this.removeAttribute("overflow");
    }
  }
};
customElements.define(DialogOverlay.is, DialogOverlay);
var Dialog = class extends ThemePropertyMixin(ElementMixin(DialogDraggableMixin(DialogResizableMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: none !important;
        }
      </style>

      <vaadin-dialog-overlay
        id="overlay"
        header-title="[[headerTitle]]"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[_theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        focus-trap
      ></vaadin-dialog-overlay>
    `;
  }
  static get is() {
    return "vaadin-dialog";
  }
  static get properties() {
    return {
      opened: {
        type: Boolean,
        value: false,
        notify: true
      },
      noCloseOnOutsideClick: {
        type: Boolean,
        value: false
      },
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      ariaLabel: {
        type: String,
        value: ""
      },
      renderer: Function,
      headerTitle: String,
      headerRenderer: Function,
      footerRenderer: Function,
      modeless: {
        type: Boolean,
        value: false
      }
    };
  }
  static get observers() {
    return [
      "_openedChanged(opened)",
      "_ariaLabelChanged(ariaLabel, headerTitle)",
      "_rendererChanged(renderer, headerRenderer, footerRenderer)"
    ];
  }
  ready() {
    super.ready();
    this.$.overlay.setAttribute("role", "dialog");
    this.$.overlay.addEventListener("vaadin-overlay-outside-click", this._handleOutsideClick.bind(this));
    this.$.overlay.addEventListener("vaadin-overlay-escape-press", this._handleEscPress.bind(this));
    processTemplates(this);
  }
  requestContentUpdate() {
    this.$.overlay.requestContentUpdate();
  }
  _rendererChanged(renderer, headerRenderer, footerRenderer) {
    this.$.overlay.setProperties({ owner: this, renderer, headerRenderer, footerRenderer });
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.__restoreOpened) {
      this.opened = true;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__restoreOpened = this.opened;
    this.opened = false;
  }
  _openedChanged(opened) {
    this.$.overlay.opened = opened;
  }
  _ariaLabelChanged(ariaLabel, headerTitle) {
    if (ariaLabel || headerTitle) {
      this.$.overlay.setAttribute("aria-label", ariaLabel || headerTitle);
    } else {
      this.$.overlay.removeAttribute("aria-label");
    }
  }
  _onOverlayOpened(e) {
    if (e.detail.value === false) {
      this.opened = false;
    }
  }
  _handleOutsideClick(e) {
    if (this.noCloseOnOutsideClick) {
      e.preventDefault();
    }
  }
  _handleEscPress(e) {
    if (this.noCloseOnEsc) {
      e.preventDefault();
    }
  }
  _bringOverlayToFront() {
    if (this.modeless) {
      this.$.overlay.bringToFront();
    }
  }
};
customElements.define(Dialog.is, Dialog);

export {
  DialogOverlay,
  Dialog
};
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-MLY6EIQD.js.map
