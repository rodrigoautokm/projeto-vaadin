import {
  ActiveItemMixin
} from "./chunk-WRZI7T35.js";
import {
  updateColumnOrders
} from "./chunk-WCPVLQ3S.js";
import {
  Virtualizer
} from "./chunk-T7QYKO45.js";
import {
  processTemplates
} from "./chunk-CE2HX6X3.js";
import {
  ResizeMixin
} from "./chunk-C2K2GOEG.js";
import {
  isAndroid,
  isChrome,
  isFirefox,
  isIOS,
  isSafari,
  isTouch
} from "./chunk-XAUSENF3.js";
import {
  beforeNextRender
} from "./chunk-UMTV3SEQ.js";
import {
  FlattenedNodesObserver
} from "./chunk-4V7CPLV2.js";
import {
  TabindexMixin
} from "./chunk-37YVODLE.js";
import {
  addListener
} from "./chunk-ZB6KQ55W.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import {
  Debouncer
} from "./chunk-VUWTYCVF.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import {
  animationFrame,
  microTask,
  timeOut
} from "./chunk-CQH3N2QY.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";

// node_modules/@vaadin/grid/src/vaadin-grid-data-provider-mixin.js
var ItemCache = class ItemCache2 {
  constructor(grid, parentCache, parentItem) {
    this.grid = grid;
    this.parentCache = parentCache;
    this.parentItem = parentItem;
    this.itemCaches = {};
    this.items = {};
    this.effectiveSize = 0;
    this.size = 0;
    this.pendingRequests = {};
  }
  isLoading() {
    return Boolean(
      Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter((index) => {
        return this.itemCaches[index].isLoading();
      })[0]
    );
  }
  getItemForIndex(index) {
    const { cache, scaledIndex } = this.getCacheAndIndex(index);
    return cache.items[scaledIndex];
  }
  updateSize() {
    this.effectiveSize = !this.parentItem || this.grid._isExpanded(this.parentItem) ? this.size + Object.keys(this.itemCaches).reduce((prev, curr) => {
      const subCache = this.itemCaches[curr];
      subCache.updateSize();
      return prev + subCache.effectiveSize;
    }, 0) : 0;
  }
  ensureSubCacheForScaledIndex(scaledIndex) {
    if (!this.itemCaches[scaledIndex]) {
      const subCache = new ItemCache2(this.grid, this, this.items[scaledIndex]);
      this.itemCaches[scaledIndex] = subCache;
      this.grid._loadPage(0, subCache);
    }
  }
  getCacheAndIndex(index) {
    let thisLevelIndex = index;
    const keys = Object.keys(this.itemCaches);
    for (let i = 0; i < keys.length; i++) {
      const expandedIndex = Number(keys[i]);
      const subCache = this.itemCaches[expandedIndex];
      if (thisLevelIndex <= expandedIndex) {
        return { cache: this, scaledIndex: thisLevelIndex };
      } else if (thisLevelIndex <= expandedIndex + subCache.effectiveSize) {
        return subCache.getCacheAndIndex(thisLevelIndex - expandedIndex - 1);
      }
      thisLevelIndex -= subCache.effectiveSize;
    }
    return { cache: this, scaledIndex: thisLevelIndex };
  }
};
var DataProviderMixin = (superClass) => class DataProviderMixin extends superClass {
  static get properties() {
    return {
      size: {
        type: Number,
        notify: true
      },
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged"
      },
      dataProvider: {
        type: Object,
        notify: true,
        observer: "_dataProviderChanged"
      },
      loading: {
        type: Boolean,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },
      _cache: {
        type: Object,
        value() {
          const cache = new ItemCache(this);
          return cache;
        }
      },
      _hasData: {
        type: Boolean,
        value: false
      },
      itemHasChildrenPath: {
        type: String,
        value: "children"
      },
      itemIdPath: {
        type: String,
        value: null
      },
      expandedItems: {
        type: Object,
        notify: true,
        value: () => []
      },
      __expandedKeys: {
        type: Object,
        computed: "__computeExpandedKeys(itemIdPath, expandedItems.*)"
      }
    };
  }
  static get observers() {
    return ["_sizeChanged(size)", "_expandedItemsChanged(expandedItems.*)"];
  }
  _sizeChanged(size) {
    const delta = size - this._cache.size;
    this._cache.size += delta;
    this._cache.effectiveSize += delta;
    this._effectiveSize = this._cache.effectiveSize;
  }
  _getItem(index, el) {
    if (index >= this._effectiveSize) {
      return;
    }
    el.index = index;
    const { cache, scaledIndex } = this._cache.getCacheAndIndex(index);
    const item = cache.items[scaledIndex];
    if (item) {
      el.toggleAttribute("loading", false);
      this._updateItem(el, item);
      if (this._isExpanded(item)) {
        cache.ensureSubCacheForScaledIndex(scaledIndex);
      }
    } else {
      el.toggleAttribute("loading", true);
      this._loadPage(this._getPageForIndex(scaledIndex), cache);
    }
  }
  getItemId(item) {
    return this.itemIdPath ? this.get(this.itemIdPath, item) : item;
  }
  _isExpanded(item) {
    return this.__expandedKeys.has(this.getItemId(item));
  }
  _expandedItemsChanged() {
    this._cache.updateSize();
    this._effectiveSize = this._cache.effectiveSize;
    this.__updateVisibleRows();
  }
  __computeExpandedKeys(itemIdPath, expandedItems) {
    const expanded = expandedItems.base || [];
    const expandedKeys = /* @__PURE__ */ new Set();
    expanded.forEach((item) => {
      expandedKeys.add(this.getItemId(item));
    });
    return expandedKeys;
  }
  expandItem(item) {
    if (!this._isExpanded(item)) {
      this.expandedItems = [...this.expandedItems, item];
    }
  }
  collapseItem(item) {
    if (this._isExpanded(item)) {
      this.expandedItems = this.expandedItems.filter((i) => !this._itemsEqual(i, item));
    }
  }
  _getIndexLevel(index) {
    let { cache } = this._cache.getCacheAndIndex(index);
    let level = 0;
    while (cache.parentCache) {
      cache = cache.parentCache;
      level += 1;
    }
    return level;
  }
  _loadPage(page, cache) {
    if (!cache.pendingRequests[page] && this.dataProvider) {
      this._setLoading(true);
      cache.pendingRequests[page] = true;
      const params = {
        page,
        pageSize: this.pageSize,
        sortOrders: this._mapSorters(),
        filters: this._mapFilters(),
        parentItem: cache.parentItem
      };
      this.dataProvider(params, (items, size) => {
        if (size !== void 0) {
          cache.size = size;
        } else if (params.parentItem) {
          cache.size = items.length;
        }
        const currentItems = Array.from(this.$.items.children).map((row) => row._item);
        items.forEach((item, itemsIndex) => {
          const itemIndex = page * this.pageSize + itemsIndex;
          cache.items[itemIndex] = item;
          if (this._isExpanded(item) && currentItems.indexOf(item) > -1) {
            cache.ensureSubCacheForScaledIndex(itemIndex);
          }
        });
        this._hasData = true;
        delete cache.pendingRequests[page];
        this._debouncerApplyCachedData = Debouncer.debounce(this._debouncerApplyCachedData, timeOut.after(0), () => {
          this._setLoading(false);
          this._cache.updateSize();
          this._effectiveSize = this._cache.effectiveSize;
          Array.from(this.$.items.children).filter((row) => !row.hidden).forEach((row) => {
            const cachedItem = this._cache.getItemForIndex(row.index);
            if (cachedItem) {
              this._getItem(row.index, row);
            }
          });
          this.__scrollToPendingIndex();
        });
        if (!this._cache.isLoading()) {
          this._debouncerApplyCachedData.flush();
        }
        this.__itemsReceived();
      });
    }
  }
  _getPageForIndex(index) {
    return Math.floor(index / this.pageSize);
  }
  clearCache() {
    this._cache = new ItemCache(this);
    this._cache.size = this.size || 0;
    this._cache.updateSize();
    this._hasData = false;
    this.__updateVisibleRows();
    if (!this._effectiveSize) {
      this._loadPage(0, this._cache);
    }
  }
  _pageSizeChanged(pageSize, oldPageSize) {
    if (oldPageSize !== void 0 && pageSize !== oldPageSize) {
      this.clearCache();
    }
  }
  _checkSize() {
    if (this.size === void 0 && this._effectiveSize === 0) {
      console.warn(
        "The <vaadin-grid> needs the total number of items in order to display rows. Set the total number of items to the `size` property, or provide the total number of items in the second argument of the `dataProvider`\u2019s `callback` call."
      );
    }
  }
  _dataProviderChanged(dataProvider, oldDataProvider) {
    if (oldDataProvider !== void 0) {
      this.clearCache();
    }
    this._ensureFirstPageLoaded();
    this._debouncerCheckSize = Debouncer.debounce(
      this._debouncerCheckSize,
      timeOut.after(2e3),
      this._checkSize.bind(this)
    );
  }
  _ensureFirstPageLoaded() {
    if (!this._hasData) {
      this._loadPage(0, this._cache);
    }
  }
  _itemsEqual(item1, item2) {
    return this.getItemId(item1) === this.getItemId(item2);
  }
  _getItemIndexInArray(item, array) {
    let result = -1;
    array.forEach((i, idx) => {
      if (this._itemsEqual(i, item)) {
        result = idx;
      }
    });
    return result;
  }
  scrollToIndex(index) {
    super.scrollToIndex(index);
    if (!isNaN(index) && (this._cache.isLoading() || !this.clientHeight)) {
      this.__pendingScrollToIndex = index;
    }
  }
  __scrollToPendingIndex() {
    if (this.__pendingScrollToIndex && this.$.items.children.length) {
      const index = this.__pendingScrollToIndex;
      delete this.__pendingScrollToIndex;
      this.scrollToIndex(index);
    }
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-styles.js
registerStyles(
  "vaadin-grid",
  css`
    @keyframes vaadin-grid-appear {
      to {
        opacity: 1;
      }
    }

    :host {
      display: block;
      animation: 1ms vaadin-grid-appear;
      height: 400px;
      flex: 1 1 auto;
      align-self: stretch;
      position: relative;
    }

    :host([hidden]) {
      display: none !important;
    }

    :host([disabled]) {
      pointer-events: none;
    }

    #scroller {
      display: block;
      transform: translateY(0);
      width: auto;
      height: auto;
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

    :host([all-rows-visible]) {
      height: auto;
      align-self: flex-start;
      flex-grow: 0;
      width: 100%;
    }

    :host([all-rows-visible]) #scroller {
      width: 100%;
      height: 100%;
      position: relative;
    }

    :host([all-rows-visible]) #items {
      min-height: 1px;
    }

    #table {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
      overflow: auto;
      position: relative;
      outline: none;
      /* Workaround for a Desktop Safari bug: new stacking context here prevents the scrollbar from getting hidden */
      z-index: 0;
    }

    #header,
    #footer {
      display: block;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      overflow: visible;
      width: 100%;
      z-index: 1;
    }

    #header {
      top: 0;
    }

    th {
      text-align: inherit;
    }

    /* Safari doesn't work with "inherit" */
    [safari] th {
      text-align: initial;
    }

    #footer {
      bottom: 0;
    }

    #items {
      flex-grow: 1;
      flex-shrink: 0;
      display: block;
      position: -webkit-sticky;
      position: sticky;
      width: 100%;
      left: 0;
      overflow: visible;
    }

    [part~='row'] {
      display: flex;
      width: 100%;
      box-sizing: border-box;
      margin: 0;
    }

    [part~='row'][loading] [part~='body-cell'] ::slotted(vaadin-grid-cell-content) {
      opacity: 0;
    }

    #items [part~='row'] {
      position: absolute;
    }

    #items [part~='row']:empty {
      height: 100%;
    }

    [part~='cell']:not([part~='details-cell']) {
      flex-shrink: 0;
      flex-grow: 1;
      box-sizing: border-box;
      display: flex;
      width: 100%;
      position: relative;
      align-items: center;
      padding: 0;
      white-space: nowrap;
    }

    [part~='details-cell'] {
      position: absolute;
      bottom: 0;
      width: 100%;
      box-sizing: border-box;
      padding: 0;
    }

    [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      display: block;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    [hidden] {
      display: none !important;
    }

    [frozen],
    [frozen-to-end] {
      z-index: 2;
      will-change: transform;
    }

    [no-scrollbars][safari] #table,
    [no-scrollbars][firefox] #table {
      overflow: hidden;
    }

    /* Reordering styles */
    :host([reordering]) [part~='cell'] ::slotted(vaadin-grid-cell-content),
    :host([reordering]) [part~='resize-handle'],
    #scroller[no-content-pointer-events] [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      pointer-events: none;
    }

    [part~='reorder-ghost'] {
      visibility: hidden;
      position: fixed;
      pointer-events: none;
      opacity: 0.5;

      /* Prevent overflowing the grid in Firefox */
      top: 0;
      left: 0;
    }

    :host([reordering]) {
      -moz-user-select: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Resizing styles */
    [part~='resize-handle'] {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
      cursor: col-resize;
      z-index: 1;
    }

    [part~='resize-handle']::before {
      position: absolute;
      content: '';
      height: 100%;
      width: 35px;
      transform: translateX(-50%);
    }

    [last-column] [part~='resize-handle']::before,
    [last-frozen] [part~='resize-handle']::before {
      width: 18px;
      transform: none;
      right: 0;
    }

    [frozen-to-end] [part~='resize-handle'] {
      left: 0;
      right: auto;
    }

    [frozen-to-end] [part~='resize-handle']::before {
      left: 0;
      right: auto;
    }

    [first-frozen-to-end] [part~='resize-handle']::before {
      width: 18px;
      transform: none;
    }

    [first-frozen-to-end] {
      margin-inline-start: auto;
    }

    /* Hide resize handle if scrolled to end */
    :host(:not([overflow~='end'])) [first-frozen-to-end] [part~='resize-handle'] {
      display: none;
    }

    #scroller[column-resizing] {
      -ms-user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Sizer styles */
    #sizer {
      display: flex;
      position: absolute;
      visibility: hidden;
    }

    #sizer [part~='details-cell'] {
      display: none !important;
    }

    #sizer [part~='cell'][hidden] {
      display: none !important;
    }

    #sizer [part~='cell'] {
      display: block;
      flex-shrink: 0;
      line-height: 0;
      height: 0 !important;
      min-height: 0 !important;
      max-height: 0 !important;
      padding: 0 !important;
      border: none !important;
    }

    #sizer [part~='cell']::before {
      content: '-';
    }

    #sizer [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      display: none !important;
    }

    /* RTL specific styles */

    :host([dir='rtl']) #items,
    :host([dir='rtl']) #header,
    :host([dir='rtl']) #footer {
      left: auto;
    }

    :host([dir='rtl']) [part~='reorder-ghost'] {
      left: auto;
      right: 0;
    }

    :host([dir='rtl']) [part~='resize-handle'] {
      left: 0;
      right: auto;
    }

    :host([dir='rtl']) [part~='resize-handle']::before {
      transform: translateX(50%);
    }

    :host([dir='rtl']) [last-column] [part~='resize-handle']::before,
    :host([dir='rtl']) [last-frozen] [part~='resize-handle']::before {
      left: 0;
      right: auto;
    }

    :host([dir='rtl']) [frozen-to-end] [part~='resize-handle'] {
      right: 0;
      left: auto;
    }

    :host([dir='rtl']) [frozen-to-end] [part~='resize-handle']::before {
      right: 0;
      left: auto;
    }
  `,
  { moduleId: "vaadin-grid-styles" }
);

// node_modules/@vaadin/grid/src/vaadin-grid-a11y-mixin.js
var A11yMixin = (superClass) => class A11yMixin extends superClass {
  static get observers() {
    return ["_a11yUpdateGridSize(size, _columnTree, _columnTree.*)"];
  }
  _a11yGetHeaderRowCount(_columnTree) {
    return _columnTree.filter((level) => level.some((col) => col.headerRenderer || col.path || col.header)).length;
  }
  _a11yGetFooterRowCount(_columnTree) {
    return _columnTree.filter((level) => level.some((col) => col.headerRenderer)).length;
  }
  _a11yUpdateGridSize(size, _columnTree) {
    if (size === void 0 || _columnTree === void 0) {
      return;
    }
    const bodyColumns = _columnTree[_columnTree.length - 1];
    this.$.table.setAttribute(
      "aria-rowcount",
      size + this._a11yGetHeaderRowCount(_columnTree) + this._a11yGetFooterRowCount(_columnTree)
    );
    this.$.table.setAttribute("aria-colcount", bodyColumns && bodyColumns.length || 0);
    this._a11yUpdateHeaderRows();
    this._a11yUpdateFooterRows();
  }
  _a11yUpdateHeaderRows() {
    Array.from(this.$.header.children).forEach(
      (headerRow, index) => headerRow.setAttribute("aria-rowindex", index + 1)
    );
  }
  _a11yUpdateFooterRows() {
    Array.from(this.$.footer.children).forEach(
      (footerRow, index) => footerRow.setAttribute("aria-rowindex", this._a11yGetHeaderRowCount(this._columnTree) + this.size + index + 1)
    );
  }
  _a11yUpdateRowRowindex(row, index) {
    row.setAttribute("aria-rowindex", index + this._a11yGetHeaderRowCount(this._columnTree) + 1);
  }
  _a11yUpdateRowSelected(row, selected) {
    row.setAttribute("aria-selected", Boolean(selected));
    Array.from(row.children).forEach((cell) => cell.setAttribute("aria-selected", Boolean(selected)));
  }
  _a11yUpdateRowExpanded(row) {
    if (this.__isRowExpandable(row)) {
      row.setAttribute("aria-expanded", "false");
    } else if (this.__isRowCollapsible(row)) {
      row.setAttribute("aria-expanded", "true");
    } else {
      row.removeAttribute("aria-expanded");
    }
  }
  _a11yUpdateRowLevel(row, level) {
    if (level > 0 || this.__isRowCollapsible(row) || this.__isRowExpandable(row)) {
      row.setAttribute("aria-level", level + 1);
    } else {
      row.removeAttribute("aria-level");
    }
  }
  _a11ySetRowDetailsCell(row, detailsCell) {
    Array.from(row.children).forEach((cell) => {
      if (cell !== detailsCell) {
        cell.setAttribute("aria-controls", detailsCell.id);
      }
    });
  }
  _a11yUpdateCellColspan(cell, colspan) {
    cell.setAttribute("aria-colspan", Number(colspan));
  }
  _a11yUpdateSorters() {
    Array.from(this.querySelectorAll("vaadin-grid-sorter")).forEach((sorter) => {
      let cellContent = sorter.parentNode;
      while (cellContent && cellContent.localName !== "vaadin-grid-cell-content") {
        cellContent = cellContent.parentNode;
      }
      if (cellContent && cellContent.assignedSlot) {
        const cell = cellContent.assignedSlot.parentNode;
        cell.setAttribute(
          "aria-sort",
          {
            asc: "ascending",
            desc: "descending"
          }[String(sorter.direction)] || "none"
        );
      }
    });
  }
};

// node_modules/@vaadin/grid/src/array-data-provider.js
function get(path, object) {
  return path.split(".").reduce((obj, property) => obj[property], object);
}
function checkPaths(arrayToCheck, action, items) {
  if (items.length === 0) {
    return false;
  }
  let result = true;
  arrayToCheck.forEach(({ path }) => {
    if (!path || path.indexOf(".") === -1) {
      return;
    }
    const parentProperty = path.replace(/\.[^.]*$/, "");
    if (get(parentProperty, items[0]) === void 0) {
      console.warn(`Path "${path}" used for ${action} does not exist in all of the items, ${action} is disabled.`);
      result = false;
    }
  });
  return result;
}
function multiSort(items, sortOrders) {
  return items.sort((a, b) => {
    return sortOrders.map((sortOrder) => {
      if (sortOrder.direction === "asc") {
        return compare(get(sortOrder.path, a), get(sortOrder.path, b));
      } else if (sortOrder.direction === "desc") {
        return compare(get(sortOrder.path, b), get(sortOrder.path, a));
      }
      return 0;
    }).reduce((p, n) => {
      return p !== 0 ? p : n;
    }, 0);
  });
}
function normalizeEmptyValue(value) {
  if ([void 0, null].indexOf(value) >= 0) {
    return "";
  } else if (isNaN(value)) {
    return value.toString();
  }
  return value;
}
function compare(a, b) {
  a = normalizeEmptyValue(a);
  b = normalizeEmptyValue(b);
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function filter(items, filters) {
  return items.filter((item) => {
    return filters.every((filter2) => {
      const value = normalizeEmptyValue(get(filter2.path, item));
      const filterValueLowercase = normalizeEmptyValue(filter2.value).toString().toLowerCase();
      return value.toString().toLowerCase().includes(filterValueLowercase);
    });
  });
}
var createArrayDataProvider = (allItems) => {
  return (params, callback) => {
    let items = allItems ? [...allItems] : [];
    if (params.filters && checkPaths(params.filters, "filtering", items)) {
      items = filter(items, params.filters);
    }
    if (Array.isArray(params.sortOrders) && params.sortOrders.length && checkPaths(params.sortOrders, "sorting", items)) {
      items = multiSort(items, params.sortOrders);
    }
    const count = Math.min(items.length, params.pageSize);
    const start = params.page * count;
    const end = start + count;
    const slice = items.slice(start, end);
    callback(slice, items.length);
  };
};

// node_modules/@vaadin/grid/src/vaadin-grid-array-data-provider-mixin.js
var ArrayDataProviderMixin = (superClass) => class ArrayDataProviderMixin extends superClass {
  static get properties() {
    return {
      items: Array
    };
  }
  static get observers() {
    return ["__dataProviderOrItemsChanged(dataProvider, items, isAttached, items.*, _filters, _sorters)"];
  }
  __setArrayDataProvider(items) {
    const arrayDataProvider = createArrayDataProvider(this.items, {});
    arrayDataProvider.__items = items;
    this.setProperties({
      _arrayDataProvider: arrayDataProvider,
      size: items.length,
      dataProvider: arrayDataProvider
    });
  }
  __dataProviderOrItemsChanged(dataProvider, items, isAttached) {
    if (!isAttached) {
      return;
    }
    if (this._arrayDataProvider) {
      if (dataProvider !== this._arrayDataProvider) {
        this.setProperties({
          _arrayDataProvider: void 0,
          items: void 0
        });
      } else if (!items) {
        this.setProperties({
          _arrayDataProvider: void 0,
          dataProvider: void 0,
          size: 0
        });
        this.clearCache();
      } else if (this._arrayDataProvider.__items === items) {
        this.clearCache();
        this.size = this._effectiveSize;
      } else {
        this.__setArrayDataProvider(items);
      }
    } else if (items) {
      this.__setArrayDataProvider(items);
    }
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-column-reordering-mixin.js
var ColumnReorderingMixin = (superClass) => class ColumnReorderingMixin extends superClass {
  static get properties() {
    return {
      columnReorderingAllowed: {
        type: Boolean,
        value: false
      },
      _orderBaseScope: {
        type: Number,
        value: 1e7
      }
    };
  }
  static get observers() {
    return ["_updateOrders(_columnTree, _columnTree.*)"];
  }
  ready() {
    super.ready();
    addListener(this, "track", this._onTrackEvent);
    this._reorderGhost = this.shadowRoot.querySelector('[part="reorder-ghost"]');
    this.addEventListener("touchstart", this._onTouchStart.bind(this));
    this.addEventListener("touchmove", this._onTouchMove.bind(this));
    this.addEventListener("touchend", this._onTouchEnd.bind(this));
    this.addEventListener("contextmenu", this._onContextMenu.bind(this));
  }
  _onContextMenu(e) {
    if (this.hasAttribute("reordering")) {
      e.preventDefault();
    }
  }
  _onTouchStart(e) {
    this._startTouchReorderTimeout = setTimeout(() => {
      this._onTrackStart({
        detail: {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY
        }
      });
    }, 100);
  }
  _onTouchMove(e) {
    if (this._draggedColumn) {
      e.preventDefault();
    }
    clearTimeout(this._startTouchReorderTimeout);
  }
  _onTouchEnd() {
    clearTimeout(this._startTouchReorderTimeout);
    this._onTrackEnd();
  }
  _onTrackEvent(e) {
    if (e.detail.state === "start") {
      const path = e.composedPath();
      const headerCell = path[path.indexOf(this.$.header) - 2];
      if (!headerCell || !headerCell._content) {
        return;
      }
      if (headerCell._content.contains(this.getRootNode().activeElement)) {
        return;
      }
      if (this.$.scroller.hasAttribute("column-resizing")) {
        return;
      }
      if (!this._touchDevice) {
        this._onTrackStart(e);
      }
    } else if (e.detail.state === "track") {
      this._onTrack(e);
    } else if (e.detail.state === "end") {
      this._onTrackEnd(e);
    }
  }
  _onTrackStart(e) {
    if (!this.columnReorderingAllowed) {
      return;
    }
    const path = e.composedPath && e.composedPath();
    if (path && path.filter((node) => node.hasAttribute && node.hasAttribute("draggable"))[0]) {
      return;
    }
    const headerCell = this._cellFromPoint(e.detail.x, e.detail.y);
    if (!headerCell || headerCell.getAttribute("part").indexOf("header-cell") === -1) {
      return;
    }
    this.toggleAttribute("reordering", true);
    this._draggedColumn = headerCell._column;
    while (this._draggedColumn.parentElement.childElementCount === 1) {
      this._draggedColumn = this._draggedColumn.parentElement;
    }
    this._setSiblingsReorderStatus(this._draggedColumn, "allowed");
    this._draggedColumn._reorderStatus = "dragging";
    this._updateGhost(headerCell);
    this._reorderGhost.style.visibility = "visible";
    this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);
    this._autoScroller();
  }
  _onTrack(e) {
    if (!this._draggedColumn) {
      return;
    }
    const targetCell = this._cellFromPoint(e.detail.x, e.detail.y);
    if (!targetCell) {
      return;
    }
    const targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);
    if (this._isSwapAllowed(this._draggedColumn, targetColumn) && this._isSwappableByPosition(targetColumn, e.detail.x)) {
      const columnTreeLevel = this._columnTree.findIndex((level) => level.includes(targetColumn));
      const levelColumnsInOrder = this._getColumnsInOrder(columnTreeLevel);
      const startIndex = levelColumnsInOrder.indexOf(this._draggedColumn);
      const endIndex = levelColumnsInOrder.indexOf(targetColumn);
      const direction = startIndex < endIndex ? 1 : -1;
      for (let i = startIndex; i !== endIndex; i += direction) {
        this._swapColumnOrders(this._draggedColumn, levelColumnsInOrder[i + direction]);
      }
    }
    this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);
    this._lastDragClientX = e.detail.x;
  }
  _onTrackEnd() {
    if (!this._draggedColumn) {
      return;
    }
    this.toggleAttribute("reordering", false);
    this._draggedColumn._reorderStatus = "";
    this._setSiblingsReorderStatus(this._draggedColumn, "");
    this._draggedColumn = null;
    this._lastDragClientX = null;
    this._reorderGhost.style.visibility = "hidden";
    this.dispatchEvent(
      new CustomEvent("column-reorder", {
        detail: {
          columns: this._getColumnsInOrder()
        }
      })
    );
  }
  _getColumnsInOrder(headerLevel = this._columnTree.length - 1) {
    return this._columnTree[headerLevel].filter((c) => !c.hidden).sort((b, a) => b._order - a._order);
  }
  _cellFromPoint(x, y) {
    x = x || 0;
    y = y || 0;
    if (!this._draggedColumn) {
      this.$.scroller.toggleAttribute("no-content-pointer-events", true);
    }
    const cell = this.shadowRoot.elementFromPoint(x, y);
    this.$.scroller.toggleAttribute("no-content-pointer-events", false);
    if (cell && cell._column) {
      return cell;
    }
  }
  _updateGhostPosition(eventClientX, eventClientY) {
    const ghostRect = this._reorderGhost.getBoundingClientRect();
    const targetLeft = eventClientX - ghostRect.width / 2;
    const targetTop = eventClientY - ghostRect.height / 2;
    const _left = parseInt(this._reorderGhost._left || 0);
    const _top = parseInt(this._reorderGhost._top || 0);
    this._reorderGhost._left = _left - (ghostRect.left - targetLeft);
    this._reorderGhost._top = _top - (ghostRect.top - targetTop);
    this._reorderGhost.style.transform = `translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`;
  }
  _updateGhost(cell) {
    const ghost = this._reorderGhost;
    ghost.textContent = cell._content.innerText;
    const style = window.getComputedStyle(cell);
    [
      "boxSizing",
      "display",
      "width",
      "height",
      "background",
      "alignItems",
      "padding",
      "border",
      "flex-direction",
      "overflow"
    ].forEach((propertyName) => {
      ghost.style[propertyName] = style[propertyName];
    });
    return ghost;
  }
  _updateOrders(columnTree, splices) {
    if (columnTree === void 0 || splices === void 0) {
      return;
    }
    columnTree[0].forEach((column) => {
      column._order = 0;
    });
    updateColumnOrders(columnTree[0], this._orderBaseScope, 0);
  }
  _setSiblingsReorderStatus(column, status) {
    Array.from(column.parentNode.children).filter((child) => /column/.test(child.localName) && this._isSwapAllowed(child, column)).forEach((sibling) => {
      sibling._reorderStatus = status;
    });
  }
  _autoScroller() {
    if (this._lastDragClientX) {
      const rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;
      const leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;
      if (rightDiff > 0) {
        this.$.table.scrollLeft += rightDiff / 10;
      } else if (leftDiff > 0) {
        this.$.table.scrollLeft -= leftDiff / 10;
      }
    }
    if (this._draggedColumn) {
      setTimeout(() => this._autoScroller(), 10);
    }
  }
  _isSwapAllowed(column1, column2) {
    if (column1 && column2) {
      const differentColumns = column1 !== column2;
      const sameParent = column1.parentElement === column2.parentElement;
      const sameFrozen = column1.frozen && column2.frozen || column1.frozenToEnd && column2.frozenToEnd || !column1.frozen && !column1.frozenToEnd && !column2.frozen && !column2.frozenToEnd;
      return differentColumns && sameParent && sameFrozen;
    }
  }
  _isSwappableByPosition(targetColumn, clientX) {
    const targetCell = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~="cell"]')).filter(
      (cell) => targetColumn.contains(cell._column)
    )[0];
    const sourceCellRect = this.$.header.querySelector("tr:not([hidden]) [reorder-status=dragging]").getBoundingClientRect();
    const targetRect = targetCell.getBoundingClientRect();
    if (targetRect.left > sourceCellRect.left) {
      return clientX > targetRect.right - sourceCellRect.width;
    }
    return clientX < targetRect.left + sourceCellRect.width;
  }
  _swapColumnOrders(column1, column2) {
    const _order = column1._order;
    column1._order = column2._order;
    column2._order = _order;
    this._updateFrozenColumn();
    this._updateFirstAndLastColumn();
  }
  _getTargetColumn(targetCell, draggedColumn) {
    if (targetCell && draggedColumn) {
      let candidate = targetCell._column;
      while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {
        candidate = candidate.parentElement;
      }
      if (candidate.parentElement === draggedColumn.parentElement) {
        return candidate;
      }
      return targetCell._column;
    }
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-column-resizing-mixin.js
var ColumnResizingMixin = (superClass) => class ColumnResizingMixin extends superClass {
  ready() {
    super.ready();
    const scroller = this.$.scroller;
    addListener(scroller, "track", this._onHeaderTrack.bind(this));
    scroller.addEventListener("touchmove", (e) => scroller.hasAttribute("column-resizing") && e.preventDefault());
    scroller.addEventListener(
      "contextmenu",
      (e) => e.target.getAttribute("part") === "resize-handle" && e.preventDefault()
    );
    scroller.addEventListener(
      "mousedown",
      (e) => e.target.getAttribute("part") === "resize-handle" && e.preventDefault()
    );
  }
  _onHeaderTrack(e) {
    const handle = e.target;
    if (handle.getAttribute("part") === "resize-handle") {
      const cell = handle.parentElement;
      let column = cell._column;
      this.$.scroller.toggleAttribute("column-resizing", true);
      while (column.localName === "vaadin-grid-column-group") {
        column = column._childColumns.slice(0).sort((a, b) => a._order - b._order).filter((column2) => !column2.hidden).pop();
      }
      const eventX = e.detail.x;
      const columnRowCells = Array.from(this.$.header.querySelectorAll('[part~="row"]:last-child [part~="cell"]'));
      const targetCell = columnRowCells.filter((cell2) => cell2._column === column)[0];
      if (targetCell.offsetWidth) {
        const style = getComputedStyle(targetCell._content);
        const minWidth = 10 + parseInt(style.paddingLeft) + parseInt(style.paddingRight) + parseInt(style.borderLeftWidth) + parseInt(style.borderRightWidth) + parseInt(style.marginLeft) + parseInt(style.marginRight);
        let maxWidth;
        const cellWidth = targetCell.offsetWidth;
        const cellRect = targetCell.getBoundingClientRect();
        if (targetCell.hasAttribute("frozen-to-end")) {
          maxWidth = cellWidth + (this.__isRTL ? eventX - cellRect.right : cellRect.left - eventX);
        } else {
          maxWidth = cellWidth + (this.__isRTL ? cellRect.left - eventX : eventX - cellRect.right);
        }
        column.width = `${Math.max(minWidth, maxWidth)}px`;
        column.flexGrow = 0;
      }
      columnRowCells.sort((a, b) => a._column._order - b._column._order).forEach((cell2, index, array) => {
        if (index < array.indexOf(targetCell)) {
          cell2._column.width = `${cell2.offsetWidth}px`;
          cell2._column.flexGrow = 0;
        }
      });
      const cellFrozenToEnd = this._frozenToEndCells[0];
      if (cellFrozenToEnd && this.$.table.scrollWidth > this.$.table.offsetWidth) {
        const frozenRect = cellFrozenToEnd.getBoundingClientRect();
        const offset = eventX - (this.__isRTL ? frozenRect.right : frozenRect.left);
        if (this.__isRTL && offset <= 0 || !this.__isRTL && offset >= 0) {
          this.$.table.scrollLeft += offset;
        }
      }
      if (e.detail.state === "end") {
        this.$.scroller.toggleAttribute("column-resizing", false);
        this.dispatchEvent(
          new CustomEvent("column-resize", {
            detail: { resizedColumn: column }
          })
        );
      }
      this._resizeHandler();
    }
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-drag-and-drop-mixin.js
var DropMode = {
  BETWEEN: "between",
  ON_TOP: "on-top",
  ON_TOP_OR_BETWEEN: "on-top-or-between",
  ON_GRID: "on-grid"
};
var DropLocation = {
  ON_TOP: "on-top",
  ABOVE: "above",
  BELOW: "below",
  EMPTY: "empty"
};
var usesDnDPolyfill = !("draggable" in document.createElement("div"));
var DragAndDropMixin = (superClass) => class DragAndDropMixin extends superClass {
  static get properties() {
    return {
      dropMode: String,
      rowsDraggable: Boolean,
      dragFilter: Function,
      dropFilter: Function,
      __dndAutoScrollThreshold: {
        value: 50
      }
    };
  }
  static get observers() {
    return ["_dragDropAccessChanged(rowsDraggable, dropMode, dragFilter, dropFilter, loading)"];
  }
  ready() {
    super.ready();
    this.$.table.addEventListener("dragstart", this._onDragStart.bind(this));
    this.$.table.addEventListener("dragend", this._onDragEnd.bind(this));
    this.$.table.addEventListener("dragover", this._onDragOver.bind(this));
    this.$.table.addEventListener("dragleave", this._onDragLeave.bind(this));
    this.$.table.addEventListener("drop", this._onDrop.bind(this));
    this.$.table.addEventListener("dragenter", (e) => {
      if (this.dropMode) {
        e.preventDefault();
        e.stopPropagation();
      }
    });
  }
  _onDragStart(e) {
    if (this.rowsDraggable) {
      let row = e.target;
      if (row.localName === "vaadin-grid-cell-content") {
        row = row.assignedSlot.parentNode.parentNode;
      }
      if (row.parentNode !== this.$.items) {
        return;
      }
      e.stopPropagation();
      this.toggleAttribute("dragging-rows", true);
      if (this._safari) {
        const transform = row.style.transform;
        row.style.top = /translateY\((.*)\)/.exec(transform)[1];
        row.style.transform = "none";
        requestAnimationFrame(() => {
          row.style.top = "";
          row.style.transform = transform;
        });
      }
      const rowRect = row.getBoundingClientRect();
      if (usesDnDPolyfill) {
        e.dataTransfer.setDragImage(row);
      } else {
        e.dataTransfer.setDragImage(row, e.clientX - rowRect.left, e.clientY - rowRect.top);
      }
      let rows = [row];
      if (this._isSelected(row._item)) {
        rows = this.__getViewportRows().filter((row2) => this._isSelected(row2._item)).filter((row2) => !this.dragFilter || this.dragFilter(this.__getRowModel(row2)));
      }
      e.dataTransfer.setData("text", this.__formatDefaultTransferData(rows));
      row.setAttribute("dragstart", rows.length > 1 ? rows.length : "");
      this.style.setProperty("--_grid-drag-start-x", `${e.clientX - rowRect.left + 20}px`);
      this.style.setProperty("--_grid-drag-start-y", `${e.clientY - rowRect.top + 10}px`);
      requestAnimationFrame(() => {
        row.removeAttribute("dragstart");
        this.updateStyles({ "--_grid-drag-start-x": "", "--_grid-drag-start-y": "" });
      });
      const event = new CustomEvent("grid-dragstart", {
        detail: {
          draggedItems: rows.map((row2) => row2._item),
          setDragData: (type, data) => e.dataTransfer.setData(type, data),
          setDraggedItemsCount: (count) => row.setAttribute("dragstart", count)
        }
      });
      event.originalEvent = e;
      this.dispatchEvent(event);
    }
  }
  _onDragEnd(e) {
    this.toggleAttribute("dragging-rows", false);
    e.stopPropagation();
    const event = new CustomEvent("grid-dragend");
    event.originalEvent = e;
    this.dispatchEvent(event);
  }
  _onDragLeave(e) {
    e.stopPropagation();
    this._clearDragStyles();
  }
  _onDragOver(e) {
    if (this.dropMode) {
      this._dropLocation = void 0;
      this._dragOverItem = void 0;
      if (this.__dndAutoScroll(e.clientY)) {
        this._clearDragStyles();
        return;
      }
      let row = e.composedPath().filter((node) => node.localName === "tr")[0];
      if (!this._effectiveSize || this.dropMode === DropMode.ON_GRID) {
        this._dropLocation = DropLocation.EMPTY;
      } else if (!row || row.parentNode !== this.$.items) {
        if (row) {
          return;
        } else if (this.dropMode === DropMode.BETWEEN || this.dropMode === DropMode.ON_TOP_OR_BETWEEN) {
          row = Array.from(this.$.items.children).filter((row2) => !row2.hidden).pop();
          this._dropLocation = DropLocation.BELOW;
        } else {
          return;
        }
      } else {
        const rowRect = row.getBoundingClientRect();
        this._dropLocation = DropLocation.ON_TOP;
        if (this.dropMode === DropMode.BETWEEN) {
          const dropAbove = e.clientY - rowRect.top < rowRect.bottom - e.clientY;
          this._dropLocation = dropAbove ? DropLocation.ABOVE : DropLocation.BELOW;
        } else if (this.dropMode === DropMode.ON_TOP_OR_BETWEEN) {
          if (e.clientY - rowRect.top < rowRect.height / 3) {
            this._dropLocation = DropLocation.ABOVE;
          } else if (e.clientY - rowRect.top > rowRect.height / 3 * 2) {
            this._dropLocation = DropLocation.BELOW;
          }
        }
      }
      if (row && row.hasAttribute("drop-disabled")) {
        this._dropLocation = void 0;
        return;
      }
      e.stopPropagation();
      e.preventDefault();
      if (this._dropLocation === DropLocation.EMPTY) {
        this.toggleAttribute("dragover", true);
      } else if (row) {
        this._dragOverItem = row._item;
        if (row.getAttribute("dragover") !== this._dropLocation) {
          row.setAttribute("dragover", this._dropLocation);
        }
      } else {
        this._clearDragStyles();
      }
    }
  }
  __dndAutoScroll(clientY) {
    if (this.__dndAutoScrolling) {
      return true;
    }
    const headerBottom = this.$.header.getBoundingClientRect().bottom;
    const footerTop = this.$.footer.getBoundingClientRect().top;
    const topDiff = headerBottom - clientY + this.__dndAutoScrollThreshold;
    const bottomDiff = clientY - footerTop + this.__dndAutoScrollThreshold;
    let scrollTopDelta = 0;
    if (bottomDiff > 0) {
      scrollTopDelta = bottomDiff * 2;
    } else if (topDiff > 0) {
      scrollTopDelta = -topDiff * 2;
    }
    if (scrollTopDelta) {
      const scrollTop = this.$.table.scrollTop;
      this.$.table.scrollTop += scrollTopDelta;
      const scrollTopChanged = scrollTop !== this.$.table.scrollTop;
      if (scrollTopChanged) {
        this.__dndAutoScrolling = true;
        setTimeout(() => {
          this.__dndAutoScrolling = false;
        }, 20);
        return true;
      }
    }
  }
  __getViewportRows() {
    const headerBottom = this.$.header.getBoundingClientRect().bottom;
    const footerTop = this.$.footer.getBoundingClientRect().top;
    return Array.from(this.$.items.children).filter((row) => {
      const rowRect = row.getBoundingClientRect();
      return rowRect.bottom > headerBottom && rowRect.top < footerTop;
    });
  }
  _clearDragStyles() {
    this.removeAttribute("dragover");
    Array.from(this.$.items.children).forEach((row) => row.removeAttribute("dragover"));
  }
  _onDrop(e) {
    if (this.dropMode) {
      e.stopPropagation();
      e.preventDefault();
      const dragData = e.dataTransfer.types && Array.from(e.dataTransfer.types).map((type) => {
        return {
          type,
          data: e.dataTransfer.getData(type)
        };
      });
      this._clearDragStyles();
      const event = new CustomEvent("grid-drop", {
        bubbles: e.bubbles,
        cancelable: e.cancelable,
        detail: {
          dropTargetItem: this._dragOverItem,
          dropLocation: this._dropLocation,
          dragData
        }
      });
      event.originalEvent = e;
      this.dispatchEvent(event);
    }
  }
  __formatDefaultTransferData(rows) {
    return rows.map((row) => {
      return Array.from(row.children).filter((cell) => !cell.hidden && cell.getAttribute("part").indexOf("details-cell") === -1).sort((a, b) => {
        return a._column._order > b._column._order ? 1 : -1;
      }).map((cell) => cell._content.textContent.trim()).filter((content) => content).join("	");
    }).join("\n");
  }
  _dragDropAccessChanged() {
    this.filterDragAndDrop();
  }
  filterDragAndDrop() {
    Array.from(this.$.items.children).filter((row) => !row.hidden).forEach((row) => {
      this._filterDragAndDrop(row, this.__getRowModel(row));
    });
  }
  _filterDragAndDrop(row, model) {
    const loading = this.loading || row.hasAttribute("loading");
    const dragDisabled = !this.rowsDraggable || loading || this.dragFilter && !this.dragFilter(model);
    const dropDisabled = !this.dropMode || loading || this.dropFilter && !this.dropFilter(model);
    const draggableElements = Array.from(row.children).map((cell) => cell._content);
    draggableElements.forEach((e) => {
      if (dragDisabled) {
        e.removeAttribute("draggable");
      } else {
        e.setAttribute("draggable", true);
      }
    });
    row.toggleAttribute("drag-disabled", !!dragDisabled);
    row.toggleAttribute("drop-disabled", !!dropDisabled);
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-dynamic-columns-mixin.js
function arrayEquals(arr1, arr2) {
  if (!arr1 || !arr2 || arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0, l = arr1.length; i < l; i++) {
    if (arr1[i] instanceof Array && arr2[i] instanceof Array) {
      if (!arrayEquals(arr1[i], arr2[i])) {
        return false;
      }
    } else if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
var DynamicColumnsMixin = (superClass) => class DynamicColumnsMixin extends superClass {
  static get properties() {
    return {
      _columnTree: Object
    };
  }
  ready() {
    super.ready();
    this._addNodeObserver();
  }
  _hasColumnGroups(columns) {
    for (let i = 0; i < columns.length; i++) {
      if (columns[i].localName === "vaadin-grid-column-group") {
        return true;
      }
    }
    return false;
  }
  _getChildColumns(el) {
    return FlattenedNodesObserver.getFlattenedNodes(el).filter(this._isColumnElement);
  }
  _flattenColumnGroups(columns) {
    return columns.map((col) => {
      if (col.localName === "vaadin-grid-column-group") {
        return this._getChildColumns(col);
      }
      return [col];
    }).reduce((prev, curr) => {
      return prev.concat(curr);
    }, []);
  }
  _getColumnTree() {
    const rootColumns = FlattenedNodesObserver.getFlattenedNodes(this).filter(this._isColumnElement);
    const columnTree = [rootColumns];
    let c = rootColumns;
    while (this._hasColumnGroups(c)) {
      c = this._flattenColumnGroups(c);
      columnTree.push(c);
    }
    return columnTree;
  }
  _updateColumnTree() {
    const columnTree = this._getColumnTree();
    if (!arrayEquals(columnTree, this._columnTree)) {
      this._columnTree = columnTree;
    }
  }
  _addNodeObserver() {
    this._observer = new FlattenedNodesObserver(this, (info) => {
      const hasColumnElements = (nodeCollection) => nodeCollection.filter(this._isColumnElement).length > 0;
      if (hasColumnElements(info.addedNodes) || hasColumnElements(info.removedNodes)) {
        const allRemovedCells = info.removedNodes.flatMap((c) => c._allCells);
        const filterNotConnected = (element) => allRemovedCells.filter((cell) => cell._content.contains(element)).length;
        this.__removeSorters(this._sorters.filter(filterNotConnected));
        this.__removeFilters(this._filters.filter(filterNotConnected));
        this._updateColumnTree();
      }
      this._debouncerCheckImports = Debouncer.debounce(
        this._debouncerCheckImports,
        timeOut.after(2e3),
        this._checkImports.bind(this)
      );
      this._ensureFirstPageLoaded();
    });
  }
  _checkImports() {
    [
      "vaadin-grid-column-group",
      "vaadin-grid-filter",
      "vaadin-grid-filter-column",
      "vaadin-grid-tree-toggle",
      "vaadin-grid-selection-column",
      "vaadin-grid-sort-column",
      "vaadin-grid-sorter"
    ].forEach((elementName) => {
      const element = this.querySelector(elementName);
      if (element && !(element instanceof PolymerElement)) {
        console.warn(`Make sure you have imported the required module for <${elementName}> element.`);
      }
    });
  }
  _updateFirstAndLastColumn() {
    Array.from(this.shadowRoot.querySelectorAll("tr")).forEach((row) => this._updateFirstAndLastColumnForRow(row));
  }
  _updateFirstAndLastColumnForRow(row) {
    Array.from(row.querySelectorAll('[part~="cell"]:not([part~="details-cell"])')).sort((a, b) => {
      return a._column._order - b._column._order;
    }).forEach((cell, cellIndex, children) => {
      cell.toggleAttribute("first-column", cellIndex === 0);
      cell.toggleAttribute("last-column", cellIndex === children.length - 1);
    });
  }
  _isColumnElement(node) {
    return node.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/.test(node.localName);
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-event-context-mixin.js
var EventContextMixin = (superClass) => class EventContextMixin extends superClass {
  getEventContext(event) {
    const context = {};
    const path = event.__composedPath || event.composedPath();
    const cell = path[path.indexOf(this.$.table) - 3];
    if (!cell) {
      return context;
    }
    context.section = ["body", "header", "footer", "details"].filter(
      (section) => cell.getAttribute("part").indexOf(section) > -1
    )[0];
    if (cell._column) {
      context.column = cell._column;
    }
    if (context.section === "body" || context.section === "details") {
      Object.assign(context, this.__getRowModel(cell.parentElement));
    }
    return context;
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-filter-mixin.js
var FilterMixin = (superClass) => class FilterMixin extends superClass {
  static get properties() {
    return {
      _filters: {
        type: Array,
        value: () => []
      }
    };
  }
  ready() {
    super.ready();
    this.addEventListener("filter-changed", this._filterChanged.bind(this));
  }
  _filterChanged(e) {
    e.stopPropagation();
    this.__addFilter(e.target);
    this.__applyFilters();
  }
  __removeFilters(filtersToRemove) {
    if (filtersToRemove.length === 0) {
      return;
    }
    this._filters = this._filters.filter((filter2) => filtersToRemove.indexOf(filter2) < 0);
    this.__applyFilters();
  }
  __addFilter(filter2) {
    const filterIndex = this._filters.indexOf(filter2);
    if (filterIndex === -1) {
      this._filters.push(filter2);
    }
  }
  __applyFilters() {
    if (this.dataProvider && this.isAttached) {
      this.clearCache();
    }
  }
  _mapFilters() {
    return this._filters.map((filter2) => {
      return {
        path: filter2.path,
        value: filter2.value
      };
    });
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-keyboard-navigation-mixin.js
var KeyboardNavigationMixin = (superClass) => class KeyboardNavigationMixin extends superClass {
  static get properties() {
    return {
      _headerFocusable: {
        type: Object,
        observer: "_focusableChanged"
      },
      _itemsFocusable: {
        type: Object,
        observer: "_focusableChanged"
      },
      _footerFocusable: {
        type: Object,
        observer: "_focusableChanged"
      },
      _navigatingIsHidden: Boolean,
      _focusedItemIndex: {
        type: Number,
        value: 0
      },
      _focusedColumnOrder: Number,
      interacting: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        readOnly: true,
        observer: "_interactingChanged"
      }
    };
  }
  ready() {
    super.ready();
    if (this._ios || this._android) {
      return;
    }
    this.addEventListener("keydown", this._onKeyDown);
    this.addEventListener("keyup", this._onKeyUp);
    this.addEventListener("focusin", this._onFocusIn);
    this.addEventListener("focusout", this._onFocusOut);
    this.$.table.addEventListener("focusin", this._onContentFocusIn.bind(this));
    this.addEventListener("mousedown", () => {
      this.toggleAttribute("navigating", false);
      this._isMousedown = true;
      this._focusedColumnOrder = void 0;
    });
    this.addEventListener("mouseup", () => {
      this._isMousedown = false;
    });
  }
  get __rowFocusMode() {
    return this.__isRow(this._itemsFocusable) || this.__isRow(this._headerFocusable) || this.__isRow(this._footerFocusable);
  }
  set __rowFocusMode(value) {
    ["_itemsFocusable", "_footerFocusable", "_headerFocusable"].forEach((focusable) => {
      if (value && this.__isCell(this[focusable])) {
        this[focusable] = this[focusable].parentElement;
      } else if (!value && this.__isRow(this[focusable])) {
        this[focusable] = this[focusable].firstElementChild;
      }
    });
  }
  _focusableChanged(focusable, oldFocusable) {
    if (oldFocusable) {
      oldFocusable.setAttribute("tabindex", "-1");
    }
    if (focusable) {
      this._updateGridSectionFocusTarget(focusable);
    }
  }
  _interactingChanged() {
    this._updateGridSectionFocusTarget(this._headerFocusable);
    this._updateGridSectionFocusTarget(this._itemsFocusable);
    this._updateGridSectionFocusTarget(this._footerFocusable);
  }
  __updateItemsFocusable() {
    if (!this._itemsFocusable) {
      return;
    }
    const wasFocused = this.shadowRoot.activeElement === this._itemsFocusable;
    this._getVisibleRows().forEach((row) => {
      if (row.index === this._focusedItemIndex) {
        if (this.__rowFocusMode) {
          this._itemsFocusable = row;
        } else if (this._itemsFocusable.parentElement) {
          const cellIndex = [...this._itemsFocusable.parentElement.children].indexOf(this._itemsFocusable);
          this._itemsFocusable = row.children[cellIndex];
        }
      }
    });
    if (wasFocused) {
      this._itemsFocusable.focus();
    }
  }
  _onKeyDown(e) {
    const key = e.key;
    let keyGroup;
    switch (key) {
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
      case "PageUp":
      case "PageDown":
      case "Home":
      case "End":
        keyGroup = "Navigation";
        break;
      case "Enter":
      case "Escape":
      case "F2":
        keyGroup = "Interaction";
        break;
      case "Tab":
        keyGroup = "Tab";
        break;
      case " ":
        keyGroup = "Space";
        break;
      default:
        break;
    }
    this._detectInteracting(e);
    if (this.interacting && keyGroup !== "Interaction") {
      keyGroup = void 0;
    }
    if (keyGroup) {
      this[`_on${keyGroup}KeyDown`](e, key);
    }
  }
  _ensureScrolledToIndex(index) {
    const targetRowInDom = [...this.$.items.children].find((child) => child.index === index);
    if (!targetRowInDom) {
      this.scrollToIndex(index);
    } else {
      this.__scrollIntoViewport(index);
    }
  }
  __isRowExpandable(row) {
    if (this.itemHasChildrenPath) {
      const item = row._item;
      return item && this.get(this.itemHasChildrenPath, item) && !this._isExpanded(item);
    }
  }
  __isRowCollapsible(row) {
    return this._isExpanded(row._item);
  }
  __isDetailsCell(element) {
    return element.matches('[part~="details-cell"]');
  }
  __isCell(element) {
    return element instanceof HTMLTableCellElement;
  }
  __isRow(element) {
    return element instanceof HTMLTableRowElement;
  }
  __getIndexOfChildElement(el) {
    return Array.prototype.indexOf.call(el.parentNode.children, el);
  }
  _onNavigationKeyDown(e, key) {
    e.preventDefault();
    const visibleItemsCount = this._lastVisibleIndex - this._firstVisibleIndex - 1;
    let dx = 0, dy = 0;
    switch (key) {
      case "ArrowRight":
        dx = this.__isRTL ? -1 : 1;
        break;
      case "ArrowLeft":
        dx = this.__isRTL ? 1 : -1;
        break;
      case "Home":
        if (this.__rowFocusMode) {
          dy = -Infinity;
        } else if (e.ctrlKey) {
          dy = -Infinity;
        } else {
          dx = -Infinity;
        }
        break;
      case "End":
        if (this.__rowFocusMode) {
          dy = Infinity;
        } else if (e.ctrlKey) {
          dy = Infinity;
        } else {
          dx = Infinity;
        }
        break;
      case "ArrowDown":
        dy = 1;
        break;
      case "ArrowUp":
        dy = -1;
        break;
      case "PageDown":
        dy = visibleItemsCount;
        break;
      case "PageUp":
        dy = -visibleItemsCount;
        break;
      default:
        break;
    }
    const activeRow = e.composedPath().find((el) => this.__isRow(el));
    const activeCell = e.composedPath().find((el) => this.__isCell(el));
    if (this.__rowFocusMode && !activeRow || !this.__rowFocusMode && !activeCell) {
      return;
    }
    const forwardsKey = this.__isRTL ? "ArrowLeft" : "ArrowRight";
    const backwardsKey = this.__isRTL ? "ArrowRight" : "ArrowLeft";
    if (key === forwardsKey) {
      if (this.__rowFocusMode) {
        if (this.__isRowExpandable(activeRow)) {
          this.expandItem(activeRow._item);
          return;
        }
        this.__rowFocusMode = false;
        this._onCellNavigation(activeRow.firstElementChild, 0, 0);
        return;
      }
    } else if (key === backwardsKey) {
      if (this.__rowFocusMode) {
        if (this.__isRowCollapsible(activeRow)) {
          this.collapseItem(activeRow._item);
          return;
        }
      } else {
        const activeRowCells = [...activeRow.children].sort((a, b) => a._order - b._order);
        if (activeCell === activeRowCells[0] || this.__isDetailsCell(activeCell)) {
          this.__rowFocusMode = true;
          this._onRowNavigation(activeRow, 0);
          return;
        }
      }
    }
    if (this.__rowFocusMode) {
      this._onRowNavigation(activeRow, dy);
    } else {
      this._onCellNavigation(activeCell, dx, dy);
    }
  }
  _onRowNavigation(activeRow, dy) {
    const { dstRow } = this.__navigateRows(dy, activeRow);
    if (dstRow) {
      dstRow.focus();
    }
  }
  __getIndexInGroup(row, bodyFallbackIndex) {
    const rowGroup = row.parentNode;
    if (rowGroup === this.$.items) {
      return bodyFallbackIndex !== void 0 ? bodyFallbackIndex : row.index;
    }
    return this.__getIndexOfChildElement(row);
  }
  __navigateRows(dy, activeRow, activeCell) {
    const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);
    const activeRowGroup = activeRow.parentNode;
    const maxRowIndex = (activeRowGroup === this.$.items ? this._effectiveSize : activeRowGroup.children.length) - 1;
    let dstRowIndex = Math.max(0, Math.min(currentRowIndex + dy, maxRowIndex));
    if (activeRowGroup !== this.$.items) {
      if (dstRowIndex > currentRowIndex) {
        while (dstRowIndex < maxRowIndex && activeRowGroup.children[dstRowIndex].hidden) {
          dstRowIndex += 1;
        }
      } else if (dstRowIndex < currentRowIndex) {
        while (dstRowIndex > 0 && activeRowGroup.children[dstRowIndex].hidden) {
          dstRowIndex -= 1;
        }
      }
      this.toggleAttribute("navigating", true);
      return { dstRow: activeRowGroup.children[dstRowIndex] };
    }
    let dstIsRowDetails = false;
    if (activeCell) {
      const isRowDetails = this.__isDetailsCell(activeCell);
      if (activeRowGroup === this.$.items) {
        const item = activeRow._item;
        const dstItem = this._cache.getItemForIndex(dstRowIndex);
        if (isRowDetails) {
          dstIsRowDetails = dy === 0;
        } else {
          dstIsRowDetails = dy === 1 && this._isDetailsOpened(item) || dy === -1 && dstRowIndex !== currentRowIndex && this._isDetailsOpened(dstItem);
        }
        if (dstIsRowDetails !== isRowDetails && (dy === 1 && dstIsRowDetails || dy === -1 && !dstIsRowDetails)) {
          dstRowIndex = currentRowIndex;
        }
      }
    }
    this._ensureScrolledToIndex(dstRowIndex);
    this._focusedItemIndex = dstRowIndex;
    this.toggleAttribute("navigating", true);
    return {
      dstRow: [...activeRowGroup.children].find((el) => !el.hidden && el.index === dstRowIndex),
      dstIsRowDetails
    };
  }
  _onCellNavigation(activeCell, dx, dy) {
    const activeRow = activeCell.parentNode;
    const { dstRow, dstIsRowDetails } = this.__navigateRows(dy, activeRow, activeCell);
    if (!dstRow) {
      return;
    }
    const columnIndex = this.__getIndexOfChildElement(activeCell);
    const isCurrentCellRowDetails = this.__isDetailsCell(activeCell);
    const activeRowGroup = activeRow.parentNode;
    const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);
    if (this._focusedColumnOrder === void 0) {
      if (isCurrentCellRowDetails) {
        this._focusedColumnOrder = 0;
      } else {
        this._focusedColumnOrder = this._getColumns(activeRowGroup, currentRowIndex).filter((c) => !c.hidden)[columnIndex]._order;
      }
    }
    if (dstIsRowDetails) {
      const dstCell = [...dstRow.children].find((el) => this.__isDetailsCell(el));
      dstCell.focus();
    } else {
      const dstRowIndex = this.__getIndexInGroup(dstRow, this._focusedItemIndex);
      const dstColumns = this._getColumns(activeRowGroup, dstRowIndex).filter((c) => !c.hidden);
      const dstSortedColumnOrders = dstColumns.map((c) => c._order).sort((b, a) => b - a);
      const maxOrderedColumnIndex = dstSortedColumnOrders.length - 1;
      const orderedColumnIndex = dstSortedColumnOrders.indexOf(
        dstSortedColumnOrders.slice(0).sort((b, a) => Math.abs(b - this._focusedColumnOrder) - Math.abs(a - this._focusedColumnOrder))[0]
      );
      const dstOrderedColumnIndex = dy === 0 && isCurrentCellRowDetails ? orderedColumnIndex : Math.max(0, Math.min(orderedColumnIndex + dx, maxOrderedColumnIndex));
      if (dstOrderedColumnIndex !== orderedColumnIndex) {
        this._focusedColumnOrder = void 0;
      }
      const columnIndexByOrder = dstColumns.reduce((acc, col, i) => {
        acc[col._order] = i;
        return acc;
      }, {});
      const dstColumnIndex = columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]];
      const dstCell = dstRow.children[dstColumnIndex];
      this._scrollHorizontallyToCell(dstCell);
      dstCell.focus();
    }
  }
  _onInteractionKeyDown(e, key) {
    const localTarget = e.composedPath()[0];
    const localTargetIsTextInput = localTarget.localName === "input" && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/i.test(localTarget.type);
    let wantInteracting;
    switch (key) {
      case "Enter":
        wantInteracting = this.interacting ? !localTargetIsTextInput : true;
        break;
      case "Escape":
        wantInteracting = false;
        break;
      case "F2":
        wantInteracting = !this.interacting;
        break;
      default:
        break;
    }
    const { cell } = this._getGridEventLocation(e);
    if (this.interacting !== wantInteracting && cell !== null) {
      if (wantInteracting) {
        const focusTarget = cell._content.querySelector("[focus-target]") || [...cell._content.querySelectorAll("*")].find((node) => this._isFocusable(node));
        if (focusTarget) {
          e.preventDefault();
          focusTarget.focus();
          this._setInteracting(true);
          this.toggleAttribute("navigating", false);
        }
      } else {
        e.preventDefault();
        this._focusedColumnOrder = void 0;
        cell.focus();
        this._setInteracting(false);
        this.toggleAttribute("navigating", true);
      }
    }
  }
  _predictFocusStepTarget(srcElement, step) {
    const tabOrder = [
      this.$.table,
      this._headerFocusable,
      this._itemsFocusable,
      this._footerFocusable,
      this.$.focusexit
    ];
    let index = tabOrder.indexOf(srcElement);
    index += step;
    while (index >= 0 && index <= tabOrder.length - 1) {
      let rowElement = tabOrder[index];
      if (rowElement && !this.__rowFocusMode) {
        rowElement = tabOrder[index].parentNode;
      }
      if (!rowElement || rowElement.hidden) {
        index += step;
      } else {
        break;
      }
    }
    return tabOrder[index];
  }
  _onTabKeyDown(e) {
    const focusTarget = this._predictFocusStepTarget(e.composedPath()[0], e.shiftKey ? -1 : 1);
    if (!focusTarget) {
      return;
    }
    e.stopPropagation();
    if (focusTarget === this.$.table) {
      this.$.table.focus();
    } else if (focusTarget === this.$.focusexit) {
      this.$.focusexit.focus();
    } else if (focusTarget === this._itemsFocusable) {
      let itemsFocusTarget = focusTarget;
      const targetRow = this.__isRow(focusTarget) ? focusTarget : focusTarget.parentNode;
      this._ensureScrolledToIndex(this._focusedItemIndex);
      if (targetRow.index !== this._focusedItemIndex && this.__isCell(focusTarget)) {
        const columnIndex = Array.from(targetRow.children).indexOf(this._itemsFocusable);
        const focusedItemRow = Array.from(this.$.items.children).find(
          (row) => !row.hidden && row.index === this._focusedItemIndex
        );
        if (focusedItemRow) {
          itemsFocusTarget = focusedItemRow.children[columnIndex];
        }
      }
      e.preventDefault();
      itemsFocusTarget.focus();
    } else {
      e.preventDefault();
      focusTarget.focus();
    }
    this.toggleAttribute("navigating", true);
  }
  _onSpaceKeyDown(e) {
    e.preventDefault();
    const element = e.composedPath()[0];
    const isRow = this.__isRow(element);
    if (isRow || !element._content || !element._content.firstElementChild) {
      this.dispatchEvent(
        new CustomEvent(isRow ? "row-activate" : "cell-activate", {
          detail: {
            model: this.__getRowModel(isRow ? element : element.parentElement)
          }
        })
      );
    }
  }
  _onKeyUp(e) {
    if (!/^( |SpaceBar)$/.test(e.key) || this.interacting) {
      return;
    }
    e.preventDefault();
    const cell = e.composedPath()[0];
    if (cell._content && cell._content.firstElementChild) {
      const wasNavigating = this.hasAttribute("navigating");
      cell._content.firstElementChild.click();
      this.toggleAttribute("navigating", wasNavigating);
    }
  }
  _onFocusIn(e) {
    if (!this._isMousedown) {
      this.toggleAttribute("navigating", true);
    }
    const rootTarget = e.composedPath()[0];
    if (rootTarget === this.$.table || rootTarget === this.$.focusexit) {
      this._predictFocusStepTarget(rootTarget, rootTarget === this.$.table ? 1 : -1).focus();
      this._setInteracting(false);
    } else {
      this._detectInteracting(e);
    }
  }
  _onFocusOut(e) {
    this.toggleAttribute("navigating", false);
    this._detectInteracting(e);
  }
  _onContentFocusIn(e) {
    const { section, cell, row } = this._getGridEventLocation(e);
    if (!cell && !this.__rowFocusMode) {
      return;
    }
    this._detectInteracting(e);
    if (section && (cell || row)) {
      this._activeRowGroup = section;
      if (this.$.header === section) {
        this._headerFocusable = this.__rowFocusMode ? row : cell;
      } else if (this.$.items === section) {
        this._itemsFocusable = this.__rowFocusMode ? row : cell;
      } else if (this.$.footer === section) {
        this._footerFocusable = this.__rowFocusMode ? row : cell;
      }
      if (cell) {
        const context = this.getEventContext(e);
        cell.dispatchEvent(new CustomEvent("cell-focus", { bubbles: true, composed: true, detail: { context } }));
      }
    }
    this._detectFocusedItemIndex(e);
  }
  _detectInteracting(e) {
    const isInteracting = e.composedPath().some((el) => el.localName === "vaadin-grid-cell-content");
    this._setInteracting(isInteracting);
    this.__updateHorizontalScrollPosition();
  }
  _detectFocusedItemIndex(e) {
    const { section, row } = this._getGridEventLocation(e);
    if (section === this.$.items) {
      this._focusedItemIndex = row.index;
    }
  }
  _updateGridSectionFocusTarget(focusTarget) {
    if (!focusTarget) {
      return;
    }
    const section = this._getGridSectionFromFocusTarget(focusTarget);
    const isInteractingWithinActiveSection = this.interacting && section === this._activeRowGroup;
    focusTarget.tabIndex = isInteractingWithinActiveSection ? -1 : 0;
  }
  _preventScrollerRotatingCellFocus(row, index) {
    if (row.index === this._focusedItemIndex && this.hasAttribute("navigating") && this._activeRowGroup === this.$.items) {
      this._navigatingIsHidden = true;
      this.toggleAttribute("navigating", false);
    }
    if (index === this._focusedItemIndex && this._navigatingIsHidden) {
      this._navigatingIsHidden = false;
      this.toggleAttribute("navigating", true);
    }
  }
  _getColumns(rowGroup, rowIndex) {
    let columnTreeLevel = this._columnTree.length - 1;
    if (rowGroup === this.$.header) {
      columnTreeLevel = rowIndex;
    } else if (rowGroup === this.$.footer) {
      columnTreeLevel = this._columnTree.length - 1 - rowIndex;
    }
    return this._columnTree[columnTreeLevel];
  }
  __isValidFocusable(element) {
    return this.$.table.contains(element) && element.offsetHeight;
  }
  _resetKeyboardNavigation() {
    ["header", "footer"].forEach((section) => {
      if (!this.__isValidFocusable(this[`_${section}Focusable`])) {
        const firstVisibleRow = [...this.$[section].children].find((row) => row.offsetHeight);
        const firstVisibleCell = firstVisibleRow ? [...firstVisibleRow.children].find((cell) => !cell.hidden) : null;
        if (firstVisibleRow && firstVisibleCell) {
          this[`_${section}Focusable`] = this.__rowFocusMode ? firstVisibleRow : firstVisibleCell;
        }
      }
    });
    if (!this.__isValidFocusable(this._itemsFocusable) && this.$.items.firstElementChild) {
      const firstVisibleRow = this.__getFirstVisibleItem();
      const firstVisibleCell = firstVisibleRow ? [...firstVisibleRow.children].find((cell) => !cell.hidden) : null;
      if (firstVisibleCell && firstVisibleRow) {
        delete this._focusedColumnOrder;
        this._itemsFocusable = this.__rowFocusMode ? firstVisibleRow : firstVisibleCell;
      }
    } else {
      this.__updateItemsFocusable();
    }
  }
  _scrollHorizontallyToCell(dstCell) {
    if (dstCell.hasAttribute("frozen") || dstCell.hasAttribute("frozen-to-end") || this.__isDetailsCell(dstCell)) {
      return;
    }
    const dstCellRect = dstCell.getBoundingClientRect();
    const dstRow = dstCell.parentNode;
    const dstCellIndex = Array.from(dstRow.children).indexOf(dstCell);
    const tableRect = this.$.table.getBoundingClientRect();
    let leftBoundary = tableRect.left, rightBoundary = tableRect.right;
    for (let i = dstCellIndex - 1; i >= 0; i--) {
      const cell = dstRow.children[i];
      if (cell.hasAttribute("hidden") || this.__isDetailsCell(cell)) {
        continue;
      }
      if (cell.hasAttribute("frozen") || cell.hasAttribute("frozen-to-end")) {
        leftBoundary = cell.getBoundingClientRect().right;
        break;
      }
    }
    for (let i = dstCellIndex + 1; i < dstRow.children.length; i++) {
      const cell = dstRow.children[i];
      if (cell.hasAttribute("hidden") || this.__isDetailsCell(cell)) {
        continue;
      }
      if (cell.hasAttribute("frozen") || cell.hasAttribute("frozen-to-end")) {
        rightBoundary = cell.getBoundingClientRect().left;
        break;
      }
    }
    if (dstCellRect.left < leftBoundary) {
      this.$.table.scrollLeft += Math.round(dstCellRect.left - leftBoundary);
    }
    if (dstCellRect.right > rightBoundary) {
      this.$.table.scrollLeft += Math.round(dstCellRect.right - rightBoundary);
    }
  }
  _getGridEventLocation(e) {
    const path = e.composedPath();
    const tableIndex = path.indexOf(this.$.table);
    const section = tableIndex >= 1 ? path[tableIndex - 1] : null;
    const row = tableIndex >= 2 ? path[tableIndex - 2] : null;
    const cell = tableIndex >= 3 ? path[tableIndex - 3] : null;
    return {
      section,
      row,
      cell
    };
  }
  _getGridSectionFromFocusTarget(focusTarget) {
    if (focusTarget === this._headerFocusable) {
      return this.$.header;
    }
    if (focusTarget === this._itemsFocusable) {
      return this.$.items;
    }
    if (focusTarget === this._footerFocusable) {
      return this.$.footer;
    }
    return null;
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-row-details-mixin.js
var RowDetailsMixin = (superClass) => class RowDetailsMixin extends superClass {
  static get properties() {
    return {
      detailsOpenedItems: {
        type: Array,
        value: () => []
      },
      rowDetailsRenderer: Function,
      _detailsCells: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "_detailsOpenedItemsChanged(detailsOpenedItems.*, rowDetailsRenderer)",
      "_rowDetailsRendererChanged(rowDetailsRenderer)"
    ];
  }
  ready() {
    super.ready();
    this._detailsCellResizeObserver = new ResizeObserver((entries) => {
      entries.forEach(({ target: cell }) => {
        this._updateDetailsCellHeight(cell.parentElement);
      });
      this.__virtualizer.__adapter._resizeHandler();
    });
  }
  _rowDetailsRendererChanged(rowDetailsRenderer) {
    if (!rowDetailsRenderer) {
      return;
    }
    if (this._columnTree) {
      Array.from(this.$.items.children).forEach((row) => {
        if (!row.querySelector("[part~=details-cell]")) {
          this._updateRow(row, this._columnTree[this._columnTree.length - 1]);
          const isDetailsOpened = this._isDetailsOpened(row._item);
          this._toggleDetailsCell(row, isDetailsOpened);
        }
      });
    }
  }
  _detailsOpenedItemsChanged(changeRecord, rowDetailsRenderer) {
    if (changeRecord.path === "detailsOpenedItems.length" || !changeRecord.value) {
      return;
    }
    [...this.$.items.children].forEach((row) => {
      if (row.hasAttribute("details-opened")) {
        this._updateItem(row, row._item);
        return;
      }
      if (rowDetailsRenderer && this._isDetailsOpened(row._item)) {
        this._updateItem(row, row._item);
      }
    });
  }
  _configureDetailsCell(cell) {
    cell.setAttribute("part", "cell details-cell");
    cell.toggleAttribute("frozen", true);
    this._detailsCellResizeObserver.observe(cell);
  }
  _toggleDetailsCell(row, detailsOpened) {
    const cell = row.querySelector('[part~="details-cell"]');
    if (!cell) {
      return;
    }
    cell.hidden = !detailsOpened;
    if (cell.hidden) {
      return;
    }
    if (this.rowDetailsRenderer) {
      cell._renderer = this.rowDetailsRenderer;
    }
  }
  _updateDetailsCellHeight(row) {
    const cell = row.querySelector('[part~="details-cell"]');
    if (!cell) {
      return;
    }
    if (cell.hidden) {
      row.style.removeProperty("padding-bottom");
    } else {
      row.style.setProperty("padding-bottom", `${cell.offsetHeight}px`);
    }
  }
  _updateDetailsCellHeights() {
    [...this.$.items.children].forEach((row) => {
      this._updateDetailsCellHeight(row);
    });
  }
  _isDetailsOpened(item) {
    return this.detailsOpenedItems && this._getItemIndexInArray(item, this.detailsOpenedItems) !== -1;
  }
  openItemDetails(item) {
    if (!this._isDetailsOpened(item)) {
      this.detailsOpenedItems = [...this.detailsOpenedItems, item];
    }
  }
  closeItemDetails(item) {
    if (this._isDetailsOpened(item)) {
      this.detailsOpenedItems = this.detailsOpenedItems.filter((i) => !this._itemsEqual(i, item));
    }
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-scroll-mixin.js
var timeouts = {
  SCROLLING: 500
};
var ScrollMixin = (superClass) => class ScrollMixin extends ResizeMixin(superClass) {
  static get properties() {
    return {
      _frozenCells: {
        type: Array,
        value: () => []
      },
      _frozenToEndCells: {
        type: Array,
        value: () => []
      },
      _rowWithFocusedElement: Element
    };
  }
  get _scrollTop() {
    return this.$.table.scrollTop;
  }
  set _scrollTop(top) {
    this.$.table.scrollTop = top;
  }
  get _scrollLeft() {
    return this.$.table.scrollLeft;
  }
  ready() {
    super.ready();
    this.scrollTarget = this.$.table;
    this.$.items.addEventListener("focusin", (e) => {
      const itemsIndex = e.composedPath().indexOf(this.$.items);
      this._rowWithFocusedElement = e.composedPath()[itemsIndex - 1];
    });
    this.$.items.addEventListener("focusout", () => {
      this._rowWithFocusedElement = void 0;
    });
    this.$.table.addEventListener("scroll", () => this._afterScroll());
  }
  _onResize() {
    this._updateOverflow();
    this.__updateHorizontalScrollPosition();
  }
  scrollToIndex(index) {
    index = Math.min(this._effectiveSize - 1, Math.max(0, index));
    this.__virtualizer.scrollToIndex(index);
    this.__scrollIntoViewport(index);
  }
  __scrollIntoViewport(index) {
    const rowElement = [...this.$.items.children].find((child) => child.index === index);
    if (rowElement) {
      const dstRect = rowElement.getBoundingClientRect();
      const footerTop = this.$.footer.getBoundingClientRect().top;
      const headerBottom = this.$.header.getBoundingClientRect().bottom;
      if (dstRect.bottom > footerTop) {
        this.$.table.scrollTop += dstRect.bottom - footerTop;
      } else if (dstRect.top < headerBottom) {
        this.$.table.scrollTop -= headerBottom - dstRect.top;
      }
    }
  }
  _scheduleScrolling() {
    if (!this._scrollingFrame) {
      this._scrollingFrame = requestAnimationFrame(() => this.$.scroller.toggleAttribute("scrolling", true));
    }
    this._debounceScrolling = Debouncer.debounce(this._debounceScrolling, timeOut.after(timeouts.SCROLLING), () => {
      cancelAnimationFrame(this._scrollingFrame);
      delete this._scrollingFrame;
      this.$.scroller.toggleAttribute("scrolling", false);
    });
  }
  _afterScroll() {
    this.__updateHorizontalScrollPosition();
    if (!this.hasAttribute("reordering")) {
      this._scheduleScrolling();
    }
    this._updateOverflow();
  }
  _updateOverflow() {
    let overflow = "";
    const table = this.$.table;
    if (table.scrollTop < table.scrollHeight - table.clientHeight) {
      overflow += " bottom";
    }
    if (table.scrollTop > 0) {
      overflow += " top";
    }
    const scrollLeft = this.__getNormalizedScrollLeft(table);
    if (scrollLeft > 0) {
      overflow += " start";
    }
    if (scrollLeft < table.scrollWidth - table.clientWidth) {
      overflow += " end";
    }
    if (this.__isRTL) {
      overflow = overflow.replace(/start|end/gi, (matched) => {
        return matched === "start" ? "end" : "start";
      });
    }
    if (table.scrollLeft < table.scrollWidth - table.clientWidth) {
      overflow += " right";
    }
    if (table.scrollLeft > 0) {
      overflow += " left";
    }
    this._debounceOverflow = Debouncer.debounce(this._debounceOverflow, animationFrame, () => {
      const value = overflow.trim();
      if (value.length > 0 && this.getAttribute("overflow") !== value) {
        this.setAttribute("overflow", value);
      } else if (value.length === 0 && this.hasAttribute("overflow")) {
        this.removeAttribute("overflow");
      }
    });
  }
  _frozenCellsChanged() {
    this._debouncerCacheElements = Debouncer.debounce(this._debouncerCacheElements, microTask, () => {
      Array.from(this.shadowRoot.querySelectorAll('[part~="cell"]')).forEach((cell) => {
        cell.style.transform = "";
      });
      this._frozenCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen]"));
      this._frozenToEndCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen-to-end]"));
      this.__updateHorizontalScrollPosition();
    });
    this._updateFrozenColumn();
  }
  _updateFrozenColumn() {
    if (!this._columnTree) {
      return;
    }
    const columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);
    columnsRow.sort((a, b) => {
      return a._order - b._order;
    });
    let lastFrozen;
    let firstFrozenToEnd;
    for (let i = 0; i < columnsRow.length; i++) {
      const col = columnsRow[i];
      col._lastFrozen = false;
      col._firstFrozenToEnd = false;
      if (firstFrozenToEnd === void 0 && col.frozenToEnd && !col.hidden) {
        firstFrozenToEnd = i;
      }
      if (col.frozen && !col.hidden) {
        lastFrozen = i;
      }
    }
    if (lastFrozen !== void 0) {
      columnsRow[lastFrozen]._lastFrozen = true;
    }
    if (firstFrozenToEnd !== void 0) {
      columnsRow[firstFrozenToEnd]._firstFrozenToEnd = true;
    }
  }
  __updateHorizontalScrollPosition() {
    const scrollWidth = this.$.table.scrollWidth;
    const clientWidth = this.$.table.clientWidth;
    const scrollLeft = Math.max(0, this.$.table.scrollLeft);
    const normalizedScrollLeft = this.__getNormalizedScrollLeft(this.$.table);
    const transform = `translate(${-scrollLeft}px, 0)`;
    this.$.header.style.transform = transform;
    this.$.footer.style.transform = transform;
    this.$.items.style.transform = transform;
    const x = this.__isRTL ? normalizedScrollLeft + clientWidth - scrollWidth : scrollLeft;
    const transformFrozen = `translate(${x}px, 0)`;
    for (let i = 0; i < this._frozenCells.length; i++) {
      this._frozenCells[i].style.transform = transformFrozen;
    }
    const remaining = this.__isRTL ? normalizedScrollLeft : scrollLeft + clientWidth - scrollWidth;
    const transformFrozenToEnd = `translate(${remaining}px, 0)`;
    for (let i = 0; i < this._frozenToEndCells.length; i++) {
      this._frozenToEndCells[i].style.transform = transformFrozenToEnd;
    }
    if (this.hasAttribute("navigating") && this.__rowFocusMode) {
      this.$.table.style.setProperty("--_grid-horizontal-scroll-position", `${-x}px`);
    }
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-selection-mixin.js
var SelectionMixin = (superClass) => class SelectionMixin extends superClass {
  static get properties() {
    return {
      selectedItems: {
        type: Object,
        notify: true,
        value: () => []
      },
      __selectedKeys: {
        type: Object,
        computed: "__computeSelectedKeys(itemIdPath, selectedItems.*)"
      }
    };
  }
  static get observers() {
    return ["__selectedItemsChanged(itemIdPath, selectedItems.*)"];
  }
  _isSelected(item) {
    return this.__selectedKeys.has(this.getItemId(item));
  }
  selectItem(item) {
    if (!this._isSelected(item)) {
      this.selectedItems = [...this.selectedItems, item];
    }
  }
  deselectItem(item) {
    if (this._isSelected(item)) {
      this.selectedItems = this.selectedItems.filter((i) => !this._itemsEqual(i, item));
    }
  }
  _toggleItem(item) {
    if (!this._isSelected(item)) {
      this.selectItem(item);
    } else {
      this.deselectItem(item);
    }
  }
  __selectedItemsChanged() {
    this.requestContentUpdate();
  }
  __computeSelectedKeys(itemIdPath, selectedItems) {
    const selected = selectedItems.base || [];
    const selectedKeys = /* @__PURE__ */ new Set();
    selected.forEach((item) => {
      selectedKeys.add(this.getItemId(item));
    });
    return selectedKeys;
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-sort-mixin.js
var defaultMultiSortPriority = "prepend";
var SortMixin = (superClass) => class SortMixin extends superClass {
  static get properties() {
    return {
      multiSort: {
        type: Boolean,
        value: false
      },
      multiSortPriority: {
        type: String,
        value: () => defaultMultiSortPriority
      },
      _sorters: {
        type: Array,
        value: () => []
      },
      _previousSorters: {
        type: Array,
        value: () => []
      }
    };
  }
  static setDefaultMultiSortPriority(priority) {
    defaultMultiSortPriority = ["append", "prepend"].includes(priority) ? priority : "prepend";
  }
  ready() {
    super.ready();
    this.addEventListener("sorter-changed", this._onSorterChanged);
  }
  _onSorterChanged(e) {
    const sorter = e.target;
    e.stopPropagation();
    sorter._grid = this;
    this.__updateSorter(sorter);
    this.__applySorters();
  }
  __removeSorters(sortersToRemove) {
    if (sortersToRemove.length === 0) {
      return;
    }
    this._sorters = this._sorters.filter((sorter) => sortersToRemove.indexOf(sorter) < 0);
    if (this.multiSort) {
      this.__updateSortOrders();
    }
    this.__applySorters();
  }
  __updateSortOrders() {
    this._sorters.forEach((sorter, index) => {
      sorter._order = this._sorters.length > 1 ? index : null;
    });
  }
  __appendSorter(sorter) {
    if (!sorter.direction) {
      this._removeArrayItem(this._sorters, sorter);
    } else if (!this._sorters.includes(sorter)) {
      this._sorters.push(sorter);
    }
    this.__updateSortOrders();
  }
  __prependSorter(sorter) {
    this._removeArrayItem(this._sorters, sorter);
    if (sorter.direction) {
      this._sorters.unshift(sorter);
    }
    this.__updateSortOrders();
  }
  __updateSorter(sorter) {
    if (!sorter.direction && this._sorters.indexOf(sorter) === -1) {
      return;
    }
    sorter._order = null;
    if (this.multiSort) {
      if (this.multiSortPriority === "append") {
        this.__appendSorter(sorter);
      } else {
        this.__prependSorter(sorter);
      }
    } else if (sorter.direction) {
      const otherSorters = this._sorters.filter((s) => s !== sorter);
      this._sorters = [sorter];
      otherSorters.forEach((sorter2) => {
        sorter2._order = null;
        sorter2.direction = null;
      });
    }
  }
  __applySorters() {
    if (this.dataProvider && this.isAttached && JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters())) {
      this.clearCache();
    }
    this._a11yUpdateSorters();
    this._previousSorters = this._mapSorters();
  }
  _mapSorters() {
    return this._sorters.map((sorter) => {
      return {
        path: sorter.path,
        direction: sorter.direction
      };
    });
  }
  _removeArrayItem(array, item) {
    const index = array.indexOf(item);
    if (index > -1) {
      array.splice(index, 1);
    }
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-styling-mixin.js
var StylingMixin = (superClass) => class StylingMixin extends superClass {
  static get properties() {
    return {
      cellClassNameGenerator: Function
    };
  }
  static get observers() {
    return ["__cellClassNameGeneratorChanged(cellClassNameGenerator)"];
  }
  __cellClassNameGeneratorChanged() {
    this.generateCellClassNames();
  }
  generateCellClassNames() {
    Array.from(this.$.items.children).filter((row) => !row.hidden && !row.hasAttribute("loading")).forEach((row) => this._generateCellClassNames(row, this.__getRowModel(row)));
  }
  _generateCellClassNames(row, model) {
    Array.from(row.children).forEach((cell) => {
      if (cell.__generatedClasses) {
        cell.__generatedClasses.forEach((className) => cell.classList.remove(className));
      }
      if (this.cellClassNameGenerator) {
        const result = this.cellClassNameGenerator(cell._column, model);
        cell.__generatedClasses = result && result.split(" ").filter((className) => className.length > 0);
        if (cell.__generatedClasses) {
          cell.__generatedClasses.forEach((className) => cell.classList.add(className));
        }
      }
    });
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid.js
var Grid = class extends ElementMixin(
  ThemableMixin(
    DataProviderMixin(
      ArrayDataProviderMixin(
        DynamicColumnsMixin(
          ActiveItemMixin(
            ScrollMixin(
              SelectionMixin(
                SortMixin(
                  RowDetailsMixin(
                    KeyboardNavigationMixin(
                      A11yMixin(
                        FilterMixin(
                          ColumnReorderingMixin(
                            ColumnResizingMixin(
                              EventContextMixin(DragAndDropMixin(StylingMixin(TabindexMixin(PolymerElement))))
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
  static get template() {
    return html`
      <div
        id="scroller"
        safari$="[[_safari]]"
        ios$="[[_ios]]"
        loading$="[[loading]]"
        column-reordering-allowed$="[[columnReorderingAllowed]]"
      >
        <table id="table" role="treegrid" aria-multiselectable="true" tabindex="0">
          <caption id="sizer" part="row"></caption>
          <thead id="header" role="rowgroup"></thead>
          <tbody id="items" role="rowgroup"></tbody>
          <tfoot id="footer" role="rowgroup"></tfoot>
        </table>

        <div part="reorder-ghost"></div>
      </div>

      <div id="focusexit" tabindex="0"></div>
    `;
  }
  static get is() {
    return "vaadin-grid";
  }
  static get observers() {
    return [
      "_columnTreeChanged(_columnTree, _columnTree.*)",
      "_effectiveSizeChanged(_effectiveSize, __virtualizer, _hasData, _columnTree)"
    ];
  }
  static get properties() {
    return {
      _safari: {
        type: Boolean,
        value: isSafari
      },
      _ios: {
        type: Boolean,
        value: isIOS
      },
      _firefox: {
        type: Boolean,
        value: isFirefox
      },
      _android: {
        type: Boolean,
        value: isAndroid
      },
      _touchDevice: {
        type: Boolean,
        value: isTouch
      },
      allRowsVisible: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      _recalculateColumnWidthOnceLoadingFinished: {
        type: Boolean,
        value: true
      },
      isAttached: {
        value: false
      },
      __gridElement: {
        type: Boolean,
        value: true
      }
    };
  }
  constructor() {
    super();
    this.addEventListener("animationend", this._onAnimationEnd);
  }
  connectedCallback() {
    super.connectedCallback();
    this.isAttached = true;
    this.recalculateColumnWidths();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.isAttached = false;
  }
  __getFirstVisibleItem() {
    return this._getVisibleRows().find((row) => this._isInViewport(row));
  }
  get _firstVisibleIndex() {
    const firstVisibleItem = this.__getFirstVisibleItem();
    return firstVisibleItem ? firstVisibleItem.index : void 0;
  }
  __getLastVisibleItem() {
    return this._getVisibleRows().reverse().find((row) => this._isInViewport(row));
  }
  get _lastVisibleIndex() {
    const lastVisibleItem = this.__getLastVisibleItem();
    return lastVisibleItem ? lastVisibleItem.index : void 0;
  }
  _isInViewport(item) {
    const scrollTargetRect = this.$.table.getBoundingClientRect();
    const itemRect = item.getBoundingClientRect();
    const headerHeight = this.$.header.getBoundingClientRect().height;
    const footerHeight = this.$.footer.getBoundingClientRect().height;
    return itemRect.bottom > scrollTargetRect.top + headerHeight && itemRect.top < scrollTargetRect.bottom - footerHeight;
  }
  _getVisibleRows() {
    return Array.from(this.$.items.children).filter((item) => !item.hidden).sort((a, b) => a.index - b.index);
  }
  ready() {
    super.ready();
    this.__virtualizer = new Virtualizer({
      createElements: this._createScrollerRows.bind(this),
      updateElement: this._updateScrollerItem.bind(this),
      scrollContainer: this.$.items,
      scrollTarget: this.$.table,
      reorderElements: true
    });
    new ResizeObserver(() => setTimeout(() => this.__updateFooterPositioning())).observe(this.$.footer);
    processTemplates(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name === "dir") {
      this.__isRTL = newValue === "rtl";
    }
  }
  __getBodyCellCoordinates(cell) {
    if (this.$.items.contains(cell) && cell.localName === "td") {
      return {
        item: cell.parentElement._item,
        column: cell._column
      };
    }
  }
  __focusBodyCell({ item, column }) {
    const row = this._getVisibleRows().find((row2) => row2._item === item);
    const cell = row && [...row.children].find((cell2) => cell2._column === column);
    if (cell) {
      cell.focus();
    }
  }
  _effectiveSizeChanged(effectiveSize, virtualizer, hasData, columnTree) {
    if (virtualizer && hasData && columnTree) {
      const cell = this.shadowRoot.activeElement;
      const cellCoordinates = this.__getBodyCellCoordinates(cell);
      virtualizer.size = effectiveSize;
      virtualizer.update();
      virtualizer.flush();
      if (cellCoordinates && cell.parentElement.hidden) {
        this.__focusBodyCell(cellCoordinates);
      }
      this._resetKeyboardNavigation();
    }
  }
  __hasRowsWithClientHeight() {
    return !!Array.from(this.$.items.children).filter((row) => row.clientHeight).length;
  }
  __itemsReceived() {
    if (this._recalculateColumnWidthOnceLoadingFinished && !this._cache.isLoading() && this.__hasRowsWithClientHeight()) {
      this._recalculateColumnWidthOnceLoadingFinished = false;
      this.recalculateColumnWidths();
    }
  }
  __getIntrinsicWidth(col) {
    const initialWidth = col.width;
    const initialFlexGrow = col.flexGrow;
    col.width = "auto";
    col.flexGrow = 0;
    const width = col._allCells.filter((cell) => {
      return !this.$.items.contains(cell) || this._isInViewport(cell.parentElement);
    }).reduce((width2, cell) => {
      return Math.max(width2, cell.offsetWidth + 1);
    }, 0);
    col.flexGrow = initialFlexGrow;
    col.width = initialWidth;
    return width;
  }
  __getDistributedWidth(col, innerColumn) {
    if (col == null || col === this) {
      return 0;
    }
    const columnWidth = Math.max(this.__getIntrinsicWidth(col), this.__getDistributedWidth(col.parentElement, col));
    if (!innerColumn) {
      return columnWidth;
    }
    const columnGroup = col;
    const columnGroupWidth = columnWidth;
    const sumOfWidthOfAllChildColumns = columnGroup._visibleChildColumns.map((col2) => this.__getIntrinsicWidth(col2)).reduce((sum, curr) => sum + curr, 0);
    const extraNecessarySpaceForGridColumnGroup = Math.max(0, columnGroupWidth - sumOfWidthOfAllChildColumns);
    const proportionOfExtraSpace = this.__getIntrinsicWidth(innerColumn) / sumOfWidthOfAllChildColumns;
    const shareOfInnerColumnFromNecessaryExtraSpace = proportionOfExtraSpace * extraNecessarySpaceForGridColumnGroup;
    return this.__getIntrinsicWidth(innerColumn) + shareOfInnerColumnFromNecessaryExtraSpace;
  }
  _recalculateColumnWidths(cols) {
    this.__virtualizer.flush();
    if (this._debouncerHiddenChanged) {
      this._debouncerHiddenChanged.flush();
    }
    cols.forEach((col) => {
      col.width = `${this.__getDistributedWidth(col)}px`;
    });
  }
  recalculateColumnWidths() {
    if (!this._columnTree) {
      return;
    }
    if (this._cache.isLoading()) {
      this._recalculateColumnWidthOnceLoadingFinished = true;
    } else {
      const cols = this._getColumns().filter((col) => !col.hidden && col.autoWidth);
      this._recalculateColumnWidths(cols);
    }
  }
  _createScrollerRows(count) {
    const rows = [];
    for (let i = 0; i < count; i++) {
      const row = document.createElement("tr");
      row.setAttribute("part", "row");
      row.setAttribute("role", "row");
      row.setAttribute("tabindex", "-1");
      if (this._columnTree) {
        this._updateRow(row, this._columnTree[this._columnTree.length - 1], "body", false, true);
      }
      rows.push(row);
    }
    if (this._columnTree) {
      this._columnTree[this._columnTree.length - 1].forEach(
        (c) => c.isConnected && c.notifyPath && c.notifyPath("_cells.*", c._cells)
      );
    }
    beforeNextRender(this, () => {
      this._updateFirstAndLastColumn();
      this._resetKeyboardNavigation();
      this._afterScroll();
      this.__itemsReceived();
    });
    return rows;
  }
  _createCell(tagName) {
    const contentId = this._contentIndex = this._contentIndex + 1 || 0;
    const slotName = `vaadin-grid-cell-content-${contentId}`;
    const cellContent = document.createElement("vaadin-grid-cell-content");
    cellContent.setAttribute("slot", slotName);
    const cell = document.createElement(tagName);
    cell.id = slotName.replace("-content-", "-");
    cell.setAttribute("tabindex", "-1");
    cell.setAttribute("role", tagName === "td" ? "gridcell" : "columnheader");
    const slot = document.createElement("slot");
    slot.setAttribute("name", slotName);
    cell.appendChild(slot);
    cell._content = cellContent;
    cellContent.addEventListener("mousedown", () => {
      if (isChrome) {
        const mouseUpListener = (event) => {
          const contentContainsFocusedElement = cellContent.contains(this.getRootNode().activeElement);
          const mouseUpWithinCell = event.composedPath().includes(cellContent);
          if (!contentContainsFocusedElement && mouseUpWithinCell) {
            cell.focus();
          }
          document.removeEventListener("mouseup", mouseUpListener, true);
        };
        document.addEventListener("mouseup", mouseUpListener, true);
      } else {
        setTimeout(() => {
          if (!cellContent.contains(this.getRootNode().activeElement)) {
            cell.focus();
          }
        });
      }
    });
    return cell;
  }
  _updateRow(row, columns, section, isColumnRow, noNotify) {
    section = section || "body";
    const contentsFragment = document.createDocumentFragment();
    Array.from(row.children).forEach((cell) => {
      cell._vacant = true;
    });
    row.innerHTML = "";
    columns.filter((column) => !column.hidden).forEach((column, index, cols) => {
      let cell;
      if (section === "body") {
        column._cells = column._cells || [];
        cell = column._cells.filter((cell2) => cell2._vacant)[0];
        if (!cell) {
          cell = this._createCell("td");
          column._cells.push(cell);
        }
        cell.setAttribute("part", "cell body-cell");
        row.appendChild(cell);
        if (index === cols.length - 1 && this.rowDetailsRenderer) {
          this._detailsCells = this._detailsCells || [];
          const detailsCell = this._detailsCells.filter((cell2) => cell2._vacant)[0] || this._createCell("td");
          if (this._detailsCells.indexOf(detailsCell) === -1) {
            this._detailsCells.push(detailsCell);
          }
          if (!detailsCell._content.parentElement) {
            contentsFragment.appendChild(detailsCell._content);
          }
          this._configureDetailsCell(detailsCell);
          row.appendChild(detailsCell);
          this._a11ySetRowDetailsCell(row, detailsCell);
          detailsCell._vacant = false;
        }
        if (column.notifyPath && !noNotify) {
          column.notifyPath("_cells.*", column._cells);
        }
      } else {
        const tagName = section === "header" ? "th" : "td";
        if (isColumnRow || column.localName === "vaadin-grid-column-group") {
          cell = column[`_${section}Cell`] || this._createCell(tagName);
          cell._column = column;
          row.appendChild(cell);
          column[`_${section}Cell`] = cell;
        } else {
          column._emptyCells = column._emptyCells || [];
          cell = column._emptyCells.filter((cell2) => cell2._vacant)[0] || this._createCell(tagName);
          cell._column = column;
          row.appendChild(cell);
          if (column._emptyCells.indexOf(cell) === -1) {
            column._emptyCells.push(cell);
          }
        }
        cell.setAttribute("part", `cell ${section}-cell`);
        this.__updateHeaderFooterRowVisibility(row);
      }
      if (!cell._content.parentElement) {
        contentsFragment.appendChild(cell._content);
      }
      cell._vacant = false;
      cell._column = column;
    });
    this.appendChild(contentsFragment);
    this._frozenCellsChanged();
    this._updateFirstAndLastColumnForRow(row);
  }
  __updateHeaderFooterRowVisibility(row) {
    if (!row) {
      return;
    }
    const visibleRowCells = Array.from(row.children).filter((cell) => {
      const column = cell._column;
      if (column._emptyCells && column._emptyCells.indexOf(cell) > -1) {
        return false;
      }
      if (row.parentElement === this.$.header) {
        if (column.headerRenderer) {
          return true;
        }
        if (column.header === null) {
          return false;
        }
        if (column.path || column.header !== void 0) {
          return true;
        }
      } else if (column.footerRenderer) {
        return true;
      }
      return false;
    });
    if (row.hidden !== !visibleRowCells.length) {
      row.hidden = !visibleRowCells.length;
    }
    this._resetKeyboardNavigation();
  }
  _updateScrollerItem(row, index) {
    this._preventScrollerRotatingCellFocus(row, index);
    if (!this._columnTree) {
      return;
    }
    row.toggleAttribute("first", index === 0);
    row.toggleAttribute("last", index === this._effectiveSize - 1);
    row.toggleAttribute("odd", index % 2);
    this._a11yUpdateRowRowindex(row, index);
    this._getItem(index, row);
  }
  _columnTreeChanged(columnTree) {
    this._renderColumnTree(columnTree);
    this.recalculateColumnWidths();
  }
  _renderColumnTree(columnTree) {
    Array.from(this.$.items.children).forEach(
      (row) => this._updateRow(row, columnTree[columnTree.length - 1], null, false, true)
    );
    while (this.$.header.children.length < columnTree.length) {
      const headerRow = document.createElement("tr");
      headerRow.setAttribute("part", "row");
      headerRow.setAttribute("role", "row");
      headerRow.setAttribute("tabindex", "-1");
      this.$.header.appendChild(headerRow);
      const footerRow = document.createElement("tr");
      footerRow.setAttribute("part", "row");
      footerRow.setAttribute("role", "row");
      footerRow.setAttribute("tabindex", "-1");
      this.$.footer.appendChild(footerRow);
    }
    while (this.$.header.children.length > columnTree.length) {
      this.$.header.removeChild(this.$.header.firstElementChild);
      this.$.footer.removeChild(this.$.footer.firstElementChild);
    }
    Array.from(this.$.header.children).forEach(
      (headerRow, index) => this._updateRow(headerRow, columnTree[index], "header", index === columnTree.length - 1)
    );
    Array.from(this.$.footer.children).forEach(
      (footerRow, index) => this._updateRow(footerRow, columnTree[columnTree.length - 1 - index], "footer", index === 0)
    );
    this._updateRow(this.$.sizer, columnTree[columnTree.length - 1]);
    this._resizeHandler();
    this._frozenCellsChanged();
    this._updateFirstAndLastColumn();
    this._resetKeyboardNavigation();
    this._a11yUpdateHeaderRows();
    this._a11yUpdateFooterRows();
    this.__updateFooterPositioning();
    this.generateCellClassNames();
  }
  __updateFooterPositioning() {
    if (this._firefox && parseFloat(navigator.userAgent.match(/Firefox\/(\d{2,3}.\d)/)[1]) < 99) {
      this.$.items.style.paddingBottom = 0;
      if (!this.allRowsVisible) {
        this.$.items.style.paddingBottom = `${this.$.footer.offsetHeight}px`;
      }
    }
  }
  _updateItem(row, item) {
    row._item = item;
    const model = this.__getRowModel(row);
    this._toggleDetailsCell(row, model.detailsOpened);
    this._a11yUpdateRowLevel(row, model.level);
    this._a11yUpdateRowSelected(row, model.selected);
    row.toggleAttribute("expanded", model.expanded);
    row.toggleAttribute("selected", model.selected);
    row.toggleAttribute("details-opened", model.detailsOpened);
    this._generateCellClassNames(row, model);
    this._filterDragAndDrop(row, model);
    Array.from(row.children).forEach((cell) => {
      if (cell._renderer) {
        const owner = cell._column || this;
        cell._renderer.call(owner, cell._content, owner, model);
      }
    });
    this._updateDetailsCellHeight(row);
    this._a11yUpdateRowExpanded(row, model.expanded);
  }
  _resizeHandler() {
    this._updateDetailsCellHeights();
    this.__updateFooterPositioning();
    this.__updateHorizontalScrollPosition();
  }
  _onAnimationEnd(e) {
    if (e.animationName.indexOf("vaadin-grid-appear") === 0) {
      e.stopPropagation();
      this.__itemsReceived();
      requestAnimationFrame(() => {
        this.__scrollToPendingIndex();
      });
    }
  }
  __getRowModel(row) {
    return {
      index: row.index,
      item: row._item,
      level: this._getIndexLevel(row.index),
      expanded: this._isExpanded(row._item),
      selected: this._isSelected(row._item),
      detailsOpened: !!this.rowDetailsRenderer && this._isDetailsOpened(row._item)
    };
  }
  requestContentUpdate() {
    if (this._columnTree) {
      this._columnTree.forEach((level) => {
        level.forEach((column) => {
          if (column._renderHeaderAndFooter) {
            column._renderHeaderAndFooter();
          }
        });
      });
      this.__updateVisibleRows();
    }
  }
  __updateVisibleRows(start, end) {
    if (this.__virtualizer) {
      this.__virtualizer.update(start, end);
    }
  }
  notifyResize() {
    console.warn(
      `WARNING: Since Vaadin 22, notifyResize() is deprecated. The component uses a ResizeObserver internally and doesn't need to be explicitly notified of resizes.`
    );
  }
};
customElements.define(Grid.is, Grid);

export {
  ItemCache,
  Grid
};
/**
 * @license
 * Copyright (c) 2016 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-4EOLQRNY.js.map
