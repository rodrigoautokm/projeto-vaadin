import {
  FlattenedNodesObserver
} from "./chunk-4V7CPLV2.js";
import {
  isElementFocused
} from "./chunk-7OTQVW5F.js";
import {
  Debouncer
} from "./chunk-VUWTYCVF.js";
import {
  DirHelper
} from "./chunk-RTIK5DCO.js";
import {
  timeOut
} from "./chunk-CQH3N2QY.js";

// node_modules/@vaadin/vaadin-list-mixin/vaadin-list-mixin.js
var ListMixin = (superClass) => class VaadinListMixin extends superClass {
  static get properties() {
    return {
      _hasVaadinListMixin: {
        value: true
      },
      selected: {
        type: Number,
        reflectToAttribute: true,
        notify: true
      },
      orientation: {
        type: String,
        reflectToAttribute: true,
        value: ""
      },
      items: {
        type: Array,
        readOnly: true,
        notify: true
      },
      _searchBuf: {
        type: String,
        value: ""
      }
    };
  }
  static get observers() {
    return ["_enhanceItems(items, orientation, selected, disabled)"];
  }
  ready() {
    super.ready();
    this.addEventListener("keydown", (e) => this._onKeydown(e));
    this.addEventListener("click", (e) => this._onClick(e));
    this._observer = new FlattenedNodesObserver(this, () => {
      this._setItems(this._filterItems(FlattenedNodesObserver.getFlattenedNodes(this)));
    });
  }
  _enhanceItems(items, orientation, selected, disabled) {
    if (!disabled) {
      if (items) {
        this.setAttribute("aria-orientation", orientation || "vertical");
        this.items.forEach((item) => {
          if (orientation) {
            item.setAttribute("orientation", orientation);
          } else {
            item.removeAttribute("orientation");
          }
        });
        this._setFocusable(selected || 0);
        const itemToSelect = items[selected];
        items.forEach((item) => {
          item.selected = item === itemToSelect;
        });
        if (itemToSelect && !itemToSelect.disabled) {
          this._scrollToItem(selected);
        }
      }
    }
  }
  get focused() {
    return (this.items || []).find(isElementFocused);
  }
  _filterItems(array) {
    return array.filter((e) => e._hasVaadinItemMixin);
  }
  _onClick(event) {
    if (event.metaKey || event.shiftKey || event.ctrlKey || event.defaultPrevented) {
      return;
    }
    const item = this._filterItems(event.composedPath())[0];
    let idx;
    if (item && !item.disabled && (idx = this.items.indexOf(item)) >= 0) {
      this.selected = idx;
    }
  }
  _searchKey(currentIdx, key) {
    this._searchReset = Debouncer.debounce(this._searchReset, timeOut.after(500), () => {
      this._searchBuf = "";
    });
    this._searchBuf += key.toLowerCase();
    const increment = 1;
    const condition = (item) => !(item.disabled || this._isItemHidden(item)) && item.textContent.replace(/[^\p{L}\p{Nd}]/gu, "").toLowerCase().indexOf(this._searchBuf) === 0;
    if (!this.items.some(
      (item) => item.textContent.replace(/[^\p{L}\p{Nd}]/gu, "").toLowerCase().indexOf(this._searchBuf) === 0
    )) {
      this._searchBuf = key.toLowerCase();
    }
    const idx = this._searchBuf.length === 1 ? currentIdx + 1 : currentIdx;
    return this._getAvailableIndex(idx, increment, condition);
  }
  get _isRTL() {
    return !this._vertical && this.getAttribute("dir") === "rtl";
  }
  _onKeydown(event) {
    if (event.metaKey || event.ctrlKey) {
      return;
    }
    const key = event.key;
    const currentIdx = this.items.indexOf(this.focused);
    if (/[a-zA-Z0-9]/.test(key) && key.length === 1) {
      const idx2 = this._searchKey(currentIdx, key);
      if (idx2 >= 0) {
        this._focus(idx2);
      }
      return;
    }
    const condition = (item) => !(item.disabled || this._isItemHidden(item));
    let idx, increment;
    const dirIncrement = this._isRTL ? -1 : 1;
    if (this._vertical && key === "ArrowUp" || !this._vertical && key === "ArrowLeft") {
      increment = -dirIncrement;
      idx = currentIdx - dirIncrement;
    } else if (this._vertical && key === "ArrowDown" || !this._vertical && key === "ArrowRight") {
      increment = dirIncrement;
      idx = currentIdx + dirIncrement;
    } else if (key === "Home") {
      increment = 1;
      idx = 0;
    } else if (key === "End") {
      increment = -1;
      idx = this.items.length - 1;
    }
    idx = this._getAvailableIndex(idx, increment, condition);
    if (idx >= 0) {
      this._focus(idx);
      event.preventDefault();
    }
  }
  _getAvailableIndex(idx, increment, condition) {
    const totalItems = this.items.length;
    for (let i = 0; typeof idx === "number" && i < totalItems; i++, idx += increment || 1) {
      if (idx < 0) {
        idx = totalItems - 1;
      } else if (idx >= totalItems) {
        idx = 0;
      }
      const item = this.items[idx];
      if (condition(item)) {
        return idx;
      }
    }
    return -1;
  }
  _isItemHidden(item) {
    return getComputedStyle(item).display === "none";
  }
  _setFocusable(idx) {
    idx = this._getAvailableIndex(idx, 1, (item2) => !item2.disabled);
    const item = this.items[idx];
    this.items.forEach((e) => {
      e.tabIndex = e === item ? 0 : -1;
    });
  }
  _focus(idx) {
    const item = this.items[idx];
    this.items.forEach((e) => {
      e.focused = e === item;
    });
    this._setFocusable(idx);
    this._scrollToItem(idx);
    this._focusItem(item);
  }
  _focusItem(item) {
    if (item) {
      item.focus();
      item.setAttribute("focus-ring", "");
    }
  }
  focus() {
    if (this._observer) {
      this._observer.flush();
    }
    const firstItem = this.querySelector('[tabindex="0"]') || (this.items ? this.items[0] : null);
    this._focusItem(firstItem);
  }
  get _scrollerElement() {
    console.warn(`Please implement the '_scrollerElement' property in <${this.localName}>`);
    return this;
  }
  _scrollToItem(idx) {
    const item = this.items[idx];
    if (!item) {
      return;
    }
    const props = this._vertical ? ["top", "bottom"] : this._isRTL ? ["right", "left"] : ["left", "right"];
    const scrollerRect = this._scrollerElement.getBoundingClientRect();
    const nextItemRect = (this.items[idx + 1] || item).getBoundingClientRect();
    const prevItemRect = (this.items[idx - 1] || item).getBoundingClientRect();
    let scrollDistance = 0;
    if (!this._isRTL && nextItemRect[props[1]] >= scrollerRect[props[1]] || this._isRTL && nextItemRect[props[1]] <= scrollerRect[props[1]]) {
      scrollDistance = nextItemRect[props[1]] - scrollerRect[props[1]];
    } else if (!this._isRTL && prevItemRect[props[0]] <= scrollerRect[props[0]] || this._isRTL && prevItemRect[props[0]] >= scrollerRect[props[0]]) {
      scrollDistance = prevItemRect[props[0]] - scrollerRect[props[0]];
    }
    this._scroll(scrollDistance);
  }
  get _vertical() {
    return this.orientation !== "horizontal";
  }
  _scroll(pixels) {
    if (this._vertical) {
      this._scrollerElement.scrollTop += pixels;
    } else {
      const dir = this.getAttribute("dir") || "ltr";
      const scrollType = DirHelper.detectScrollType();
      const scrollLeft = DirHelper.getNormalizedScrollLeft(scrollType, dir, this._scrollerElement) + pixels;
      DirHelper.setNormalizedScrollLeft(scrollType, dir, this._scrollerElement, scrollLeft);
    }
  }
};

export {
  ListMixin
};
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-QAHWQ2NB.js.map
