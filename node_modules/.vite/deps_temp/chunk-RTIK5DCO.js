// node_modules/@vaadin/component-base/src/dir-helper.js
var DirHelper = class {
  static detectScrollType() {
    const dummy = document.createElement("div");
    dummy.textContent = "ABCD";
    dummy.dir = "rtl";
    dummy.style.fontSize = "14px";
    dummy.style.width = "4px";
    dummy.style.height = "1px";
    dummy.style.position = "absolute";
    dummy.style.top = "-1000px";
    dummy.style.overflow = "scroll";
    document.body.appendChild(dummy);
    let cachedType = "reverse";
    if (dummy.scrollLeft > 0) {
      cachedType = "default";
    } else {
      dummy.scrollLeft = 2;
      if (dummy.scrollLeft < 2) {
        cachedType = "negative";
      }
    }
    document.body.removeChild(dummy);
    return cachedType;
  }
  static getNormalizedScrollLeft(scrollType2, direction, element) {
    const { scrollLeft } = element;
    if (direction !== "rtl" || !scrollType2) {
      return scrollLeft;
    }
    switch (scrollType2) {
      case "negative":
        return element.scrollWidth - element.clientWidth + scrollLeft;
      case "reverse":
        return element.scrollWidth - element.clientWidth - scrollLeft;
      default:
        return scrollLeft;
    }
  }
  static setNormalizedScrollLeft(scrollType2, direction, element, scrollLeft) {
    if (direction !== "rtl" || !scrollType2) {
      element.scrollLeft = scrollLeft;
      return;
    }
    switch (scrollType2) {
      case "negative":
        element.scrollLeft = element.clientWidth - element.scrollWidth + scrollLeft;
        break;
      case "reverse":
        element.scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;
        break;
      default:
        element.scrollLeft = scrollLeft;
        break;
    }
  }
};

// node_modules/@vaadin/component-base/src/dir-mixin.js
var directionSubscribers = [];
function directionUpdater() {
  const documentDir = getDocumentDir();
  directionSubscribers.forEach((element) => {
    alignDirs(element, documentDir);
  });
}
var scrollType;
var directionObserver = new MutationObserver(directionUpdater);
directionObserver.observe(document.documentElement, { attributes: true, attributeFilter: ["dir"] });
function alignDirs(element, documentDir, elementDir = element.getAttribute("dir")) {
  if (documentDir) {
    element.setAttribute("dir", documentDir);
  } else if (elementDir != null) {
    element.removeAttribute("dir");
  }
}
function getDocumentDir() {
  return document.documentElement.getAttribute("dir");
}
var DirMixin = (superClass) => class VaadinDirMixin extends superClass {
  static get properties() {
    return {
      dir: {
        type: String,
        value: "",
        reflectToAttribute: true,
        converter: {
          fromAttribute: (attr) => {
            return !attr ? "" : attr;
          },
          toAttribute: (prop) => {
            return prop === "" ? null : prop;
          }
        }
      }
    };
  }
  static finalize() {
    super.finalize();
    if (!scrollType) {
      scrollType = DirHelper.detectScrollType();
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.hasAttribute("dir") || this.__restoreSubscription) {
      this.__subscribe();
      alignDirs(this, getDocumentDir(), null);
    }
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name !== "dir") {
      return;
    }
    const documentDir = getDocumentDir();
    const newValueEqlDocDir = newValue === documentDir && directionSubscribers.indexOf(this) === -1;
    const newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1;
    const newDiffValue = newValue !== documentDir && oldValue === documentDir;
    if (newValueEqlDocDir || newValueEmptied) {
      this.__subscribe();
      alignDirs(this, documentDir, newValue);
    } else if (newDiffValue) {
      this.__unsubscribe();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__restoreSubscription = directionSubscribers.includes(this);
    this.__unsubscribe();
  }
  _valueToNodeAttribute(node, value, attribute) {
    if (attribute === "dir" && value === "" && !node.hasAttribute("dir")) {
      return;
    }
    super._valueToNodeAttribute(node, value, attribute);
  }
  _attributeToProperty(attribute, value, type) {
    if (attribute === "dir" && !value) {
      this.dir = "";
    } else {
      super._attributeToProperty(attribute, value, type);
    }
  }
  __subscribe() {
    if (!directionSubscribers.includes(this)) {
      directionSubscribers.push(this);
    }
  }
  __unsubscribe() {
    if (directionSubscribers.includes(this)) {
      directionSubscribers.splice(directionSubscribers.indexOf(this), 1);
    }
  }
  __getNormalizedScrollLeft(element) {
    return DirHelper.getNormalizedScrollLeft(scrollType, this.getAttribute("dir") || "ltr", element);
  }
  __setNormalizedScrollLeft(element, scrollLeft) {
    return DirHelper.setNormalizedScrollLeft(scrollType, this.getAttribute("dir") || "ltr", element, scrollLeft);
  }
};

export {
  DirHelper,
  DirMixin
};
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-RTIK5DCO.js.map
