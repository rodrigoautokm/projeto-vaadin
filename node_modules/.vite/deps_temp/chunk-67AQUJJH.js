import {
  dedupingMixin
} from "./chunk-NCN7ELFS.js";

// node_modules/@vaadin/field-base/src/labelled-input-controller.js
var LabelledInputController = class {
  constructor(input, labelController) {
    this.input = input;
    this.__preventDuplicateLabelClick = this.__preventDuplicateLabelClick.bind(this);
    labelController.addEventListener("label-changed", (event) => {
      this.__initLabel(event.detail.node);
    });
    this.__initLabel(labelController.node);
  }
  __initLabel(label) {
    if (label) {
      label.addEventListener("click", this.__preventDuplicateLabelClick);
      if (this.input) {
        label.setAttribute("for", this.input.id);
      }
    }
  }
  __preventDuplicateLabelClick() {
    const inputClickHandler = (e) => {
      e.stopImmediatePropagation();
      this.input.removeEventListener("click", inputClickHandler);
    };
    this.input.addEventListener("click", inputClickHandler);
  }
};

// node_modules/@vaadin/field-base/src/input-mixin.js
var InputMixin = dedupingMixin(
  (superclass) => class InputMixinClass extends superclass {
    static get properties() {
      return {
        inputElement: {
          type: Object,
          readOnly: true,
          observer: "_inputElementChanged"
        },
        type: {
          type: String,
          readOnly: true
        },
        value: {
          type: String,
          value: "",
          observer: "_valueChanged",
          notify: true
        },
        _hasInputValue: {
          type: Boolean,
          value: false,
          observer: "_hasInputValueChanged"
        }
      };
    }
    constructor() {
      super();
      this._boundOnInput = this.__onInput.bind(this);
      this._boundOnChange = this._onChange.bind(this);
    }
    clear() {
      this.value = "";
    }
    _addInputListeners(input) {
      input.addEventListener("input", this._boundOnInput);
      input.addEventListener("change", this._boundOnChange);
    }
    _removeInputListeners(input) {
      input.removeEventListener("input", this._boundOnInput);
      input.removeEventListener("change", this._boundOnChange);
    }
    _forwardInputValue(value) {
      if (!this.inputElement) {
        return;
      }
      if (value != null) {
        this.inputElement.value = value;
      } else {
        this.inputElement.value = "";
      }
    }
    _inputElementChanged(input, oldInput) {
      if (input) {
        this._addInputListeners(input);
      } else if (oldInput) {
        this._removeInputListeners(oldInput);
      }
    }
    _hasInputValueChanged(hasValue, oldHasValue) {
      if (hasValue || oldHasValue) {
        this.dispatchEvent(new CustomEvent("has-input-value-changed"));
      }
    }
    __onInput(event) {
      const target = event.composedPath()[0];
      this._hasInputValue = target.value.length > 0;
      this._onInput(event);
    }
    _onInput(event) {
      const target = event.composedPath()[0];
      this.__userInput = event.isTrusted;
      this.value = target.value;
      this.__userInput = false;
    }
    _onChange(_event) {
    }
    _toggleHasValue(hasValue) {
      this.toggleAttribute("has-value", hasValue);
    }
    _valueChanged(newVal, oldVal) {
      this._toggleHasValue(this._hasValue);
      if (newVal === "" && oldVal === void 0) {
        return;
      }
      if (this.__userInput) {
        return;
      }
      this._forwardInputValue(newVal);
    }
    get _hasValue() {
      return this.value != null && this.value !== "";
    }
  }
);

export {
  InputMixin,
  LabelledInputController
};
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-67AQUJJH.js.map
