{
  "version": 3,
  "sources": ["../../@vaadin/virtual-list/src/vaadin-virtual-list.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { html, PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { ControllerMixin } from '@vaadin/component-base/src/controller-mixin.js';\nimport { ElementMixin } from '@vaadin/component-base/src/element-mixin.js';\nimport { OverflowController } from '@vaadin/component-base/src/overflow-controller.js';\nimport { processTemplates } from '@vaadin/component-base/src/templates.js';\nimport { Virtualizer } from '@vaadin/component-base/src/virtualizer.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\n\n/**\n * `<vaadin-virtual-list>` is a Web Component for displaying a virtual/infinite list of items.\n *\n * ```html\n * <vaadin-virtual-list></vaadin-virtual-list>\n * ```\n *\n * ```js\n * const list = document.querySelector('vaadin-virtual-list');\n * list.items = items; // An array of data items\n * list.renderer = (root, list, {item, index}) => {\n *   root.textContent = `#${index}: ${item.name}`\n * }\n * ```\n *\n * The following state attributes are available for styling:\n *\n * Attribute        | Description\n * -----------------|--------------------------------------------\n * `overflow`       | Set to `top`, `bottom`, both, or none.\n *\n * See [Virtual List](https://vaadin.com/docs/latest/components/virtual-list) documentation.\n *\n * @extends HTMLElement\n * @mixes ControllerMixin\n * @mixes ElementMixin\n * @mixes ThemableMixin\n */\nclass VirtualList extends ElementMixin(ControllerMixin(ThemableMixin(PolymerElement))) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n          height: 400px;\n          overflow: auto;\n          flex: auto;\n          align-self: stretch;\n        }\n\n        :host([hidden]) {\n          display: none !important;\n        }\n\n        :host(:not([grid])) #items > ::slotted(*) {\n          width: 100%;\n        }\n      </style>\n\n      <div id=\"items\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-virtual-list';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * An array containing items determining how many instances to render.\n       * @type {Array<!VirtualListItem> | undefined}\n       */\n      items: { type: Array },\n\n      /**\n       * Custom function for rendering the content of every item.\n       * Receives three arguments:\n       *\n       * - `root` The render target element representing one item at a time.\n       * - `virtualList` The reference to the `<vaadin-virtual-list>` element.\n       * - `model` The object with the properties related with the rendered\n       *   item, contains:\n       *   - `model.index` The index of the rendered item.\n       *   - `model.item` The item.\n       * @type {VirtualListRenderer | undefined}\n       */\n      renderer: Function,\n\n      /** @private */\n      __virtualizer: Object,\n    };\n  }\n\n  static get observers() {\n    return ['__itemsOrRendererChanged(items, renderer, __virtualizer)'];\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n\n    this.__virtualizer = new Virtualizer({\n      createElements: this.__createElements,\n      updateElement: this.__updateElement.bind(this),\n      elementsContainer: this,\n      scrollTarget: this,\n      scrollContainer: this.shadowRoot.querySelector('#items'),\n    });\n\n    this.__overflowController = new OverflowController(this);\n    this.addController(this.__overflowController);\n\n    processTemplates(this);\n  }\n\n  /**\n   * Scroll to a specific index in the virtual list.\n   *\n   * @param {number} index Index to scroll to\n   */\n  scrollToIndex(index) {\n    this.__virtualizer.scrollToIndex(index);\n  }\n\n  /** @private */\n  __createElements(count) {\n    return [...Array(count)].map(() => document.createElement('div'));\n  }\n\n  /** @private */\n  __updateElement(el, index) {\n    if (el.__renderer !== this.renderer) {\n      el.__renderer = this.renderer;\n      this.__clearRenderTargetContent(el);\n    }\n\n    if (this.renderer) {\n      this.renderer(el, this, { item: this.items[index], index });\n    }\n  }\n\n  /**\n   * Clears the content of a render target.\n   * @private\n   */\n  __clearRenderTargetContent(element) {\n    element.innerHTML = '';\n    // Whenever a Lit-based renderer is used, it assigns a Lit part to the node it was rendered into.\n    // When clearing the rendered content, this part needs to be manually disposed of.\n    // Otherwise, using a Lit-based renderer on the same node will throw an exception or render nothing afterward.\n    delete element._$litPart$;\n  }\n\n  /** @private */\n  __itemsOrRendererChanged(items, renderer, virtualizer) {\n    // If the renderer is removed but there are elements created by\n    // a previous renderer, we need to request an update from the virtualizer\n    // to get the already existing elements properly cleared.\n    const hasRenderedItems = this.childElementCount > 0;\n\n    if ((renderer || hasRenderedItems) && virtualizer) {\n      virtualizer.size = (items || []).length;\n      virtualizer.update();\n    }\n  }\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @return {number}\n   */\n  get firstVisibleIndex() {\n    return this.__virtualizer.firstVisibleIndex;\n  }\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @return {number}\n   */\n  get lastVisibleIndex() {\n    return this.__virtualizer.lastVisibleIndex;\n  }\n\n  /**\n   * Requests an update for the content of the rows.\n   * While performing the update, it invokes the renderer passed in the `renderer` property for each visible row.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n  requestContentUpdate() {\n    if (this.__virtualizer) {\n      this.__virtualizer.update();\n    }\n  }\n}\n\ncustomElements.define(VirtualList.is, VirtualList);\n\nexport { VirtualList };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA,IAAM,cAAN,cAA0B,aAAa,gBAAgB,cAAc,cAAc,CAAC,CAAC,EAAE;AAAA,EACrF,WAAW,WAAW;AACpB,WAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBT;AAAA,EAEA,WAAW,KAAK;AACd,WAAO;AAAA,EACT;AAAA,EAEA,WAAW,aAAa;AACtB,WAAO;AAAA,MAKL,OAAO,EAAE,MAAM,MAAM;AAAA,MAcrB,UAAU;AAAA,MAGV,eAAe;AAAA,IACjB;AAAA,EACF;AAAA,EAEA,WAAW,YAAY;AACrB,WAAO,CAAC,0DAA0D;AAAA,EACpE;AAAA,EAGA,QAAQ;AACN,UAAM,MAAM;AAEZ,SAAK,gBAAgB,IAAI,YAAY;AAAA,MACnC,gBAAgB,KAAK;AAAA,MACrB,eAAe,KAAK,gBAAgB,KAAK,IAAI;AAAA,MAC7C,mBAAmB;AAAA,MACnB,cAAc;AAAA,MACd,iBAAiB,KAAK,WAAW,cAAc,QAAQ;AAAA,IACzD,CAAC;AAED,SAAK,uBAAuB,IAAI,mBAAmB,IAAI;AACvD,SAAK,cAAc,KAAK,oBAAoB;AAE5C,qBAAiB,IAAI;AAAA,EACvB;AAAA,EAOA,cAAc,OAAO;AACnB,SAAK,cAAc,cAAc,KAAK;AAAA,EACxC;AAAA,EAGA,iBAAiB,OAAO;AACtB,WAAO,CAAC,GAAG,MAAM,KAAK,CAAC,EAAE,IAAI,MAAM,SAAS,cAAc,KAAK,CAAC;AAAA,EAClE;AAAA,EAGA,gBAAgB,IAAI,OAAO;AACzB,QAAI,GAAG,eAAe,KAAK,UAAU;AACnC,SAAG,aAAa,KAAK;AACrB,WAAK,2BAA2B,EAAE;AAAA,IACpC;AAEA,QAAI,KAAK,UAAU;AACjB,WAAK,SAAS,IAAI,MAAM,EAAE,MAAM,KAAK,MAAM,QAAQ,MAAM,CAAC;AAAA,IAC5D;AAAA,EACF;AAAA,EAMA,2BAA2B,SAAS;AAClC,YAAQ,YAAY;AAIpB,WAAO,QAAQ;AAAA,EACjB;AAAA,EAGA,yBAAyB,OAAO,UAAU,aAAa;AAIrD,UAAM,mBAAmB,KAAK,oBAAoB;AAElD,SAAK,YAAY,qBAAqB,aAAa;AACjD,kBAAY,QAAQ,SAAS,CAAC,GAAG;AACjC,kBAAY,OAAO;AAAA,IACrB;AAAA,EACF;AAAA,EAOA,IAAI,oBAAoB;AACtB,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA,EAOA,IAAI,mBAAmB;AACrB,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA,EAQA,uBAAuB;AACrB,QAAI,KAAK,eAAe;AACtB,WAAK,cAAc,OAAO;AAAA,IAC5B;AAAA,EACF;AACF;AAEA,eAAe,OAAO,YAAY,IAAI,WAAW;",
  "names": []
}
