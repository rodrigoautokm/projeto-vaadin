{
  "version": 3,
  "sources": ["../../@polymer/polymer/lib/elements/dom-if.js"],
  "sourcesContent": ["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\n\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { microTask } from '../utils/async.js';\nimport { root } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\nimport { hideElementsGlobally } from '../utils/hide-template-controls.js';\nimport { fastDomIf, strictTemplatePolicy, suppressTemplateNotifications } from '../utils/settings.js';\nimport { showHideChildren, templatize } from '../utils/templatize.js';\n\n/**\n * @customElement\n * @polymer\n * @extends PolymerElement\n * @summary Base class for dom-if element; subclassed into concrete\n *   implementation.\n */\nclass DomIfBase extends PolymerElement {\n\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() { return 'dom-if'; }\n\n  static get template() { return null; }\n\n  static get properties() {\n\n    return {\n\n      /**\n       * Fired whenever DOM is added or removed/hidden by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n\n      /**\n       * A boolean indicating whether this template should stamp.\n       */\n      if: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n\n      /**\n       * When true, elements will be removed from DOM and discarded when `if`\n       * becomes false and re-created and added back to the DOM when `if`\n       * becomes true.  By default, stamped elements will be hidden but left\n       * in the DOM when `if` becomes false, which is generally results\n       * in better performance.\n       */\n      restamp: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n\n      /**\n       * When the global `suppressTemplateNotifications` setting is used, setting\n       * `notifyDomChange: true` will enable firing `dom-change` events on this\n       * element.\n       */\n      notifyDomChange: {\n        type: Boolean\n      }\n    };\n\n  }\n\n  constructor() {\n    super();\n    this.__renderDebouncer = null;\n    this._lastIf = false;\n    this.__hideTemplateChildren__ = false;\n    /** @type {!HTMLTemplateElement|undefined} */\n    this.__template;\n    /** @type {!TemplateInfo|undefined} */\n    this._templateInfo;\n  }\n\n  __debounceRender() {\n    // Render is async for 2 reasons:\n    // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n    //    same turn. This was more common in 1.x where a compound computed\n    //    property could result in the result changing multiple times, but is\n    //    mitigated to a large extent by batched property processing in 2.x.\n    // 2. To avoid double object propagation when a bag including values bound\n    //    to the `if` property as well as one or more hostProps could enqueue\n    //    the <dom-if> to flush before the <template>'s host property\n    //    forwarding. In that scenario creating an instance would result in\n    //    the host props being set once, and then the enqueued changes on the\n    //    template would set properties a second time, potentially causing an\n    //    object to be set to an instance more than once.  Creating the\n    //    instance async from flushing data ensures this doesn't happen. If\n    //    we wanted a sync option in the future, simply having <dom-if> flush\n    //    (or clear) its template's pending host properties before creating\n    //    the instance would also avoid the problem.\n    this.__renderDebouncer = Debouncer.debounce(\n          this.__renderDebouncer\n        , microTask\n        , () => this.__render());\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    const parent = wrap(this).parentNode;\n    if (!parent || (parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&\n        !wrap(parent).host)) {\n      this.__teardownInstance();\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    if (!hideElementsGlobally()) {\n      this.style.display = 'none';\n    }\n    if (this.if) {\n      this.__debounceRender();\n    }\n  }\n\n  /**\n   * Ensures a template has been assigned to `this.__template`.  If it has not\n   * yet been, it querySelectors for it in its children and if it does not yet\n   * exist (e.g. in parser-generated case), opens a mutation observer and\n   * waits for it to appear (returns false if it has not yet been found,\n   * otherwise true).  In the `removeNestedTemplates` case, the \"template\" will\n   * be the `dom-if` element itself.\n   *\n   * @return {boolean} True when a template has been found, false otherwise\n   */\n  __ensureTemplate() {\n    if (!this.__template) {\n      // When `removeNestedTemplates` is true, the \"template\" is the element\n      // itself, which has been given a `_templateInfo` property\n      const thisAsTemplate = /** @type {!HTMLTemplateElement} */ (\n          /** @type {!HTMLElement} */ (this));\n      let template = thisAsTemplate._templateInfo ?\n          thisAsTemplate :\n          /** @type {!HTMLTemplateElement} */\n          (wrap(thisAsTemplate).querySelector('template'));\n      if (!template) {\n        // Wait until childList changes and template should be there by then\n        let observer = new MutationObserver(() => {\n          if (wrap(this).querySelector('template')) {\n            observer.disconnect();\n            this.__render();\n          } else {\n            throw new Error('dom-if requires a <template> child');\n          }\n        });\n        observer.observe(this, {childList: true});\n        return false;\n      }\n      this.__template = template;\n    }\n    return true;\n  }\n\n  /**\n   * Ensures a an instance of the template has been created and inserted. This\n   * method may return false if the template has not yet been found or if\n   * there is no `parentNode` to insert the template into (in either case,\n   * connection or the template-finding mutation observer firing will queue\n   * another render, causing this method to be called again at a more\n   * appropriate time).\n   *\n   * Subclasses should implement the following methods called here:\n   * - `__hasInstance`\n   * - `__createAndInsertInstance`\n   * - `__getInstanceNodes`\n   *\n   * @return {boolean} True if the instance was created, false otherwise.\n   */\n  __ensureInstance() {\n    let parentNode = wrap(this).parentNode;\n    if (!this.__hasInstance()) {\n      // Guard against element being detached while render was queued\n      if (!parentNode) {\n        return false;\n      }\n      // Find the template (when false, there was no template yet)\n      if (!this.__ensureTemplate()) {\n        return false;\n      }\n      this.__createAndInsertInstance(parentNode);\n    } else {\n      // Move instance children if necessary\n      let children = this.__getInstanceNodes();\n      if (children && children.length) {\n        // Detect case where dom-if was re-attached in new position\n        let lastChild = wrap(this).previousSibling;\n        if (lastChild !== children[children.length-1]) {\n          for (let i=0, n; (i<children.length) && (n=children[i]); i++) {\n            wrap(parentNode).insertBefore(n, this);\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   *\n   * @return {void}\n   */\n  render() {\n    flush();\n  }\n\n  /**\n   * Performs the key rendering steps:\n   * 1. Ensure a template instance has been stamped (when true)\n   * 2. Remove the template instance (when false and restamp:true)\n   * 3. Sync the hidden state of the instance nodes with the if/restamp state\n   * 4. Fires the `dom-change` event when necessary\n   *\n   * @return {void}\n   */\n  __render() {\n    if (this.if) {\n      if (!this.__ensureInstance()) {\n        // No template found yet\n        return;\n      }\n    } else if (this.restamp) {\n      this.__teardownInstance();\n    }\n    this._showHideChildren();\n    if ((!suppressTemplateNotifications || this.notifyDomChange)\n        && this.if != this._lastIf) {\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      this._lastIf = this.if;\n    }\n  }\n\n  // Ideally these would be annotated as abstract methods in an abstract class,\n  // but closure compiler is finnicky\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Abstract API to be implemented by subclass: Returns true if a template\n   * instance has been created and inserted.\n   *\n   * @protected\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() { }\n\n  /**\n   * Abstract API to be implemented by subclass: Returns the child nodes stamped\n   * from a template instance.\n   *\n   * @protected\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() { }\n\n  /**\n   * Abstract API to be implemented by subclass: Creates an instance of the\n   * template and inserts it into the given parent node.\n   *\n   * @protected\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) { } // eslint-disable-line no-unused-vars\n\n  /**\n   * Abstract API to be implemented by subclass: Removes nodes created by an\n   * instance of a template and any associated cleanup.\n   *\n   * @protected\n   * @return {void}\n   */\n  __teardownInstance() { }\n\n  /**\n   * Abstract API to be implemented by subclass: Shows or hides any template\n   * instance childNodes based on the `if` state of the element and its\n   * `__hideTemplateChildren__` property.\n   *\n   * @protected\n   * @return {void}\n   */\n  _showHideChildren() { }\n  /* eslint-enable valid-jsdoc */\n}\n\n/**\n * The version of DomIf used when `fastDomIf` setting is in use, which is\n * optimized for first-render (but adds a tax to all subsequent property updates\n * on the host, whether they were used in a given `dom-if` or not).\n *\n * This implementation avoids use of `Templatizer`, which introduces a new scope\n * (a non-element PropertyEffects instance), which is not strictly necessary\n * since `dom-if` never introduces new properties to its scope (unlike\n * `dom-repeat`). Taking advantage of this fact, the `dom-if` reaches up to its\n * `__dataHost` and stamps the template directly from the host using the host's\n * runtime `_stampTemplate` API, which binds the property effects of the\n * template directly to the host. This both avoids the intermediary\n * `Templatizer` instance, but also avoids the need to bind host properties to\n * the `<template>` element and forward those into the template instance.\n *\n * In this version of `dom-if`, the `this.__instance` method is the\n * `DocumentFragment` returned from `_stampTemplate`, which also serves as the\n * handle for later removing it using the `_removeBoundDom` method.\n */\nclass DomIfFast extends DomIfBase {\n\n  constructor() {\n    super();\n    this.__instance = null;\n    this.__syncInfo = null;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() {\n    return Boolean(this.__instance);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() {\n    return this.__instance.templateInfo.childNodes;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this\n   * element and then inserts the resulting nodes into the given `parentNode`.\n   *\n   * @override\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) {\n    const host = this.__dataHost || this;\n    if (strictTemplatePolicy) {\n      if (!this.__dataHost) {\n        throw new Error('strictTemplatePolicy: template owner not trusted');\n      }\n    }\n    // Pre-bind and link the template into the effects system\n    const templateInfo = host._bindTemplate(\n        /** @type {!HTMLTemplateElement} */ (this.__template), true);\n    // Install runEffects hook that prevents running property effects\n    // (and any nested template effects) when the `if` is false\n    templateInfo.runEffects = (runEffects, changedProps, hasPaths) => {\n      let syncInfo = this.__syncInfo;\n      if (this.if) {\n        // Mix any props that changed while the `if` was false into `changedProps`\n        if (syncInfo) {\n          // If there were properties received while the `if` was false, it is\n          // important to sync the hidden state with the element _first_, so that\n          // new bindings to e.g. `textContent` do not get stomped on by\n          // pre-hidden values if `_showHideChildren` were to be called later at\n          // the next render. Clearing `__invalidProps` here ensures\n          // `_showHideChildren`'s call to `__syncHostProperties` no-ops, so\n          // that we don't call `runEffects` more often than necessary.\n          this.__syncInfo = null;\n          this._showHideChildren();\n          changedProps = Object.assign(syncInfo.changedProps, changedProps);\n        }\n        runEffects(changedProps, hasPaths);\n      } else {\n        // Accumulate any values changed while `if` was false, along with the\n        // runEffects method to sync them, so that we can replay them once `if`\n        // becomes true\n        if (this.__instance) {\n          if (!syncInfo) {\n            syncInfo = this.__syncInfo = { runEffects, changedProps: {} };\n          }\n          if (hasPaths) {\n            // Store root object of any paths; this will ensure direct bindings\n            // like [[obj.foo]] bindings run after a `set('obj.foo', v)`, but\n            // note that path notifications like `set('obj.foo.bar', v)` will\n            // not propagate. Since batched path notifications are not\n            // supported, we cannot simply accumulate path notifications. This\n            // is equivalent to the non-fastDomIf case, which stores root(p) in\n            // __invalidProps.\n            for (const p in changedProps) {\n              const rootProp = root(p);\n              syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];\n            }\n          } else {\n            Object.assign(syncInfo.changedProps, changedProps);\n          }\n        }\n      }\n    };\n    // Stamp the template, and set its DocumentFragment to the \"instance\"\n    this.__instance = host._stampTemplate(\n        /** @type {!HTMLTemplateElement} */ (this.__template), templateInfo);\n    wrap(parentNode).insertBefore(this.__instance, this);\n  }\n\n  /**\n   * Run effects for any properties that changed while the `if` was false.\n   *\n   * @return {void}\n   */\n  __syncHostProperties() {\n    const syncInfo = this.__syncInfo;\n    if (syncInfo) {\n      this.__syncInfo = null;\n      syncInfo.runEffects(syncInfo.changedProps, false);\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Remove the instance and any nodes it created.  Uses the `__dataHost`'s\n   * runtime `_removeBoundDom` method.\n   *\n   * @override\n   * @return {void}\n   */\n  __teardownInstance() {\n    const host = this.__dataHost || this;\n    if (this.__instance) {\n      host._removeBoundDom(this.__instance);\n      this.__instance = null;\n      this.__syncInfo = null;\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Shows or hides the template instance top level child nodes. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   *\n   * @override\n   * @return {void}\n   * @protected\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    const hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\n      this.__instance.__hidden = hidden;\n      showHideChildren(hidden, this.__instance.templateInfo.childNodes);\n    }\n    if (!hidden) {\n      this.__syncHostProperties();\n    }\n  }\n}\n\n/**\n * The \"legacy\" implementation of `dom-if`, implemented using `Templatizer`.\n *\n * In this version, `this.__instance` is the `TemplateInstance` returned\n * from the templatized constructor.\n */\nclass DomIfLegacy extends DomIfBase {\n\n  constructor() {\n    super();\n    this.__ctor = null;\n    this.__instance = null;\n    this.__invalidProps = null;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() {\n    return Boolean(this.__instance);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() {\n    return this.__instance.children;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Stamps the template by creating a new instance of the templatized\n   * constructor (which is created lazily if it does not yet exist), and then\n   * inserts its resulting `root` doc fragment into the given `parentNode`.\n   *\n   * @override\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) {\n    // Ensure we have an instance constructor\n    if (!this.__ctor) {\n      this.__ctor = templatize(\n          /** @type {!HTMLTemplateElement} */ (this.__template), this, {\n            // dom-if templatizer instances require `mutable: true`, as\n            // `__syncHostProperties` relies on that behavior to sync objects\n            mutableData: true,\n            /**\n             * @param {string} prop Property to forward\n             * @param {*} value Value of property\n             * @this {DomIfLegacy}\n             */\n            forwardHostProp: function(prop, value) {\n              if (this.__instance) {\n                if (this.if) {\n                  this.__instance.forwardHostProp(prop, value);\n                } else {\n                  // If we have an instance but are squelching host property\n                  // forwarding due to if being false, note the invalidated\n                  // properties so `__syncHostProperties` can sync them the next\n                  // time `if` becomes true\n                  this.__invalidProps =\n                      this.__invalidProps || Object.create(null);\n                  this.__invalidProps[root(prop)] = true;\n                }\n              }\n            }\n          });\n    }\n    // Create and insert the instance\n    this.__instance = new this.__ctor();\n    wrap(parentNode).insertBefore(this.__instance.root, this);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Removes the instance and any nodes it created.\n   *\n   * @override\n   * @return {void}\n   */\n  __teardownInstance() {\n    if (this.__instance) {\n      let c$ = this.__instance.children;\n      if (c$ && c$.length) {\n        // use first child parent, for case when dom-if may have been detached\n        let parent = wrap(c$[0]).parentNode;\n        // Instance children may be disconnected from parents when dom-if\n        // detaches if a tree was innerHTML'ed\n        if (parent) {\n          parent = wrap(parent);\n          for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n            parent.removeChild(n);\n          }\n        }\n      }\n      this.__invalidProps = null;\n      this.__instance = null;\n    }\n  }\n\n  /**\n   * Forwards any properties that changed while the `if` was false into the\n   * template instance and flushes it.\n   *\n   * @return {void}\n   */\n  __syncHostProperties() {\n    let props = this.__invalidProps;\n    if (props) {\n      this.__invalidProps = null;\n      for (let prop in props) {\n        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n      }\n      this.__instance._flushProperties();\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   *\n   * @override\n   * @protected\n   * @return {void}\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    const hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\n      this.__instance.__hidden = hidden;\n      this.__instance._showHideChildren(hidden);\n    }\n    if (!hidden) {\n      this.__syncHostProperties();\n    }\n  }\n}\n\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends DomIfBase\n * @constructor\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\nexport const DomIf = fastDomIf ? DomIfFast : DomIfLegacy;\n\ncustomElements.define(DomIf.is, DomIf);\n"],
  "mappings": "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",
  "names": []
}
