import {
  InputMixin
} from "./chunk-67AQUJJH.js";
import {
  DelegateStateMixin
} from "./chunk-5THRPDE7.js";
import {
  DisabledMixin
} from "./chunk-PVLUQVE7.js";
import {
  isElementFocused
} from "./chunk-7OTQVW5F.js";
import {
  dedupingMixin
} from "./chunk-NCN7ELFS.js";

// node_modules/@vaadin/field-base/src/checked-mixin.js
var CheckedMixin = dedupingMixin(
  (superclass) => class CheckedMixinClass extends DelegateStateMixin(DisabledMixin(InputMixin(superclass))) {
    static get properties() {
      return {
        checked: {
          type: Boolean,
          value: false,
          notify: true,
          reflectToAttribute: true
        }
      };
    }
    static get delegateProps() {
      return [...super.delegateProps, "checked"];
    }
    _onChange(event) {
      const input = event.target;
      this._toggleChecked(input.checked);
      if (!isElementFocused(input)) {
        input.focus();
      }
    }
    _toggleChecked(checked) {
      this.checked = checked;
    }
  }
);

// node_modules/@vaadin/field-base/src/slot-target-controller.js
var SlotTargetController = class {
  constructor(sourceSlot, targetFactory, callback) {
    this.sourceSlot = sourceSlot;
    this.targetFactory = targetFactory;
    this.copyCallback = callback;
    if (sourceSlot) {
      sourceSlot.addEventListener("slotchange", () => {
        if (this.__copying) {
          this.__copying = false;
        } else {
          this.__checkAndCopyNodesToSlotTarget();
        }
      });
    }
  }
  hostConnected() {
    this.__sourceSlotObserver = new MutationObserver(() => this.__checkAndCopyNodesToSlotTarget());
    if (!this.__copying) {
      this.__checkAndCopyNodesToSlotTarget();
    }
  }
  __checkAndCopyNodesToSlotTarget() {
    this.__sourceSlotObserver.disconnect();
    const slotTarget = this.targetFactory();
    if (!slotTarget) {
      return;
    }
    if (this.__slotTargetClones) {
      this.__slotTargetClones.forEach((node) => {
        if (node.parentElement === slotTarget) {
          slotTarget.removeChild(node);
        }
      });
      delete this.__slotTargetClones;
    }
    const nodes = this.sourceSlot.assignedNodes({ flatten: true }).filter((node) => !(node.nodeType === Node.TEXT_NODE && node.textContent.trim() === ""));
    if (nodes.length > 0) {
      slotTarget.innerHTML = "";
      this.__copying = true;
      this.__copyNodesToSlotTarget(nodes, slotTarget);
    }
  }
  __copyNodesToSlotTarget(nodes, slotTarget) {
    this.__slotTargetClones = this.__slotTargetClones || [];
    nodes.forEach((node) => {
      const clone = node.cloneNode(true);
      this.__slotTargetClones.push(clone);
      slotTarget.appendChild(clone);
      this.__sourceSlotObserver.observe(node, {
        attributes: true,
        childList: true,
        subtree: true,
        characterData: true
      });
    });
    if (typeof this.copyCallback === "function") {
      this.copyCallback(nodes);
    }
  }
};

export {
  CheckedMixin,
  SlotTargetController
};
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-KXLK7FPS.js.map
