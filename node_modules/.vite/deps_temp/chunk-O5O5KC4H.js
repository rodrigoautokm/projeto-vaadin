import {
  InputFieldMixin
} from "./chunk-BIVBC2ID.js";
import {
  inputFieldShared as inputFieldShared2
} from "./chunk-KP6A4WLM.js";
import {
  inputFieldShared
} from "./chunk-VED5C5P5.js";
import {
  fieldButton
} from "./chunk-34PCHBPM.js";
import {
  InputController
} from "./chunk-GGAGROPH.js";
import {
  LabelledInputController
} from "./chunk-67AQUJJH.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";

// node_modules/@vaadin/number-field/theme/lumo/vaadin-number-field-styles.js
var numberField = css`
  :host {
    width: 8em;
  }

  :host([has-controls]:not([theme~='align-right'])) ::slotted(input) {
    text-align: center;
  }

  [part$='button'][disabled] {
    opacity: 0.2;
  }

  :host([has-controls]) [part='input-field'] {
    padding: 0;
  }

  [part\$='button'] {
    cursor: pointer;
    font-size: var(--lumo-icon-size-s);
    width: 1.6em;
    height: 1.6em;
  }

  [part\$='button']::before {
    margin-top: 0.3em;
  }

  [part='decrease-button']::before {
    content: var(--lumo-icons-minus);
  }

  [part='increase-button']::before {
    content: var(--lumo-icons-plus);
  }

  /* RTL specific styles */
  :host([dir='rtl']:not([theme~='align-right'])) ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }
`;
registerStyles("vaadin-number-field", [inputFieldShared, fieldButton, numberField], {
  moduleId: "lumo-number-field"
});

// node_modules/@vaadin/number-field/src/vaadin-number-field.js
registerStyles("vaadin-number-field", inputFieldShared2, { moduleId: "vaadin-number-field-styles" });
var NumberField = class extends InputFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-number-field";
  }
  static get template() {
    return html`
      <style>
        :host([readonly]) [part$='button'] {
          pointer-events: none;
        }

        [part='decrease-button']::before {
          content: 'âˆ’';
        }

        [part='increase-button']::before {
          content: '+';
        }

        [part='decrease-button'],
        [part='increase-button'] {
          -webkit-user-select: none;
          -moz-user-select: none;
          user-select: none;
        }

        :host([dir='rtl']) [part='input-field'] {
          direction: ltr;
        }
      </style>

      <div class="vaadin-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <div
            disabled$="[[!_allowed(-1, value, min, max, step)]]"
            part="decrease-button"
            on-click="_decreaseValue"
            on-touchend="_decreaseButtonTouchend"
            hidden$="[[!hasControls]]"
            aria-hidden="true"
            slot="prefix"
          ></div>
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div
            disabled$="[[!_allowed(1, value, min, max, step)]]"
            part="increase-button"
            on-click="_increaseValue"
            on-touchend="_increaseButtonTouchend"
            hidden$="[[!hasControls]]"
            aria-hidden="true"
            slot="suffix"
          ></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
    `;
  }
  static get properties() {
    return {
      hasControls: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      min: {
        type: Number
      },
      max: {
        type: Number
      },
      step: {
        type: Number
      }
    };
  }
  static get observers() {
    return ["_stepChanged(step, inputElement)"];
  }
  static get delegateProps() {
    return [...super.delegateProps, "min", "max"];
  }
  static get constraints() {
    return [...super.constraints, "min", "max", "step"];
  }
  constructor() {
    super();
    this._setType("number");
  }
  get slotStyles() {
    const tag = this.localName;
    return [
      ...super.slotStyles,
      `
        ${tag} input[type="number"]::-webkit-outer-spin-button,
        ${tag} input[type="number"]::-webkit-inner-spin-button {
          -webkit-appearance: none;
          margin: 0;
        }

        ${tag} input[type="number"] {
          -moz-appearance: textfield;
        }

        ${tag}[dir='rtl'] input[type="number"]::placeholder {
          direction: rtl;
        }

        ${tag}[dir='rtl']:not([has-controls]) input[type="number"]::placeholder {
          text-align: left;
        }
      `
    ];
  }
  get clearElement() {
    return this.$.clearButton;
  }
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
  }
  checkValidity() {
    if (this.inputElement && this.inputElement.validity.badInput) {
      return false;
    }
    return super.checkValidity();
  }
  _decreaseButtonTouchend(e) {
    e.preventDefault();
    this._decreaseValue();
  }
  _increaseButtonTouchend(e) {
    e.preventDefault();
    this._increaseValue();
  }
  _decreaseValue() {
    this._incrementValue(-1);
  }
  _increaseValue() {
    this._incrementValue(1);
  }
  _incrementValue(incr) {
    if (this.disabled || this.readonly) {
      return;
    }
    const step = this.step || 1;
    let value = parseFloat(this.value);
    if (!this.value) {
      if (this.min === 0 && incr < 0 || this.max === 0 && incr > 0 || this.max === 0 && this.min === 0) {
        incr = 0;
        value = 0;
      } else if ((this.max == null || this.max >= 0) && (this.min == null || this.min <= 0)) {
        value = 0;
      } else if (this.min > 0) {
        value = this.min;
        if (this.max < 0 && incr < 0) {
          value = this.max;
        }
        incr = 0;
      } else if (this.max < 0) {
        value = this.max;
        if (incr < 0) {
          incr = 0;
        } else if (this._getIncrement(1, value - step) > this.max) {
          value -= 2 * step;
        } else {
          value -= step;
        }
      }
    } else if (value < this.min) {
      incr = 0;
      value = this.min;
    } else if (value > this.max) {
      incr = 0;
      value = this.max;
    }
    const newValue = this._getIncrement(incr, value);
    if (!this.value || incr === 0 || this._incrementIsInsideTheLimits(incr, value)) {
      this._setValue(newValue);
    }
  }
  _setValue(value) {
    this.value = this.inputElement.value = String(parseFloat(value));
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  _getIncrement(incr, currentValue) {
    let step = this.step || 1, min = this.min || 0;
    const multiplier = Math.max(this._getMultiplier(currentValue), this._getMultiplier(step), this._getMultiplier(min));
    step *= multiplier;
    currentValue = Math.round(currentValue * multiplier);
    min *= multiplier;
    const margin = (currentValue - min) % step;
    if (incr > 0) {
      return (currentValue - margin + step) / multiplier;
    } else if (incr < 0) {
      return (currentValue - (margin || step)) / multiplier;
    }
    return currentValue / multiplier;
  }
  _getDecimalCount(number) {
    const s = String(number);
    const i = s.indexOf(".");
    return i === -1 ? 1 : s.length - i - 1;
  }
  _getMultiplier(number) {
    if (!isNaN(number)) {
      return 10 ** this._getDecimalCount(number);
    }
  }
  _incrementIsInsideTheLimits(incr, value) {
    if (incr < 0) {
      return this.min == null || this._getIncrement(incr, value) >= this.min;
    } else if (incr > 0) {
      return this.max == null || this._getIncrement(incr, value) <= this.max;
    }
    return this._getIncrement(incr, value) <= this.max && this._getIncrement(incr, value) >= this.min;
  }
  _allowed(sign) {
    const incr = sign * (this.step || 1);
    const value = parseFloat(this.value);
    return !this.value || !this.disabled && this._incrementIsInsideTheLimits(incr, value);
  }
  _stepChanged(step, inputElement) {
    if (inputElement) {
      inputElement.step = step || "any";
    }
  }
  _valueChanged(newVal, oldVal) {
    if (newVal && isNaN(parseFloat(newVal))) {
      this.value = "";
    } else if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    super._valueChanged(this.value, oldVal);
  }
  _onKeyDown(event) {
    if (event.key === "ArrowUp") {
      event.preventDefault();
      this._increaseValue();
    } else if (event.key === "ArrowDown") {
      event.preventDefault();
      this._decreaseValue();
    }
    super._onKeyDown(event);
  }
};
customElements.define(NumberField.is, NumberField);

export {
  NumberField
};
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-O5O5KC4H.js.map
