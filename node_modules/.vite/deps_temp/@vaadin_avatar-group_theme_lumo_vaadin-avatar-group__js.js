import {
  ResizeMixin
} from "./chunk-C2K2GOEG.js";
import {
  announce
} from "./chunk-BXCHFJHA.js";
import "./chunk-S3HOX4GU.js";
import "./chunk-QJ5Y7LU7.js";
import {
  ListBox
} from "./chunk-H44FQUHM.js";
import "./chunk-QAHWQ2NB.js";
import "./chunk-Q6GVJPMX.js";
import {
  menuOverlayCore
} from "./chunk-E2XIUAPG.js";
import {
  PositionMixin
} from "./chunk-BTTUSTOZ.js";
import {
  OverlayElement,
  overlay
} from "./chunk-LH2VMHWZ.js";
import "./chunk-2FVEPLVQ.js";
import "./chunk-YOCIS3UP.js";
import "./chunk-DKDV73LI.js";
import "./chunk-JJXNSZ6B.js";
import "./chunk-VUBXZXWD.js";
import "./chunk-WE3EBNE7.js";
import "./chunk-XAUSENF3.js";
import "./chunk-SG4ORNH2.js";
import {
  afterNextRender
} from "./chunk-UMTV3SEQ.js";
import {
  calculateSplices
} from "./chunk-4V7CPLV2.js";
import "./chunk-IOVQFHDT.js";
import "./chunk-FSHK2P6W.js";
import "./chunk-MMTYJQZF.js";
import "./chunk-LATBNNHW.js";
import "./chunk-45DBWWZS.js";
import "./chunk-ZB6KQ55W.js";
import "./chunk-PVLUQVE7.js";
import "./chunk-TXOUNVRU.js";
import "./chunk-ZCT3SKJI.js";
import "./chunk-DALKQVZ5.js";
import "./chunk-ZU2IWMPM.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import "./chunk-7OTQVW5F.js";
import "./chunk-D7TE3X7L.js";
import "./chunk-7S7VFRNQ.js";
import "./chunk-ZYZHRUSQ.js";
import "./chunk-2EAS4FPS.js";
import "./chunk-VUWTYCVF.js";
import "./chunk-RTIK5DCO.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import "./chunk-CQH3N2QY.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";
import "./chunk-A5QYNKPK.js";
import "./chunk-NCN7ELFS.js";
import "./chunk-CJPRR7ZF.js";

// node_modules/@vaadin/avatar-group/theme/lumo/vaadin-avatar-group-styles.js
registerStyles(
  "vaadin-avatar-group",
  css`
    :host {
      --vaadin-avatar-size: var(--lumo-size-m);
    }

    :host([theme~='xlarge']) {
      --vaadin-avatar-group-overlap: 12px;
      --vaadin-avatar-group-overlap-border: 3px;
      --vaadin-avatar-size: var(--lumo-size-xl);
    }

    :host([theme~='large']) {
      --vaadin-avatar-group-overlap: 10px;
      --vaadin-avatar-group-overlap-border: 3px;
      --vaadin-avatar-size: var(--lumo-size-l);
    }

    :host([theme~='small']) {
      --vaadin-avatar-group-overlap: 6px;
      --vaadin-avatar-group-overlap-border: 2px;
      --vaadin-avatar-size: var(--lumo-size-s);
    }

    :host([theme~='xsmall']) {
      --vaadin-avatar-group-overlap: 4px;
      --vaadin-avatar-group-overlap-border: 2px;
      --vaadin-avatar-size: var(--lumo-size-xs);
    }
  `,
  { moduleId: "lumo-avatar-group" }
);
var avatarGroupOverlay = css`
  :host {
    --_lumo-list-box-item-selected-icon-display: none;
    --_lumo-list-box-item-padding-left: calc(var(--lumo-space-m) + var(--lumo-border-radius-m) / 4);
  }

  [part='overlay'] {
    outline: none;
  }
`;
registerStyles("vaadin-avatar-group-overlay", [overlay, menuOverlayCore, avatarGroupOverlay], {
  moduleId: "lumo-avatar-group-overlay"
});
registerStyles(
  "vaadin-avatar-group-list-box",
  css`
    [part='items'] ::slotted(vaadin-item[theme='avatar-group-item']) {
      padding: var(--lumo-space-xs);
      padding-right: var(--lumo-space-m);
    }

    :host([dir='rtl']) [part='items'] ::slotted(vaadin-item[theme='avatar-group-item']) {
      padding: var(--lumo-space-xs);
      padding-left: var(--lumo-space-m);
    }
  `,
  { moduleId: "lumo-avatar-group-list-box" }
);
registerStyles(
  "vaadin-item",
  css`
    :host([theme='avatar-group-item']) [part='content'] {
      display: flex;
      align-items: center;
    }

    :host([theme='avatar-group-item']) ::slotted(vaadin-avatar) {
      width: var(--lumo-size-xs);
      height: var(--lumo-size-xs);
    }

    :host([theme='avatar-group-item']:not([dir='rtl'])) ::slotted(vaadin-avatar) {
      margin-right: var(--lumo-space-s);
    }

    :host([theme='avatar-group-item'][dir='rtl']) ::slotted(vaadin-avatar) {
      margin-left: var(--lumo-space-s);
    }
  `,
  { moduleId: "lumo-avatar-group-item" }
);

// node_modules/@vaadin/avatar-group/src/vaadin-avatar-group-list-box.js
var AvatarGroupListBox = class extends ListBox {
  static get is() {
    return "vaadin-avatar-group-list-box";
  }
};
customElements.define(AvatarGroupListBox.is, AvatarGroupListBox);

// node_modules/@vaadin/avatar-group/src/vaadin-avatar-group-overlay.js
var AvatarGroupOverlay = class extends PositionMixin(OverlayElement) {
  static get is() {
    return "vaadin-avatar-group-overlay";
  }
};
customElements.define(AvatarGroupOverlay.is, AvatarGroupOverlay);

// node_modules/@vaadin/avatar-group/src/vaadin-avatar-group.js
var MINIMUM_DISPLAYED_AVATARS = 2;
var AvatarGroup = class extends ResizeMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          width: 100%; /* prevent collapsing inside non-stretching column flex */
          --vaadin-avatar-group-overlap: 8px;
          --vaadin-avatar-group-overlap-border: 2px;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='container'] {
          display: flex;
          position: relative;
          width: 100%;
          flex-wrap: nowrap;
        }

        [part='avatar']:not(:first-child) {
          -webkit-mask-image: url('data:image/svg+xml;utf8,<svg viewBox=%220 0 300 300%22 fill=%22none%22 xmlns=%22http://www.w3.org/2000/svg%22><path fill-rule=%22evenodd%22 clip-rule=%22evenodd%22 d=%22M300 0H0V300H300V0ZM150 200C177.614 200 200 177.614 200 150C200 122.386 177.614 100 150 100C122.386 100 100 122.386 100 150C100 177.614 122.386 200 150 200Z%22 fill=%22black%22/></svg>');
          mask-image: url('data:image/svg+xml;utf8,<svg viewBox=%220 0 300 300%22 fill=%22none%22 xmlns=%22http://www.w3.org/2000/svg%22><path fill-rule=%22evenodd%22 clip-rule=%22evenodd%22 d=%22M300 0H0V300H300V0ZM150 200C177.614 200 200 177.614 200 150C200 122.386 177.614 100 150 100C122.386 100 100 122.386 100 150C100 177.614 122.386 200 150 200Z%22 fill=%22black%22/></svg>');
          -webkit-mask-size: calc(
            300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6
          );
          mask-size: calc(
            300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6
          );
        }

        [part='avatar']:not([dir='rtl']):not(:first-child) {
          margin-left: calc(var(--vaadin-avatar-group-overlap) * -1 - var(--vaadin-avatar-outline-width));
          -webkit-mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
          mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
        }

        [part='avatar'][dir='rtl']:not(:first-child) {
          margin-right: calc(var(--vaadin-avatar-group-overlap) * -1);
          -webkit-mask-position: calc(
            50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width)
          );
          mask-position: calc(
            50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width)
          );
        }
      </style>
      <div id="container" part="container">
        <template id="items" is="dom-repeat" items="[[__computeItems(items.*, __itemsInView, maxItemsVisible)]]">
          <vaadin-avatar
            name="[[item.name]]"
            abbr="[[item.abbr]]"
            img="[[item.img]]"
            part="avatar"
            theme$="[[_theme]]"
            i18n="[[i18n]]"
            color-index="[[item.colorIndex]]"
          ></vaadin-avatar>
        </template>
        <vaadin-avatar
          id="overflow"
          part="avatar"
          hidden$="[[__computeMoreHidden(items.length, __itemsInView, __maxReached)]]"
          abbr="[[__computeMore(items.length, __itemsInView, maxItemsVisible)]]"
          theme$="[[_theme]]"
          on-click="_onOverflowClick"
          on-keydown="_onOverflowKeyDown"
          aria-haspopup="listbox"
        ></vaadin-avatar>
      </div>
      <vaadin-avatar-group-overlay
        id="overlay"
        opened="{{_opened}}"
        no-vertical-overlap
        on-vaadin-overlay-close="_onVaadinOverlayClose"
      >
        <template>
          <vaadin-avatar-group-list-box on-keydown="_onListKeyDown">
            <template is="dom-repeat" items="[[__computeExtraItems(items.*, __itemsInView, maxItemsVisible)]]">
              <vaadin-item theme="avatar-group-item" role="option">
                <vaadin-avatar
                  name="[[item.name]]"
                  abbr="[[item.abbr]]"
                  img="[[item.img]]"
                  i18n="[[i18n]]"
                  part="avatar"
                  theme$="[[_theme]]"
                  color-index="[[item.colorIndex]]"
                  tabindex="-1"
                  aria-hidden="true"
                ></vaadin-avatar>
                [[item.name]]
              </vaadin-item>
            </template>
          </vaadin-avatar-group-list-box>
        </template>
      </vaadin-avatar-group-overlay>
    `;
  }
  static get is() {
    return "vaadin-avatar-group";
  }
  static get properties() {
    return {
      items: {
        type: Array
      },
      maxItemsVisible: {
        type: Number
      },
      i18n: {
        type: Object,
        value: () => {
          return {
            anonymous: "anonymous",
            activeUsers: {
              one: "Currently one active user",
              many: "Currently {count} active users"
            },
            joined: "{user} joined",
            left: "{user} left"
          };
        }
      },
      __maxReached: {
        type: Boolean,
        computed: "__computeMaxReached(items.length, maxItemsVisible)"
      },
      __itemsInView: {
        type: Number,
        value: null
      },
      _opened: {
        type: Boolean,
        observer: "__openedChanged",
        value: false
      }
    };
  }
  static get observers() {
    return [
      "__computeMoreTitle(items.length, __itemsInView, maxItemsVisible)",
      "__itemsChanged(items.splices, items.*)",
      "__i18nItemsChanged(i18n.*, items.length)"
    ];
  }
  ready() {
    super.ready();
    this._overlayElement = this.shadowRoot.querySelector("vaadin-avatar-group-overlay");
    this._overlayElement.positionTarget = this.$.overflow;
    afterNextRender(this, () => {
      this.__setItemsInView();
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this._opened = false;
  }
  get _avatars() {
    return this.shadowRoot.querySelectorAll("vaadin-avatar");
  }
  __getMessage(user, action) {
    return action.replace("{user}", user.name || user.abbr || this.i18n.anonymous);
  }
  _onOverflowClick(e) {
    e.stopPropagation();
    if (this._opened) {
      this.$.overlay.close();
    } else if (!e.defaultPrevented) {
      this._opened = true;
    }
  }
  _onOverflowKeyDown(e) {
    if (!this._opened) {
      if (/^(Enter|SpaceBar|\s)$/.test(e.key)) {
        e.preventDefault();
        this._opened = true;
      }
    }
  }
  _onListKeyDown(event) {
    if (event.key === "Escape" || event.key === "Esc" || /^(Tab)$/.test(event.key)) {
      this._opened = false;
    }
  }
  _onResize() {
    this.__setItemsInView();
  }
  _onVaadinOverlayClose(e) {
    if (e.detail.sourceEvent && e.detail.sourceEvent.composedPath().includes(this)) {
      e.preventDefault();
    }
  }
  __computeItems(arr, itemsInView, maxItemsVisible) {
    const items = arr.base || [];
    const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
    return limit ? items.slice(0, limit) : items;
  }
  __computeExtraItems(arr, itemsInView, maxItemsVisible) {
    const items = arr.base || [];
    const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
    return limit ? items.slice(limit) : items;
  }
  __computeMaxReached(items, maxItemsVisible) {
    return maxItemsVisible != null && items > this.__getMax(maxItemsVisible);
  }
  __computeMore(items, itemsInView, maxItemsVisible) {
    return `+${items - this.__getLimit(items, itemsInView, maxItemsVisible)}`;
  }
  __computeMoreHidden(items, itemsInView, maxReached) {
    return !maxReached && !(itemsInView && itemsInView < items);
  }
  __computeMoreTitle(items, itemsInView, maxItemsVisible) {
    const limit = this.__getLimit(items, itemsInView, maxItemsVisible);
    if (limit == null) {
      return;
    }
    const result = [];
    for (let i = limit; i < items; i++) {
      const item = this.items[i];
      if (item) {
        result.push(item.name || item.abbr || "anonymous");
      }
    }
    this.$.overflow.setAttribute("title", result.join("\n"));
  }
  __getLimit(items, itemsInView, maxItemsVisible) {
    let limit = null;
    const adjustedMax = this.__getMax(maxItemsVisible);
    if (maxItemsVisible != null && adjustedMax < items) {
      limit = adjustedMax - 1;
    } else if (itemsInView && itemsInView < items) {
      limit = itemsInView;
    }
    return Math.min(limit, this.__calculateAvatarsFitWidth());
  }
  __getMax(maxItemsVisible) {
    return Math.max(maxItemsVisible, MINIMUM_DISPLAYED_AVATARS);
  }
  __itemsChanged(splices, itemsChange) {
    const items = itemsChange.base;
    this.$.items.render();
    this.__setItemsInView();
    if (splices && Array.isArray(splices.indexSplices)) {
      splices.indexSplices.forEach((mutation) => {
        this.__announceItemsChange(items, mutation);
      });
    } else if (Array.isArray(items) && Array.isArray(this.__oldItems)) {
      const diff = calculateSplices(items, this.__oldItems);
      diff.forEach((mutation) => {
        this.__announceItemsChange(items, mutation);
      });
    }
    this.__oldItems = items;
  }
  __announceItemsChange(items, mutation) {
    const { addedCount, index, removed } = mutation;
    let addedMsg = [];
    let removedMsg = [];
    if (addedCount) {
      addedMsg = items.slice(index, index + addedCount).map((user) => this.__getMessage(user, this.i18n.joined || "{user} joined"));
    }
    if (removed) {
      removedMsg = removed.map((user) => this.__getMessage(user, this.i18n.left || "{user} left"));
    }
    const messages = removedMsg.concat(addedMsg);
    if (messages.length > 0) {
      announce(messages.join(", "));
    }
  }
  __i18nItemsChanged(i18n, items) {
    const { base } = i18n;
    if (base && base.activeUsers) {
      const field = items === 1 ? "one" : "many";
      if (base.activeUsers[field]) {
        this.setAttribute("aria-label", base.activeUsers[field].replace("{count}", items || 0));
      }
    }
  }
  __openedChanged(opened, wasOpened) {
    if (opened) {
      if (!this._menuElement) {
        this._menuElement = this._overlayElement.content.querySelector("vaadin-avatar-group-list-box");
        this._menuElement.setAttribute("role", "listbox");
      }
      this._openedWithFocusRing = this.$.overflow.hasAttribute("focus-ring");
      const avatars = this._menuElement.querySelectorAll("vaadin-avatar");
      avatars.forEach((avatar) => avatar.removeAttribute("title"));
      this._menuElement.focus();
    } else if (wasOpened) {
      this.$.overflow.focus();
      if (this._openedWithFocusRing) {
        this.$.overflow.setAttribute("focus-ring", "");
      }
    }
    this.$.overflow.setAttribute("aria-expanded", opened === true);
  }
  __setItemsInView() {
    const avatars = this._avatars;
    const items = this.items;
    if (!items || !avatars || avatars.length < 3) {
      return;
    }
    let result = this.__calculateAvatarsFitWidth();
    if (result === items.length - 1) {
      result = items.length;
    }
    if (result >= items.length && this._opened) {
      this.$.overlay.close();
      this.$.overlay._flushAnimation("closing");
    }
    this.__itemsInView = result;
  }
  __calculateAvatarsFitWidth() {
    if (!this.shadowRoot || this._avatars.length < MINIMUM_DISPLAYED_AVATARS) {
      return MINIMUM_DISPLAYED_AVATARS;
    }
    const avatars = this._avatars;
    const avatarWidth = avatars[0].clientWidth;
    const { marginLeft, marginRight } = getComputedStyle(avatars[1]);
    const offset = this.getAttribute("dir") === "rtl" ? parseInt(marginRight, 0) - parseInt(marginLeft, 0) : parseInt(marginLeft, 0) - parseInt(marginRight, 0);
    return Math.floor((this.$.container.offsetWidth - avatarWidth) / (avatarWidth + offset));
  }
};
customElements.define(AvatarGroup.is, AvatarGroup);
/**
 * @license
 * Copyright (c) 2020 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_avatar-group_theme_lumo_vaadin-avatar-group__js.js.map
