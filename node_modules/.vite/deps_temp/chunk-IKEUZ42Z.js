import {
  MEDIA_MATCH,
  MIXIN_MATCH,
  VAR_ASSIGN,
  cssBuild,
  detectMixin,
  disableRuntime,
  getComputedStyleValue,
  nativeCssVariables,
  nativeShadow,
  updateNativeProperties
} from "./chunk-GNFLOEUQ.js";
import {
  findObservedAttributesGetter
} from "./chunk-7ZAE2LQL.js";
import {
  hideElementsGlobally
} from "./chunk-DKDV73LI.js";
import {
  Debouncer
} from "./chunk-JJXNSZ6B.js";
import {
  MutableData,
  OptionalMutableData,
  modelForElement,
  templatize
} from "./chunk-VUBXZXWD.js";
import {
  FlattenedNodesObserver,
  calculateSplices
} from "./chunk-4V7CPLV2.js";
import {
  ElementMixin,
  PolymerElement,
  PropertyAccessors,
  PropertyEffects,
  builtCSS,
  get,
  register,
  wrap
} from "./chunk-ZKSNVHJS.js";
import {
  cancelSyntheticClickEvents,
  legacyNoObservedAttributes,
  legacyOptimizations,
  passiveTouchGestures,
  strictTemplatePolicy
} from "./chunk-A5QYNKPK.js";
import {
  dedupingMixin,
  microTask,
  timeOut
} from "./chunk-NCN7ELFS.js";

// node_modules/@polymer/polymer/lib/legacy/polymer.dom.js
var p = Element.prototype;
var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
var matchesSelector = function(node, selector) {
  return normalizedMatchesSelector.call(node, selector);
};
var DomApiNative = class {
  constructor(node) {
    if (window["ShadyDOM"] && window["ShadyDOM"]["inUse"]) {
      window["ShadyDOM"]["patch"](node);
    }
    this.node = node;
  }
  observeNodes(callback) {
    return new FlattenedNodesObserver(
      this.node,
      callback
    );
  }
  unobserveNodes(observerHandle) {
    observerHandle.disconnect();
  }
  notifyObserver() {
  }
  deepContains(node) {
    if (wrap(this.node).contains(node)) {
      return true;
    }
    let n = node;
    let doc = node.ownerDocument;
    while (n && n !== doc && n !== this.node) {
      n = wrap(n).parentNode || wrap(n).host;
    }
    return n === this.node;
  }
  getOwnerRoot() {
    return wrap(this.node).getRootNode();
  }
  getDistributedNodes() {
    return this.node.localName === "slot" ? wrap(this.node).assignedNodes({ flatten: true }) : [];
  }
  getDestinationInsertionPoints() {
    let ip$ = [];
    let n = wrap(this.node).assignedSlot;
    while (n) {
      ip$.push(n);
      n = wrap(n).assignedSlot;
    }
    return ip$;
  }
  importNode(node, deep) {
    let doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
    return wrap(doc).importNode(node, deep);
  }
  getEffectiveChildNodes() {
    return FlattenedNodesObserver.getFlattenedNodes(
      this.node
    );
  }
  queryDistributedElements(selector) {
    let c$ = this.getEffectiveChildNodes();
    let list = [];
    for (let i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
      if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
        list.push(c);
      }
    }
    return list;
  }
  get activeElement() {
    let node = this.node;
    return node._activeElement !== void 0 ? node._activeElement : node.activeElement;
  }
};
function forwardMethods(proto, methods) {
  for (let i = 0; i < methods.length; i++) {
    let method = methods[i];
    proto[method] = function() {
      return this.node[method].apply(this.node, arguments);
    };
  }
}
function forwardReadOnlyProperties(proto, properties) {
  for (let i = 0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        const domApi = this;
        return domApi.node[name];
      },
      configurable: true
    });
  }
}
function forwardProperties(proto, properties) {
  for (let i = 0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        return this.node[name];
      },
      set: function(value) {
        this.node[name] = value;
      },
      configurable: true
    });
  }
}
var EventApi = class {
  constructor(event) {
    this.event = event;
  }
  get rootTarget() {
    return this.path[0];
  }
  get localTarget() {
    return this.event.target;
  }
  get path() {
    return this.event.composedPath();
  }
};
DomApiNative.prototype.cloneNode;
DomApiNative.prototype.appendChild;
DomApiNative.prototype.insertBefore;
DomApiNative.prototype.removeChild;
DomApiNative.prototype.replaceChild;
DomApiNative.prototype.setAttribute;
DomApiNative.prototype.removeAttribute;
DomApiNative.prototype.querySelector;
DomApiNative.prototype.querySelectorAll;
DomApiNative.prototype.parentNode;
DomApiNative.prototype.firstChild;
DomApiNative.prototype.lastChild;
DomApiNative.prototype.nextSibling;
DomApiNative.prototype.previousSibling;
DomApiNative.prototype.firstElementChild;
DomApiNative.prototype.lastElementChild;
DomApiNative.prototype.nextElementSibling;
DomApiNative.prototype.previousElementSibling;
DomApiNative.prototype.childNodes;
DomApiNative.prototype.children;
DomApiNative.prototype.classList;
DomApiNative.prototype.textContent;
DomApiNative.prototype.innerHTML;
var DomApiImpl = DomApiNative;
if (window["ShadyDOM"] && window["ShadyDOM"]["inUse"] && window["ShadyDOM"]["noPatch"] && window["ShadyDOM"]["Wrapper"]) {
  class Wrapper extends window["ShadyDOM"]["Wrapper"] {
  }
  Object.getOwnPropertyNames(DomApiNative.prototype).forEach((prop) => {
    if (prop != "activeElement") {
      Wrapper.prototype[prop] = DomApiNative.prototype[prop];
    }
  });
  forwardReadOnlyProperties(Wrapper.prototype, [
    "classList"
  ]);
  DomApiImpl = Wrapper;
  Object.defineProperties(EventApi.prototype, {
    localTarget: {
      get() {
        const current = this.event.currentTarget;
        const currentRoot = current && dom(current).getOwnerRoot();
        const p$ = this.path;
        for (let i = 0; i < p$.length; i++) {
          const e = p$[i];
          if (dom(e).getOwnerRoot() === currentRoot) {
            return e;
          }
        }
      },
      configurable: true
    },
    path: {
      get() {
        return window["ShadyDOM"]["composedPath"](this.event);
      },
      configurable: true
    }
  });
} else {
  forwardMethods(DomApiNative.prototype, [
    "cloneNode",
    "appendChild",
    "insertBefore",
    "removeChild",
    "replaceChild",
    "setAttribute",
    "removeAttribute",
    "querySelector",
    "querySelectorAll",
    "attachShadow"
  ]);
  forwardReadOnlyProperties(DomApiNative.prototype, [
    "parentNode",
    "firstChild",
    "lastChild",
    "nextSibling",
    "previousSibling",
    "firstElementChild",
    "lastElementChild",
    "nextElementSibling",
    "previousElementSibling",
    "childNodes",
    "children",
    "classList",
    "shadowRoot"
  ]);
  forwardProperties(DomApiNative.prototype, [
    "textContent",
    "innerHTML",
    "className"
  ]);
}
var dom = function(obj) {
  obj = obj || document;
  if (obj instanceof DomApiImpl) {
    return obj;
  }
  if (obj instanceof EventApi) {
    return obj;
  }
  let helper = obj["__domApi"];
  if (!helper) {
    if (obj instanceof Event) {
      helper = new EventApi(obj);
    } else {
      helper = new DomApiImpl(obj);
    }
    obj["__domApi"] = helper;
  }
  return helper;
};

// node_modules/@webcomponents/shadycss/src/css-parse.js
var StyleNode = class {
  constructor() {
    this["start"] = 0;
    this["end"] = 0;
    this["previous"] = null;
    this["parent"] = null;
    this["rules"] = null;
    this["parsedCssText"] = "";
    this["cssText"] = "";
    this["atRule"] = false;
    this["type"] = 0;
    this["keyframesName"] = "";
    this["selector"] = "";
    this["parsedSelector"] = "";
  }
};
function parse(text) {
  text = clean(text);
  return parseCss(lex(text), text);
}
function clean(cssText) {
  return cssText.replace(RX.comments, "").replace(RX.port, "");
}
function lex(text) {
  let root = new StyleNode();
  root["start"] = 0;
  root["end"] = text.length;
  let n = root;
  for (let i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n["rules"]) {
        n["rules"] = [];
      }
      let p2 = n;
      let previous = p2["rules"][p2["rules"].length - 1] || null;
      n = new StyleNode();
      n["start"] = i + 1;
      n["parent"] = p2;
      n["previous"] = previous;
      p2["rules"].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n["end"] = i + 1;
      n = n["parent"] || root;
    }
  }
  return root;
}
function parseCss(node, text) {
  let t = text.substring(node["start"], node["end"] - 1);
  node["parsedCssText"] = node["cssText"] = t.trim();
  if (node["parent"]) {
    let ss = node["previous"] ? node["previous"]["end"] : node["parent"]["start"];
    t = text.substring(ss, node["start"] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, " ");
    t = t.substring(t.lastIndexOf(";") + 1);
    let s = node["parsedSelector"] = node["selector"] = t.trim();
    node["atRule"] = s.indexOf(AT_START) === 0;
    if (node["atRule"]) {
      if (s.indexOf(MEDIA_START) === 0) {
        node["type"] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node["type"] = types.KEYFRAMES_RULE;
        node["keyframesName"] = node["selector"].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node["type"] = types.MIXIN_RULE;
      } else {
        node["type"] = types.STYLE_RULE;
      }
    }
  }
  let r$ = node["rules"];
  if (r$) {
    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }
  return node;
}
function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
    let code = arguments[1], repeat = 6 - code.length;
    while (repeat--) {
      code = "0" + code;
    }
    return "\\" + code;
  });
}
function stringify(node, preserveProperties, text = "") {
  let cssText = "";
  if (node["cssText"] || node["rules"]) {
    let r$ = node["rules"];
    if (r$ && !_hasMixinRules(r$)) {
      for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node["cssText"] : removeCustomProps(node["cssText"]);
      cssText = cssText.trim();
      if (cssText) {
        cssText = "  " + cssText + "\n";
      }
    }
  }
  if (cssText) {
    if (node["selector"]) {
      text += node["selector"] + " " + OPEN_BRACE + "\n";
    }
    text += cssText;
    if (node["selector"]) {
      text += CLOSE_BRACE + "\n\n";
    }
  }
  return text;
}
function _hasMixinRules(rules) {
  let r = rules[0];
  return Boolean(r) && Boolean(r["selector"]) && r["selector"].indexOf(VAR_START) === 0;
}
function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}
function removeCustomPropAssignment(cssText) {
  return cssText.replace(RX.customProp, "").replace(RX.mixinProp, "");
}
function removeCustomPropApply(cssText) {
  return cssText.replace(RX.mixinApply, "").replace(RX.varApply, "");
}
var types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1e3
};
var OPEN_BRACE = "{";
var CLOSE_BRACE = "}";
var RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
};
var VAR_START = "--";
var MEDIA_START = "@media";
var AT_START = "@";

// node_modules/@webcomponents/shadycss/src/unscoped-style-handler.js
var styleTextSet = /* @__PURE__ */ new Set();
var scopingAttribute = "shady-unscoped";
function processUnscopedStyle(style) {
  const text = style.textContent;
  if (!styleTextSet.has(text)) {
    styleTextSet.add(text);
    const newStyle = document.createElement("style");
    newStyle.setAttribute("shady-unscoped", "");
    newStyle.textContent = text;
    document.head.appendChild(newStyle);
  }
}
function isUnscopedStyle(style) {
  return style.hasAttribute(scopingAttribute);
}

// node_modules/@webcomponents/shadycss/src/style-util.js
function toCssText(rules, callback) {
  if (!rules) {
    return "";
  }
  if (typeof rules === "string") {
    rules = parse(rules);
  }
  if (callback) {
    forEachRule(rules, callback);
  }
  return stringify(rules, nativeCssVariables);
}
function rulesForStyle(style) {
  if (!style["__cssRules"] && style.textContent) {
    style["__cssRules"] = parse(style.textContent);
  }
  return style["__cssRules"] || null;
}
function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }
  let skipRules = false;
  let type = node["type"];
  if (onlyActiveRules) {
    if (type === types.MEDIA_RULE) {
      let matchMedia = node["selector"].match(MEDIA_MATCH);
      if (matchMedia) {
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }
  if (type === types.STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback && type === types.KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === types.MIXIN_RULE) {
    skipRules = true;
  }
  let r$ = node["rules"];
  if (r$ && !skipRules) {
    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
}
function findMatchingParen(text, start) {
  let level = 0;
  for (let i = start, l = text.length; i < l; i++) {
    if (text[i] === "(") {
      level++;
    } else if (text[i] === ")") {
      if (--level === 0) {
        return i;
      }
    }
  }
  return -1;
}
function processVariableAndFallback(str, callback) {
  let start = str.indexOf("var(");
  if (start === -1) {
    return callback(str, "", "", "");
  }
  let end = findMatchingParen(str, start + 3);
  let inner = str.substring(start + 4, end);
  let prefix = str.substring(0, start);
  let suffix = processVariableAndFallback(str.substring(end + 1), callback);
  let comma = inner.indexOf(",");
  if (comma === -1) {
    return callback(prefix, inner.trim(), "", suffix);
  }
  let value = inner.substring(0, comma).trim();
  let fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}
var wrap2 = window["ShadyDOM"] && window["ShadyDOM"]["wrap"] || ((node) => node);
function getIsExtends(element) {
  let localName = element["localName"];
  let is = "", typeExtension = "";
  if (localName) {
    if (localName.indexOf("-") > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = element.getAttribute && element.getAttribute("is") || "";
    }
  } else {
    is = element.is;
    typeExtension = element.extends;
  }
  return { is, typeExtension };
}
function gatherStyleText(element) {
  const styleTextParts = [];
  const styles = element.querySelectorAll(
    "style"
  );
  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];
    if (isUnscopedStyle(style)) {
      if (!nativeShadow) {
        processUnscopedStyle(style);
        style.parentNode.removeChild(style);
      }
    } else {
      styleTextParts.push(style.textContent);
      style.parentNode.removeChild(style);
    }
  }
  return styleTextParts.join("").trim();
}
var CSS_BUILD_ATTR = "css-build";
function getCssBuild(element) {
  if (cssBuild !== void 0) {
    return cssBuild;
  }
  if (element.__cssBuild === void 0) {
    const attrValue = element.getAttribute(CSS_BUILD_ATTR);
    if (attrValue) {
      element.__cssBuild = attrValue;
    } else {
      const buildComment = getBuildComment(element);
      if (buildComment !== "") {
        removeBuildComment(element);
      }
      element.__cssBuild = buildComment;
    }
  }
  return element.__cssBuild || "";
}
function elementHasBuiltCss(element) {
  return getCssBuild(element) !== "";
}
function getBuildComment(element) {
  const buildComment = element.localName === "template" ? element.content.firstChild : element.firstChild;
  if (buildComment instanceof Comment) {
    const commentParts = buildComment.textContent.trim().split(":");
    if (commentParts[0] === CSS_BUILD_ATTR) {
      return commentParts[1];
    }
  }
  return "";
}
function removeBuildComment(element) {
  const buildComment = element.localName === "template" ? element.content.firstChild : element.firstChild;
  buildComment.parentNode.removeChild(buildComment);
}

// node_modules/@webcomponents/shadycss/src/apply-shim.js
var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
var IMPORTANT = /\s*!important/;
var MIXIN_VAR_SEP = "_-_";
var MixinMap = class {
  constructor() {
    this._map = {};
  }
  set(name, props) {
    name = name.trim();
    this._map[name] = {
      properties: props,
      dependants: {}
    };
  }
  get(name) {
    name = name.trim();
    return this._map[name] || null;
  }
};
var invalidCallback = null;
var ApplyShim = class {
  constructor() {
    this._currentElement = null;
    this._measureElement = null;
    this._map = new MixinMap();
  }
  detectMixin(cssText) {
    return detectMixin(cssText);
  }
  gatherStyles(template) {
    const styleText = gatherStyleText(template.content);
    if (styleText) {
      const style = document.createElement(
        "style"
      );
      style.textContent = styleText;
      template.content.insertBefore(style, template.content.firstChild);
      return style;
    }
    return null;
  }
  transformTemplate(template, elementName) {
    if (template._gatheredStyle === void 0) {
      template._gatheredStyle = this.gatherStyles(template);
    }
    const style = template._gatheredStyle;
    return style ? this.transformStyle(style, elementName) : null;
  }
  transformStyle(style, elementName = "") {
    let ast = rulesForStyle(style);
    this.transformRules(ast, elementName);
    style.textContent = toCssText(ast);
    return ast;
  }
  transformCustomStyle(style) {
    let ast = rulesForStyle(style);
    forEachRule(ast, (rule) => {
      if (rule["selector"] === ":root") {
        rule["selector"] = "html";
      }
      this.transformRule(rule);
    });
    style.textContent = toCssText(ast);
    return ast;
  }
  transformRules(rules, elementName) {
    this._currentElement = elementName;
    forEachRule(rules, (r) => {
      this.transformRule(r);
    });
    this._currentElement = null;
  }
  transformRule(rule) {
    rule["cssText"] = this.transformCssText(rule["parsedCssText"], rule);
    if (rule["selector"] === ":root") {
      rule["selector"] = ":host > *";
    }
  }
  transformCssText(cssText, rule) {
    cssText = cssText.replace(
      VAR_ASSIGN,
      (matchText, propertyName, valueProperty, valueMixin) => this._produceCssProperties(
        matchText,
        propertyName,
        valueProperty,
        valueMixin,
        rule
      )
    );
    return this._consumeCssProperties(cssText, rule);
  }
  _getInitialValueForProperty(property) {
    if (!this._measureElement) {
      this._measureElement = document.createElement(
        "meta"
      );
      this._measureElement.setAttribute("apply-shim-measure", "");
      this._measureElement.style.all = "initial";
      document.head.appendChild(this._measureElement);
    }
    return window.getComputedStyle(this._measureElement).getPropertyValue(property);
  }
  _fallbacksFromPreviousRules(startRule) {
    let topRule = startRule;
    while (topRule["parent"]) {
      topRule = topRule["parent"];
    }
    const fallbacks = {};
    let seenStartRule = false;
    forEachRule(topRule, (r) => {
      seenStartRule = seenStartRule || r === startRule;
      if (seenStartRule) {
        return;
      }
      if (r["selector"] === startRule["selector"]) {
        Object.assign(fallbacks, this._cssTextToMap(r["parsedCssText"]));
      }
    });
    return fallbacks;
  }
  _consumeCssProperties(text, rule) {
    let m = null;
    while (m = MIXIN_MATCH.exec(text)) {
      let matchText = m[0];
      let mixinName = m[1];
      let idx = m.index;
      let applyPos = idx + matchText.indexOf("@apply");
      let afterApplyPos = idx + matchText.length;
      let textBeforeApply = text.slice(0, applyPos);
      let textAfterApply = text.slice(afterApplyPos);
      let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};
      Object.assign(defaults, this._cssTextToMap(textBeforeApply));
      let replacement = this._atApplyToCssProperties(mixinName, defaults);
      text = `${textBeforeApply}${replacement}${textAfterApply}`;
      MIXIN_MATCH.lastIndex = idx + replacement.length;
    }
    return text;
  }
  _atApplyToCssProperties(mixinName, fallbacks) {
    mixinName = mixinName.replace(APPLY_NAME_CLEAN, "");
    let vars = [];
    let mixinEntry = this._map.get(mixinName);
    if (!mixinEntry) {
      this._map.set(mixinName, {});
      mixinEntry = this._map.get(mixinName);
    }
    if (mixinEntry) {
      if (this._currentElement) {
        mixinEntry.dependants[this._currentElement] = true;
      }
      let p2, parts, f;
      const properties = mixinEntry.properties;
      for (p2 in properties) {
        f = fallbacks && fallbacks[p2];
        parts = [p2, ": var(", mixinName, MIXIN_VAR_SEP, p2];
        if (f) {
          parts.push(",", f.replace(IMPORTANT, ""));
        }
        parts.push(")");
        if (IMPORTANT.test(properties[p2])) {
          parts.push(" !important");
        }
        vars.push(parts.join(""));
      }
    }
    return vars.join("; ");
  }
  _replaceInitialOrInherit(property, value) {
    let match = INITIAL_INHERIT.exec(value);
    if (match) {
      if (match[1]) {
        value = this._getInitialValueForProperty(property);
      } else {
        value = "apply-shim-inherit";
      }
    }
    return value;
  }
  _cssTextToMap(text, replaceInitialOrInherit = false) {
    let props = text.split(";");
    let property, value;
    let out = {};
    for (let i = 0, p2, sp; i < props.length; i++) {
      p2 = props[i];
      if (p2) {
        sp = p2.split(":");
        if (sp.length > 1) {
          property = sp[0].trim();
          value = sp.slice(1).join(":");
          if (replaceInitialOrInherit) {
            value = this._replaceInitialOrInherit(property, value);
          }
          out[property] = value;
        }
      }
    }
    return out;
  }
  _invalidateMixinEntry(mixinEntry) {
    if (!invalidCallback) {
      return;
    }
    for (let elementName in mixinEntry.dependants) {
      if (elementName !== this._currentElement) {
        invalidCallback(elementName);
      }
    }
  }
  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule) {
    if (valueProperty) {
      processVariableAndFallback(valueProperty, (prefix2, value) => {
        if (value && this._map.get(value)) {
          valueMixin = `@apply ${value};`;
        }
      });
    }
    if (!valueMixin) {
      return matchText;
    }
    let mixinAsProperties = this._consumeCssProperties("" + valueMixin, rule);
    let prefix = matchText.slice(0, matchText.indexOf("--"));
    let mixinValues = this._cssTextToMap(mixinAsProperties, true);
    let combinedProps = mixinValues;
    let mixinEntry = this._map.get(propertyName);
    let oldProps = mixinEntry && mixinEntry.properties;
    if (oldProps) {
      combinedProps = Object.assign(Object.create(oldProps), mixinValues);
    } else {
      this._map.set(propertyName, combinedProps);
    }
    let out = [];
    let p2, v;
    let needToInvalidate = false;
    for (p2 in combinedProps) {
      v = mixinValues[p2];
      if (v === void 0) {
        v = "initial";
      }
      if (oldProps && !(p2 in oldProps)) {
        needToInvalidate = true;
      }
      out.push(`${propertyName}${MIXIN_VAR_SEP}${p2}: ${v}`);
    }
    if (needToInvalidate) {
      this._invalidateMixinEntry(mixinEntry);
    }
    if (mixinEntry) {
      mixinEntry.properties = combinedProps;
    }
    if (valueProperty) {
      prefix = `${matchText};${prefix}`;
    }
    return `${prefix}${out.join("; ")};`;
  }
};
ApplyShim.prototype["detectMixin"] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype["transformStyle"] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype["transformCustomStyle"] = ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype["transformRules"] = ApplyShim.prototype.transformRules;
ApplyShim.prototype["transformRule"] = ApplyShim.prototype.transformRule;
ApplyShim.prototype["transformTemplate"] = ApplyShim.prototype.transformTemplate;
ApplyShim.prototype["_separator"] = MIXIN_VAR_SEP;
Object.defineProperty(ApplyShim.prototype, "invalidCallback", {
  get() {
    return invalidCallback;
  },
  set(cb) {
    invalidCallback = cb;
  }
});
var apply_shim_default = ApplyShim;

// node_modules/@webcomponents/shadycss/src/template-map.js
var templateMap = {};
var template_map_default = templateMap;

// node_modules/@webcomponents/shadycss/src/apply-shim-utils.js
var CURRENT_VERSION = "_applyShimCurrentVersion";
var NEXT_VERSION = "_applyShimNextVersion";
var VALIDATING_VERSION = "_applyShimValidatingVersion";
var promise = Promise.resolve();
function invalidate(elementName) {
  let template = template_map_default[elementName];
  if (template) {
    invalidateTemplate(template);
  }
}
function invalidateTemplate(template) {
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}
function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}
function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}
function startValidatingTemplate(template) {
  template[VALIDATING_VERSION] = template[NEXT_VERSION];
  if (!template._validating) {
    template._validating = true;
    promise.then(function() {
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

// node_modules/@webcomponents/shadycss/entrypoints/apply-shim.js
var applyShim = new apply_shim_default();
var ApplyShimInterface = class {
  constructor() {
    this.customStyleInterface = null;
    applyShim["invalidCallback"] = invalidate;
  }
  ensure() {
    if (this.customStyleInterface) {
      return;
    }
    if (window.ShadyCSS.CustomStyleInterface) {
      this.customStyleInterface = window.ShadyCSS.CustomStyleInterface;
      this.customStyleInterface["transformCallback"] = (style) => {
        applyShim.transformCustomStyle(style);
      };
      this.customStyleInterface["validateCallback"] = () => {
        requestAnimationFrame(() => {
          if (this.customStyleInterface["enqueued"]) {
            this.flushCustomStyles();
          }
        });
      };
    }
  }
  prepareTemplate(template, elementName) {
    this.ensure();
    if (elementHasBuiltCss(template)) {
      return;
    }
    template_map_default[elementName] = template;
    let ast = applyShim.transformTemplate(template, elementName);
    template["_styleAst"] = ast;
  }
  flushCustomStyles() {
    this.ensure();
    if (!this.customStyleInterface) {
      return;
    }
    let styles = this.customStyleInterface["processStyles"]();
    if (!this.customStyleInterface["enqueued"]) {
      return;
    }
    for (let i = 0; i < styles.length; i++) {
      let cs = styles[i];
      let style = this.customStyleInterface["getStyleForCustomStyle"](cs);
      if (style) {
        applyShim.transformCustomStyle(style);
      }
    }
    this.customStyleInterface["enqueued"] = false;
  }
  styleSubtree(element, properties) {
    this.ensure();
    if (properties) {
      updateNativeProperties(element, properties);
    }
    if (element.shadowRoot) {
      this.styleElement(element);
      let shadowChildren = element.shadowRoot.children || element.shadowRoot.childNodes;
      for (let i = 0; i < shadowChildren.length; i++) {
        this.styleSubtree(shadowChildren[i]);
      }
    } else {
      let children = element.children || element.childNodes;
      for (let i = 0; i < children.length; i++) {
        this.styleSubtree(children[i]);
      }
    }
  }
  styleElement(element) {
    this.ensure();
    let { is } = getIsExtends(element);
    let template = template_map_default[is];
    if (template && elementHasBuiltCss(template)) {
      return;
    }
    if (template && !templateIsValid(template)) {
      if (!templateIsValidating(template)) {
        this.prepareTemplate(template, is);
        startValidatingTemplate(template);
      }
      let root = element.shadowRoot;
      if (root) {
        let style = root.querySelector(
          "style"
        );
        if (style) {
          style["__cssRules"] = template["_styleAst"];
          style.textContent = toCssText(template["_styleAst"]);
        }
      }
    }
  }
  styleDocument(properties) {
    this.ensure();
    this.styleSubtree(document.body, properties);
  }
};
if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
  const applyShimInterface = new ApplyShimInterface();
  let CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;
  window.ShadyCSS = {
    prepareTemplate(template, elementName, elementExtends) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.prepareTemplate(template, elementName);
    },
    prepareTemplateStyles(template, elementName, elementExtends) {
      window.ShadyCSS.prepareTemplate(template, elementName, elementExtends);
    },
    prepareTemplateDom(template, elementName) {
    },
    styleSubtree(element, properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleSubtree(element, properties);
    },
    styleElement(element) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleElement(element);
    },
    styleDocument(properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleDocument(properties);
    },
    getComputedStyleValue(element, property) {
      return getComputedStyleValue(element, property);
    },
    flushCustomStyles() {
      applyShimInterface.flushCustomStyles();
    },
    nativeCss: nativeCssVariables,
    nativeShadow,
    cssBuild,
    disableRuntime
  };
  if (CustomStyleInterface) {
    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
  }
}
window.ShadyCSS.ApplyShim = applyShim;

// node_modules/@polymer/polymer/lib/utils/gestures.js
var HAS_NATIVE_TA = typeof document.head.style.touchAction === "string";
var GESTURE_KEY = "__polymerGestures";
var HANDLED_OBJ = "__polymerGesturesHandled";
var TOUCH_ACTION = "__polymerGesturesTouchAction";
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = ["mousedown", "mousemove", "mouseup", "click"];
var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
var MOUSE_HAS_BUTTONS = function() {
  try {
    return new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (e) {
    return false;
  }
}();
function isMouseEvent(name) {
  return MOUSE_EVENTS.indexOf(name) > -1;
}
var supportsPassive = false;
(function() {
  try {
    let opts = Object.defineProperty({}, "passive", { get() {
      supportsPassive = true;
    } });
    window.addEventListener("test", null, opts);
    window.removeEventListener("test", null, opts);
  } catch (e) {
  }
})();
function PASSIVE_TOUCH(eventName) {
  if (isMouseEvent(eventName) || eventName === "touchend") {
    return;
  }
  if (HAS_NATIVE_TA && supportsPassive && passiveTouchGestures) {
    return { passive: true };
  } else {
    return;
  }
}
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var clickedLabels = [];
var labellable = {
  "button": true,
  "input": true,
  "keygen": true,
  "meter": true,
  "output": true,
  "textarea": true,
  "progress": true,
  "select": true
};
var canBeDisabled = {
  "button": true,
  "command": true,
  "fieldset": true,
  "input": true,
  "keygen": true,
  "optgroup": true,
  "option": true,
  "select": true,
  "textarea": true
};
function canBeLabelled(el) {
  return labellable[el.localName] || false;
}
function matchingLabels(el) {
  let labels = Array.prototype.slice.call(el.labels || []);
  if (!labels.length) {
    labels = [];
    try {
      let root = el.getRootNode();
      if (el.id) {
        let matching = root.querySelectorAll(`label[for = '${el.id}']`);
        for (let i = 0; i < matching.length; i++) {
          labels.push(matching[i]);
        }
      }
    } catch (e) {
    }
  }
  return labels;
}
var mouseCanceller = function(mouseEvent) {
  let sc = mouseEvent.sourceCapabilities;
  if (sc && !sc.firesTouchEvents) {
    return;
  }
  mouseEvent[HANDLED_OBJ] = { skip: true };
  if (mouseEvent.type === "click") {
    let clickFromLabel = false;
    let path = getComposedPath(mouseEvent);
    for (let i = 0; i < path.length; i++) {
      if (path[i].nodeType === Node.ELEMENT_NODE) {
        if (path[i].localName === "label") {
          clickedLabels.push(path[i]);
        } else if (canBeLabelled(path[i])) {
          let ownerLabels = matchingLabels(path[i]);
          for (let j = 0; j < ownerLabels.length; j++) {
            clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;
          }
        }
      }
      if (path[i] === POINTERSTATE.mouse.target) {
        return;
      }
    }
    if (clickFromLabel) {
      return;
    }
    mouseEvent.preventDefault();
    mouseEvent.stopPropagation();
  }
};
function setupTeardownMouseCanceller(setup) {
  let events = IS_TOUCH_ONLY ? ["click"] : MOUSE_EVENTS;
  for (let i = 0, en; i < events.length; i++) {
    en = events[i];
    if (setup) {
      clickedLabels.length = 0;
      document.addEventListener(en, mouseCanceller, true);
    } else {
      document.removeEventListener(en, mouseCanceller, true);
    }
  }
}
function ignoreMouse(e) {
  if (!cancelSyntheticClickEvents) {
    return;
  }
  if (!POINTERSTATE.mouse.mouseIgnoreJob) {
    setupTeardownMouseCanceller(true);
  }
  let unset = function() {
    setupTeardownMouseCanceller();
    POINTERSTATE.mouse.target = null;
    POINTERSTATE.mouse.mouseIgnoreJob = null;
  };
  POINTERSTATE.mouse.target = getComposedPath(e)[0];
  POINTERSTATE.mouse.mouseIgnoreJob = Debouncer.debounce(
    POINTERSTATE.mouse.mouseIgnoreJob,
    timeOut.after(MOUSE_TIMEOUT),
    unset
  );
}
function hasLeftMouseButton(ev) {
  let type = ev.type;
  if (!isMouseEvent(type)) {
    return false;
  }
  if (type === "mousemove") {
    let buttons = ev.buttons === void 0 ? 1 : ev.buttons;
    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    return Boolean(buttons & 1);
  } else {
    let button = ev.button === void 0 ? 0 : ev.button;
    return button === 0;
  }
}
function isSyntheticClick(ev) {
  if (ev.type === "click") {
    if (ev.detail === 0) {
      return true;
    }
    let t = _findOriginalTarget(ev);
    if (!t.nodeType || t.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    let bcr = t.getBoundingClientRect();
    let x = ev.pageX, y = ev.pageY;
    return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
  }
  return false;
}
var POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};
function firstTouchAction(ev) {
  let ta = "auto";
  let path = getComposedPath(ev);
  for (let i = 0, n; i < path.length; i++) {
    n = path[i];
    if (n[TOUCH_ACTION]) {
      ta = n[TOUCH_ACTION];
      break;
    }
  }
  return ta;
}
function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener("mousemove", movefn);
  document.addEventListener("mouseup", upfn);
}
function untrackDocument(stateObj) {
  document.removeEventListener("mousemove", stateObj.movefn);
  document.removeEventListener("mouseup", stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}
if (cancelSyntheticClickEvents) {
  document.addEventListener("touchend", ignoreMouse, supportsPassive ? { passive: true } : false);
}
var getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : (event) => event.composedPath && event.composedPath() || [];
var gestures = {};
var recognizers = [];
function deepTargetFind(x, y) {
  let node = document.elementFromPoint(x, y);
  let next = node;
  while (next && next.shadowRoot && !window.ShadyDOM) {
    let oldNext = next;
    next = next.shadowRoot.elementFromPoint(x, y);
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}
function _findOriginalTarget(ev) {
  const path = getComposedPath(ev);
  return path.length > 0 ? path[0] : ev.target;
}
function _handleNative(ev) {
  let handled;
  let type = ev.type;
  let node = ev.currentTarget;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  let gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.slice(0, 5) === "touch") {
      ev = ev;
      let t = ev.changedTouches[0];
      if (type === "touchstart") {
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === "touchstart" || type === "touchmove") {
          _handleTouchAction(ev);
        }
      }
    }
  }
  handled = ev[HANDLED_OBJ];
  if (handled.skip) {
    return;
  }
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      handled[r.name] = true;
      r[type](ev);
    }
  }
}
function _handleTouchAction(ev) {
  let t = ev.changedTouches[0];
  let type = ev.type;
  if (type === "touchstart") {
    POINTERSTATE.touch.x = t.clientX;
    POINTERSTATE.touch.y = t.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === "touchmove") {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    let ta = firstTouchAction(ev);
    let shouldPrevent = false;
    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
    if (!ev.cancelable) {
    } else if (ta === "none") {
      shouldPrevent = true;
    } else if (ta === "pan-x") {
      shouldPrevent = dy > dx;
    } else if (ta === "pan-y") {
      shouldPrevent = dx > dy;
    }
    if (shouldPrevent) {
      ev.preventDefault();
    } else {
      prevent("track");
    }
  }
}
function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}
function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}
function _add(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (let i = 0, dep, gd; i < deps.length; i++) {
    dep = deps[i];
    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== "click") {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = { _count: 0 };
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}
function _remove(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (gobj) {
    for (let i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}
function register2(recog) {
  recognizers.push(recog);
  for (let i = 0; i < recog.emits.length; i++) {
    gestures[recog.emits[i]] = recog;
  }
}
function _findRecognizerByEvent(evName) {
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    for (let j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}
function setTouchAction(node, value) {
  if (HAS_NATIVE_TA && node instanceof HTMLElement) {
    microTask.run(() => {
      node.style.touchAction = value;
    });
  }
  node[TOUCH_ACTION] = value;
}
function _fire(target, type, detail) {
  let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  wrap(target).dispatchEvent(ev);
  if (ev.defaultPrevented) {
    let preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}
function prevent(evName) {
  let recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}
register2({
  name: "downup",
  deps: ["mousedown", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["down", "up"],
  info: {
    movefn: null,
    upfn: null
  },
  reset: function() {
    untrackDocument(this.info);
  },
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn2(e2) {
      if (!hasLeftMouseButton(e2)) {
        downupFire("up", t, e2);
        untrackDocument(self.info);
      }
    };
    let upfn = function upfn2(e2) {
      if (hasLeftMouseButton(e2)) {
        downupFire("up", t, e2);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    downupFire("down", t, e);
  },
  touchstart: function(e) {
    downupFire("down", _findOriginalTarget(e), e.changedTouches[0], e);
  },
  touchend: function(e) {
    downupFire("up", _findOriginalTarget(e), e.changedTouches[0], e);
  }
});
function downupFire(type, target, event, preventer) {
  if (!target) {
    return;
  }
  _fire(target, type, {
    x: event.clientX,
    y: event.clientY,
    sourceEvent: event,
    preventer,
    prevent: function(e) {
      return prevent(e);
    }
  });
}
register2({
  name: "track",
  touchAction: "none",
  deps: ["mousedown", "touchstart", "touchmove", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["track"],
  info: {
    x: 0,
    y: 0,
    state: "start",
    started: false,
    moves: [],
    addMove: function(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },
  reset: function() {
    this.info.state = "start";
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn2(e2) {
      let x = e2.clientX, y = e2.clientY;
      if (trackHasMovedEnough(self.info, x, y)) {
        self.info.state = self.info.started ? e2.type === "mouseup" ? "end" : "track" : "start";
        if (self.info.state === "start") {
          prevent("tap");
        }
        self.info.addMove({ x, y });
        if (!hasLeftMouseButton(e2)) {
          self.info.state = "end";
          untrackDocument(self.info);
        }
        if (t) {
          trackFire(self.info, t, e2);
        }
        self.info.started = true;
      }
    };
    let upfn = function upfn2(e2) {
      if (self.info.started) {
        movefn(e2);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  touchstart: function(e) {
    let ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  touchmove: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    let x = ct.clientX, y = ct.clientY;
    if (trackHasMovedEnough(this.info, x, y)) {
      if (this.info.state === "start") {
        prevent("tap");
      }
      this.info.addMove({ x, y });
      trackFire(this.info, t, ct);
      this.info.state = "track";
      this.info.started = true;
    }
  },
  touchend: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    if (this.info.started) {
      this.info.state = "end";
      this.info.addMove({ x: ct.clientX, y: ct.clientY });
      trackFire(this.info, t, ct);
    }
  }
});
function trackHasMovedEnough(info, x, y) {
  if (info.prevent) {
    return false;
  }
  if (info.started) {
    return true;
  }
  let dx = Math.abs(info.x - x);
  let dy = Math.abs(info.y - y);
  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
}
function trackFire(info, target, touch) {
  if (!target) {
    return;
  }
  let secondlast = info.moves[info.moves.length - 2];
  let lastmove = info.moves[info.moves.length - 1];
  let dx = lastmove.x - info.x;
  let dy = lastmove.y - info.y;
  let ddx, ddy = 0;
  if (secondlast) {
    ddx = lastmove.x - secondlast.x;
    ddy = lastmove.y - secondlast.y;
  }
  _fire(target, "track", {
    state: info.state,
    x: touch.clientX,
    y: touch.clientY,
    dx,
    dy,
    ddx,
    ddy,
    sourceEvent: touch,
    hover: function() {
      return deepTargetFind(touch.clientX, touch.clientY);
    }
  });
}
register2({
  name: "tap",
  deps: ["mousedown", "click", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["click", "touchend"]
  },
  emits: ["tap"],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  reset: function() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  mousedown: function(e) {
    if (hasLeftMouseButton(e)) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    }
  },
  click: function(e) {
    if (hasLeftMouseButton(e)) {
      trackForward(this.info, e);
    }
  },
  touchstart: function(e) {
    const touch = e.changedTouches[0];
    this.info.x = touch.clientX;
    this.info.y = touch.clientY;
  },
  touchend: function(e) {
    trackForward(this.info, e.changedTouches[0], e);
  }
});
function trackForward(info, e, preventer) {
  let dx = Math.abs(e.clientX - info.x);
  let dy = Math.abs(e.clientY - info.y);
  let t = _findOriginalTarget(preventer || e);
  if (!t || canBeDisabled[t.localName] && t.hasAttribute("disabled")) {
    return;
  }
  if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
    if (!info.prevent) {
      _fire(t, "tap", {
        x: e.clientX,
        y: e.clientY,
        sourceEvent: e,
        preventer
      });
    }
  }
}

// node_modules/@polymer/polymer/lib/mixins/gesture-event-listeners.js
var GestureEventListeners = dedupingMixin((superClass) => {
  class GestureEventListeners2 extends superClass {
    _addEventListenerToNode(node, eventName, handler) {
      if (!addListener(node, eventName, handler)) {
        super._addEventListenerToNode(node, eventName, handler);
      }
    }
    _removeEventListenerFromNode(node, eventName, handler) {
      if (!removeListener(node, eventName, handler)) {
        super._removeEventListenerFromNode(node, eventName, handler);
      }
    }
  }
  return GestureEventListeners2;
});

// node_modules/@polymer/polymer/lib/mixins/dir-mixin.js
var HOST_DIR = /:host\(:dir\((ltr|rtl)\)\)/g;
var HOST_DIR_REPLACMENT = ':host([dir="$1"])';
var EL_DIR = /([\s\w-#\.\[\]\*]*):dir\((ltr|rtl)\)/g;
var EL_DIR_REPLACMENT = ':host([dir="$2"]) $1';
var DIR_CHECK = /:dir\((?:ltr|rtl)\)/;
var SHIM_SHADOW = Boolean(window["ShadyDOM"] && window["ShadyDOM"]["inUse"]);
var DIR_INSTANCES = [];
var observer = null;
var documentDir = "";
function getRTL() {
  documentDir = document.documentElement.getAttribute("dir");
}
function setRTL(instance) {
  if (!instance.__autoDirOptOut) {
    const el = instance;
    el.setAttribute("dir", documentDir);
  }
}
function updateDirection() {
  getRTL();
  documentDir = document.documentElement.getAttribute("dir");
  for (let i = 0; i < DIR_INSTANCES.length; i++) {
    setRTL(DIR_INSTANCES[i]);
  }
}
function takeRecords() {
  if (observer && observer.takeRecords().length) {
    updateDirection();
  }
}
var DirMixin = dedupingMixin((base) => {
  if (!SHIM_SHADOW) {
    if (!observer) {
      getRTL();
      observer = new MutationObserver(updateDirection);
      observer.observe(document.documentElement, { attributes: true, attributeFilter: ["dir"] });
    }
  }
  const elementBase = PropertyAccessors(base);
  class Dir extends elementBase {
    static _processStyleText(cssText, baseURI) {
      cssText = elementBase._processStyleText.call(this, cssText, baseURI);
      if (!SHIM_SHADOW && DIR_CHECK.test(cssText)) {
        cssText = this._replaceDirInCssText(cssText);
        this.__activateDir = true;
      }
      return cssText;
    }
    static _replaceDirInCssText(text) {
      let replacedText = text;
      replacedText = replacedText.replace(HOST_DIR, HOST_DIR_REPLACMENT);
      replacedText = replacedText.replace(EL_DIR, EL_DIR_REPLACMENT);
      return replacedText;
    }
    constructor() {
      super();
      this.__autoDirOptOut = false;
    }
    ready() {
      super.ready();
      this.__autoDirOptOut = this.hasAttribute("dir");
    }
    connectedCallback() {
      if (elementBase.prototype.connectedCallback) {
        super.connectedCallback();
      }
      if (this.constructor.__activateDir) {
        takeRecords();
        DIR_INSTANCES.push(this);
        setRTL(this);
      }
    }
    disconnectedCallback() {
      if (elementBase.prototype.disconnectedCallback) {
        super.disconnectedCallback();
      }
      if (this.constructor.__activateDir) {
        const idx = DIR_INSTANCES.indexOf(this);
        if (idx > -1) {
          DIR_INSTANCES.splice(idx, 1);
        }
      }
    }
  }
  Dir.__activateDir = false;
  return Dir;
});

// node_modules/@polymer/polymer/lib/utils/unresolved.js
function resolve() {
  document.body.removeAttribute("unresolved");
}
if (document.readyState === "interactive" || document.readyState === "complete") {
  resolve();
} else {
  window.addEventListener("DOMContentLoaded", resolve);
}

// node_modules/@polymer/polymer/lib/utils/scope-subtree.js
var ShadyDOM2 = window.ShadyDOM;
var ShadyCSS = window.ShadyCSS;
function sameScope(node, scope) {
  return wrap(node).getRootNode() === scope;
}
function scopeSubtree(container, shouldObserve = false) {
  if (!ShadyDOM2 || !ShadyCSS) {
    return null;
  }
  if (!ShadyDOM2["handlesDynamicScoping"]) {
    return null;
  }
  const ScopingShim = ShadyCSS["ScopingShim"];
  if (!ScopingShim) {
    return null;
  }
  const containerScope = ScopingShim["scopeForNode"](container);
  const root = wrap(container).getRootNode();
  const scopify = (node) => {
    if (!sameScope(node, root)) {
      return;
    }
    const elements = Array.from(ShadyDOM2["nativeMethods"]["querySelectorAll"].call(node, "*"));
    elements.push(node);
    for (let i = 0; i < elements.length; i++) {
      const el = elements[i];
      if (!sameScope(el, root)) {
        continue;
      }
      const currentScope = ScopingShim["currentScopeForNode"](el);
      if (currentScope !== containerScope) {
        if (currentScope !== "") {
          ScopingShim["unscopeNode"](el, currentScope);
        }
        ScopingShim["scopeNode"](el, containerScope);
      }
    }
  };
  scopify(container);
  if (shouldObserve) {
    const mo = new MutationObserver((mxns) => {
      for (let i = 0; i < mxns.length; i++) {
        const mxn = mxns[i];
        for (let j = 0; j < mxn.addedNodes.length; j++) {
          const addedNode = mxn.addedNodes[j];
          if (addedNode.nodeType === Node.ELEMENT_NODE) {
            scopify(addedNode);
          }
        }
      }
    });
    mo.observe(container, { childList: true, subtree: true });
    return mo;
  } else {
    return null;
  }
}

// node_modules/@polymer/polymer/lib/legacy/legacy-element-mixin.js
var DISABLED_ATTR = "disable-upgrade";
var styleInterface = window.ShadyCSS;
var LegacyElementMixin = dedupingMixin((base) => {
  const GesturesElement = GestureEventListeners(ElementMixin(base));
  const legacyElementBase = builtCSS ? GesturesElement : DirMixin(GesturesElement);
  const observedAttributesGetter = findObservedAttributesGetter(legacyElementBase);
  const DIRECTION_MAP = {
    "x": "pan-x",
    "y": "pan-y",
    "none": "none",
    "all": "auto"
  };
  class LegacyElement2 extends legacyElementBase {
    constructor() {
      super();
      this.isAttached;
      this.__boundListeners;
      this._debouncers;
      this.__isUpgradeDisabled;
      this.__needsAttributesAtConnected;
      this._legacyForceObservedAttributes;
    }
    static get importMeta() {
      return this.prototype.importMeta;
    }
    created() {
    }
    __attributeReaction(name, old, value) {
      if (this.__dataAttributes && this.__dataAttributes[name] || name === DISABLED_ATTR) {
        this.attributeChangedCallback(name, old, value, null);
      }
    }
    setAttribute(name, value) {
      if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
        const oldValue = this.getAttribute(name);
        super.setAttribute(name, value);
        this.__attributeReaction(name, oldValue, String(value));
      } else {
        super.setAttribute(name, value);
      }
    }
    removeAttribute(name) {
      if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
        const oldValue = this.getAttribute(name);
        super.removeAttribute(name);
        this.__attributeReaction(name, oldValue, null);
      } else {
        super.removeAttribute(name);
      }
    }
    static get observedAttributes() {
      if (legacyNoObservedAttributes && !this.prototype._legacyForceObservedAttributes) {
        if (!this.hasOwnProperty(JSCompiler_renameProperty("__observedAttributes", this))) {
          this.__observedAttributes = [];
          register(this.prototype);
        }
        return this.__observedAttributes;
      } else {
        return observedAttributesGetter.call(this).concat(DISABLED_ATTR);
      }
    }
    _enableProperties() {
      if (!this.__isUpgradeDisabled) {
        super._enableProperties();
      }
    }
    _canApplyPropertyDefault(property) {
      return super._canApplyPropertyDefault(property) && !(this.__isUpgradeDisabled && this._isPropertyPending(property));
    }
    connectedCallback() {
      if (this.__needsAttributesAtConnected) {
        this._takeAttributes();
      }
      if (!this.__isUpgradeDisabled) {
        super.connectedCallback();
        this.isAttached = true;
        this.attached();
      }
    }
    attached() {
    }
    disconnectedCallback() {
      if (!this.__isUpgradeDisabled) {
        super.disconnectedCallback();
        this.isAttached = false;
        this.detached();
      }
    }
    detached() {
    }
    attributeChangedCallback(name, old, value, namespace) {
      if (old !== value) {
        if (name == DISABLED_ATTR) {
          if (this.__isUpgradeDisabled && value == null) {
            this._initializeProperties();
            this.__isUpgradeDisabled = false;
            if (wrap(this).isConnected) {
              this.connectedCallback();
            }
          }
        } else {
          super.attributeChangedCallback(name, old, value, namespace);
          this.attributeChanged(name, old, value);
        }
      }
    }
    attributeChanged(name, old, value) {
    }
    _initializeProperties() {
      if (legacyOptimizations && this.hasAttribute(DISABLED_ATTR)) {
        this.__isUpgradeDisabled = true;
      } else {
        let proto = Object.getPrototypeOf(this);
        if (!proto.hasOwnProperty(JSCompiler_renameProperty("__hasRegisterFinished", proto))) {
          this._registered();
          proto.__hasRegisterFinished = true;
        }
        super._initializeProperties();
        this.root = this;
        this.created();
        if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
          if (this.hasAttributes()) {
            this._takeAttributes();
          } else if (!this.parentNode) {
            this.__needsAttributesAtConnected = true;
          }
        }
        this._applyListeners();
      }
    }
    _takeAttributes() {
      const a = this.attributes;
      for (let i = 0, l = a.length; i < l; i++) {
        const attr = a[i];
        this.__attributeReaction(attr.name, null, attr.value);
      }
    }
    _registered() {
    }
    ready() {
      this._ensureAttributes();
      super.ready();
    }
    _ensureAttributes() {
    }
    _applyListeners() {
    }
    serialize(value) {
      return this._serializeValue(value);
    }
    deserialize(value, type) {
      return this._deserializeValue(value, type);
    }
    reflectPropertyToAttribute(property, attribute, value) {
      this._propertyToAttribute(property, attribute, value);
    }
    serializeValueToAttribute(value, attribute, node) {
      this._valueToNodeAttribute(node || this, value, attribute);
    }
    extend(prototype, api) {
      if (!(prototype && api)) {
        return prototype || api;
      }
      let n$ = Object.getOwnPropertyNames(api);
      for (let i = 0, n; i < n$.length && (n = n$[i]); i++) {
        let pd = Object.getOwnPropertyDescriptor(api, n);
        if (pd) {
          Object.defineProperty(prototype, n, pd);
        }
      }
      return prototype;
    }
    mixin(target, source) {
      for (let i in source) {
        target[i] = source[i];
      }
      return target;
    }
    chainObject(object, prototype) {
      if (object && prototype && object !== prototype) {
        object.__proto__ = prototype;
      }
      return object;
    }
    instanceTemplate(template) {
      let content = this.constructor._contentForTemplate(template);
      let dom2 = document.importNode(content, true);
      return dom2;
    }
    fire(type, detail, options) {
      options = options || {};
      detail = detail === null || detail === void 0 ? {} : detail;
      let event = new Event(type, {
        bubbles: options.bubbles === void 0 ? true : options.bubbles,
        cancelable: Boolean(options.cancelable),
        composed: options.composed === void 0 ? true : options.composed
      });
      event.detail = detail;
      let node = options.node || this;
      wrap(node).dispatchEvent(event);
      return event;
    }
    listen(node, eventName, methodName) {
      node = node || this;
      let hbl = this.__boundListeners || (this.__boundListeners = /* @__PURE__ */ new WeakMap());
      let bl = hbl.get(node);
      if (!bl) {
        bl = {};
        hbl.set(node, bl);
      }
      let key = eventName + methodName;
      if (!bl[key]) {
        bl[key] = this._addMethodEventListenerToNode(
          node,
          eventName,
          methodName,
          this
        );
      }
    }
    unlisten(node, eventName, methodName) {
      node = node || this;
      let bl = this.__boundListeners && this.__boundListeners.get(node);
      let key = eventName + methodName;
      let handler = bl && bl[key];
      if (handler) {
        this._removeEventListenerFromNode(
          node,
          eventName,
          handler
        );
        bl[key] = null;
      }
    }
    setScrollDirection(direction, node) {
      setTouchAction(
        node || this,
        DIRECTION_MAP[direction] || "auto"
      );
    }
    $$(slctr) {
      return this.root.querySelector(slctr);
    }
    get domHost() {
      let root = wrap(this).getRootNode();
      return root instanceof DocumentFragment ? root.host : root;
    }
    distributeContent() {
      const thisEl = this;
      const domApi = dom(thisEl);
      if (window.ShadyDOM && domApi.shadowRoot) {
        ShadyDOM.flush();
      }
    }
    getEffectiveChildNodes() {
      const thisEl = this;
      const domApi = dom(thisEl);
      return domApi.getEffectiveChildNodes();
    }
    queryDistributedElements(selector) {
      const thisEl = this;
      const domApi = dom(thisEl);
      return domApi.queryDistributedElements(selector);
    }
    getEffectiveChildren() {
      let list = this.getEffectiveChildNodes();
      return list.filter(function(n) {
        return n.nodeType === Node.ELEMENT_NODE;
      });
    }
    getEffectiveTextContent() {
      let cn = this.getEffectiveChildNodes();
      let tc = [];
      for (let i = 0, c; c = cn[i]; i++) {
        if (c.nodeType !== Node.COMMENT_NODE) {
          tc.push(c.textContent);
        }
      }
      return tc.join("");
    }
    queryEffectiveChildren(selector) {
      let e$ = this.queryDistributedElements(selector);
      return e$ && e$[0];
    }
    queryAllEffectiveChildren(selector) {
      return this.queryDistributedElements(selector);
    }
    getContentChildNodes(slctr) {
      let content = this.root.querySelector(slctr || "slot");
      return content ? dom(content).getDistributedNodes() : [];
    }
    getContentChildren(slctr) {
      let children = this.getContentChildNodes(slctr).filter(function(n) {
        return n.nodeType === Node.ELEMENT_NODE;
      });
      return children;
    }
    isLightDescendant(node) {
      const thisNode = this;
      return thisNode !== node && wrap(thisNode).contains(node) && wrap(thisNode).getRootNode() === wrap(node).getRootNode();
    }
    isLocalDescendant(node) {
      return this.root === wrap(node).getRootNode();
    }
    scopeSubtree(container, shouldObserve = false) {
      return scopeSubtree(container, shouldObserve);
    }
    getComputedStyleValue(property) {
      return styleInterface.getComputedStyleValue(this, property);
    }
    debounce(jobName, callback, wait) {
      this._debouncers = this._debouncers || {};
      return this._debouncers[jobName] = Debouncer.debounce(
        this._debouncers[jobName],
        wait > 0 ? timeOut.after(wait) : microTask,
        callback.bind(this)
      );
    }
    isDebouncerActive(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      return !!(debouncer && debouncer.isActive());
    }
    flushDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.flush();
      }
    }
    cancelDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.cancel();
      }
    }
    async(callback, waitTime) {
      return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) : ~microTask.run(callback.bind(this));
    }
    cancelAsync(handle) {
      handle < 0 ? microTask.cancel(~handle) : timeOut.cancel(handle);
    }
    create(tag, props) {
      let elt = document.createElement(tag);
      if (props) {
        if (elt.setProperties) {
          elt.setProperties(props);
        } else {
          for (let n in props) {
            elt[n] = props[n];
          }
        }
      }
      return elt;
    }
    elementMatches(selector, node) {
      return matchesSelector(node || this, selector);
    }
    toggleAttribute(name, bool) {
      let node = this;
      if (arguments.length === 3) {
        node = arguments[2];
      }
      if (arguments.length == 1) {
        bool = !node.hasAttribute(name);
      }
      if (bool) {
        wrap(node).setAttribute(name, "");
        return true;
      } else {
        wrap(node).removeAttribute(name);
        return false;
      }
    }
    toggleClass(name, bool, node) {
      node = node || this;
      if (arguments.length == 1) {
        bool = !node.classList.contains(name);
      }
      if (bool) {
        node.classList.add(name);
      } else {
        node.classList.remove(name);
      }
    }
    transform(transformText, node) {
      node = node || this;
      node.style.webkitTransform = transformText;
      node.style.transform = transformText;
    }
    translate3d(x, y, z, node) {
      node = node || this;
      this.transform("translate3d(" + x + "," + y + "," + z + ")", node);
    }
    arrayDelete(arrayOrPath, item) {
      let index;
      if (Array.isArray(arrayOrPath)) {
        index = arrayOrPath.indexOf(item);
        if (index >= 0) {
          return arrayOrPath.splice(index, 1);
        }
      } else {
        let arr = get(this, arrayOrPath);
        index = arr.indexOf(item);
        if (index >= 0) {
          return this.splice(arrayOrPath, index, 1);
        }
      }
      return null;
    }
    _logger(level, args) {
      if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {
        args = args[0];
      }
      switch (level) {
        case "log":
        case "warn":
        case "error":
          console[level](...args);
      }
    }
    _log(...args) {
      this._logger("log", args);
    }
    _warn(...args) {
      this._logger("warn", args);
    }
    _error(...args) {
      this._logger("error", args);
    }
    _logf(methodName, ...args) {
      return ["[%s::%s]", this.is, methodName, ...args];
    }
  }
  LegacyElement2.prototype.is = "";
  return LegacyElement2;
});

// node_modules/@polymer/polymer/lib/legacy/class.js
var lifecycleProps = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  listeners: true,
  hostAttributes: true
};
var excludeOnInfo = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  behaviors: true,
  _noAccessors: true
};
var excludeOnBehaviors = Object.assign({
  listeners: true,
  hostAttributes: true,
  properties: true,
  observers: true
}, excludeOnInfo);
function copyProperties(source, target, excludeProps) {
  const noAccessors = source._noAccessors;
  const propertyNames = Object.getOwnPropertyNames(source);
  for (let i = 0; i < propertyNames.length; i++) {
    let p2 = propertyNames[i];
    if (p2 in excludeProps) {
      continue;
    }
    if (noAccessors) {
      target[p2] = source[p2];
    } else {
      let pd = Object.getOwnPropertyDescriptor(source, p2);
      if (pd) {
        pd.configurable = true;
        Object.defineProperty(target, p2, pd);
      }
    }
  }
}
function applyBehaviors(proto, behaviors, lifecycle) {
  for (let i = 0; i < behaviors.length; i++) {
    applyInfo(proto, behaviors[i], lifecycle, excludeOnBehaviors);
  }
}
function applyInfo(proto, info, lifecycle, excludeProps) {
  copyProperties(info, proto, excludeProps);
  for (let p2 in lifecycleProps) {
    if (info[p2]) {
      lifecycle[p2] = lifecycle[p2] || [];
      lifecycle[p2].push(info[p2]);
    }
  }
}
function flattenBehaviors(behaviors, list, exclude) {
  list = list || [];
  for (let i = behaviors.length - 1; i >= 0; i--) {
    let b = behaviors[i];
    if (b) {
      if (Array.isArray(b)) {
        flattenBehaviors(b, list);
      } else {
        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
          list.unshift(b);
        }
      }
    } else {
      console.warn("behavior is null, check for missing or 404 import");
    }
  }
  return list;
}
function mergeProperties(target, source) {
  for (const p2 in source) {
    const targetInfo = target[p2];
    const sourceInfo = source[p2];
    if (!("value" in sourceInfo) && targetInfo && "value" in targetInfo) {
      target[p2] = Object.assign({ value: targetInfo.value }, sourceInfo);
    } else {
      target[p2] = sourceInfo;
    }
  }
}
var LegacyElement = LegacyElementMixin(HTMLElement);
function GenerateClassFromInfo(info, Base2, behaviors) {
  let behaviorList;
  const lifecycle = {};
  class PolymerGenerated extends Base2 {
    static _finalizeClass() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("generatedFrom", this))) {
        Base2._finalizeClass.call(this);
      } else {
        if (behaviorList) {
          for (let i = 0, b; i < behaviorList.length; i++) {
            b = behaviorList[i];
            if (b.properties) {
              this.createProperties(b.properties);
            }
            if (b.observers) {
              this.createObservers(b.observers, b.properties);
            }
          }
        }
        if (info.properties) {
          this.createProperties(info.properties);
        }
        if (info.observers) {
          this.createObservers(info.observers, info.properties);
        }
        this._prepareTemplate();
      }
    }
    static get properties() {
      const properties = {};
      if (behaviorList) {
        for (let i = 0; i < behaviorList.length; i++) {
          mergeProperties(properties, behaviorList[i].properties);
        }
      }
      mergeProperties(properties, info.properties);
      return properties;
    }
    static get observers() {
      let observers = [];
      if (behaviorList) {
        for (let i = 0, b; i < behaviorList.length; i++) {
          b = behaviorList[i];
          if (b.observers) {
            observers = observers.concat(b.observers);
          }
        }
      }
      if (info.observers) {
        observers = observers.concat(info.observers);
      }
      return observers;
    }
    created() {
      super.created();
      const list = lifecycle.created;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    _registered() {
      const generatedProto = PolymerGenerated.prototype;
      if (!generatedProto.hasOwnProperty(JSCompiler_renameProperty("__hasRegisterFinished", generatedProto))) {
        generatedProto.__hasRegisterFinished = true;
        super._registered();
        if (legacyOptimizations) {
          copyPropertiesToProto(generatedProto);
        }
        const proto = Object.getPrototypeOf(this);
        let list = lifecycle.beforeRegister;
        if (list) {
          for (let i = 0; i < list.length; i++) {
            list[i].call(proto);
          }
        }
        list = lifecycle.registered;
        if (list) {
          for (let i = 0; i < list.length; i++) {
            list[i].call(proto);
          }
        }
      }
    }
    _applyListeners() {
      super._applyListeners();
      const list = lifecycle.listeners;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          const listeners = list[i];
          if (listeners) {
            for (let l in listeners) {
              this._addMethodEventListenerToNode(this, l, listeners[l]);
            }
          }
        }
      }
    }
    _ensureAttributes() {
      const list = lifecycle.hostAttributes;
      if (list) {
        for (let i = list.length - 1; i >= 0; i--) {
          const hostAttributes = list[i];
          for (let a in hostAttributes) {
            this._ensureAttribute(a, hostAttributes[a]);
          }
        }
      }
      super._ensureAttributes();
    }
    ready() {
      super.ready();
      let list = lifecycle.ready;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    attached() {
      super.attached();
      let list = lifecycle.attached;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    detached() {
      super.detached();
      let list = lifecycle.detached;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    attributeChanged(name, old, value) {
      super.attributeChanged();
      let list = lifecycle.attributeChanged;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          list[i].call(this, name, old, value);
        }
      }
    }
  }
  if (behaviors) {
    if (!Array.isArray(behaviors)) {
      behaviors = [behaviors];
    }
    let superBehaviors = Base2.prototype.behaviors;
    behaviorList = flattenBehaviors(behaviors, null, superBehaviors);
    PolymerGenerated.prototype.behaviors = superBehaviors ? superBehaviors.concat(behaviors) : behaviorList;
  }
  const copyPropertiesToProto = (proto) => {
    if (behaviorList) {
      applyBehaviors(proto, behaviorList, lifecycle);
    }
    applyInfo(proto, info, lifecycle, excludeOnInfo);
  };
  if (!legacyOptimizations) {
    copyPropertiesToProto(PolymerGenerated.prototype);
  }
  PolymerGenerated.generatedFrom = info;
  return PolymerGenerated;
}
var Class = function(info, mixin) {
  if (!info) {
    console.warn("Polymer.Class requires `info` argument");
  }
  let klass = mixin ? mixin(LegacyElement) : LegacyElement;
  klass = GenerateClassFromInfo(info, klass, info.behaviors);
  klass.is = klass.prototype.is = info.is;
  return klass;
};

// node_modules/@polymer/polymer/lib/legacy/polymer-fn.js
var Polymer = function(info) {
  let klass;
  if (typeof info === "function") {
    klass = info;
  } else {
    klass = Polymer.Class(info);
  }
  if (info._legacyForceObservedAttributes) {
    klass.prototype._legacyForceObservedAttributes = info._legacyForceObservedAttributes;
  }
  customElements.define(klass.is, klass);
  return klass;
};
Polymer.Class = Class;

// node_modules/@polymer/polymer/lib/legacy/templatizer-behavior.js
var Templatizer = {
  templatize(template, mutableData) {
    this._templatizerTemplate = template;
    this.ctor = templatize(template, this, {
      mutableData: Boolean(mutableData),
      parentModel: this._parentModel,
      instanceProps: this._instanceProps,
      forwardHostProp: this._forwardHostPropV2,
      notifyInstanceProp: this._notifyInstancePropV2
    });
  },
  stamp(model) {
    return new this.ctor(model);
  },
  modelForElement(el) {
    return modelForElement(this._templatizerTemplate, el);
  }
};

// node_modules/@polymer/polymer/lib/legacy/mutable-data-behavior.js
var mutablePropertyChange;
(() => {
  mutablePropertyChange = MutableData._mutablePropertyChange;
})();
var OptionalMutableDataBehavior = {
  properties: {
    mutableData: Boolean
  },
  _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, this.mutableData);
  }
};

// node_modules/@polymer/polymer/lib/elements/dom-bind.js
var domBindBase = GestureEventListeners(
  OptionalMutableData(
    PropertyEffects(HTMLElement)
  )
);
var DomBind = class extends domBindBase {
  static get observedAttributes() {
    return ["mutable-data"];
  }
  constructor() {
    super();
    if (strictTemplatePolicy) {
      throw new Error(`strictTemplatePolicy: dom-bind not allowed`);
    }
    this.root = null;
    this.$ = null;
    this.__children = null;
  }
  attributeChangedCallback(name, old, value, namespace) {
    this.mutableData = true;
  }
  connectedCallback() {
    if (!hideElementsGlobally()) {
      this.style.display = "none";
    }
    this.render();
  }
  disconnectedCallback() {
    this.__removeChildren();
  }
  __insertChildren() {
    wrap(wrap(this).parentNode).insertBefore(this.root, this);
  }
  __removeChildren() {
    if (this.__children) {
      for (let i = 0; i < this.__children.length; i++) {
        this.root.appendChild(this.__children[i]);
      }
    }
  }
  render() {
    let template;
    if (!this.__children) {
      template = template || this.querySelector("template");
      if (!template) {
        let observer2 = new MutationObserver(() => {
          template = this.querySelector("template");
          if (template) {
            observer2.disconnect();
            this.render();
          } else {
            throw new Error("dom-bind requires a <template> child");
          }
        });
        observer2.observe(this, { childList: true });
        return;
      }
      this.root = this._stampTemplate(
        template
      );
      this.$ = this.root.$;
      this.__children = [];
      for (let n = this.root.firstChild; n; n = n.nextSibling) {
        this.__children[this.__children.length] = n;
      }
      this._enableProperties();
    }
    this.__insertChildren();
    this.dispatchEvent(new CustomEvent("dom-change", {
      bubbles: true,
      composed: true
    }));
  }
};
customElements.define("dom-bind", DomBind);

// node_modules/@polymer/polymer/lib/elements/array-selector.js
var ArraySelectorMixin = dedupingMixin((superClass) => {
  let elementBase = ElementMixin(superClass);
  class ArraySelectorMixin2 extends elementBase {
    static get properties() {
      return {
        items: {
          type: Array
        },
        multi: {
          type: Boolean,
          value: false
        },
        selected: { type: Object, notify: true },
        selectedItem: { type: Object, notify: true },
        toggle: { type: Boolean, value: false }
      };
    }
    static get observers() {
      return ["__updateSelection(multi, items.*)"];
    }
    constructor() {
      super();
      this.__lastItems = null;
      this.__lastMulti = null;
      this.__selectedMap = null;
    }
    __updateSelection(multi, itemsInfo) {
      let path = itemsInfo.path;
      if (path == JSCompiler_renameProperty("items", this)) {
        let newItems = itemsInfo.base || [];
        let lastItems = this.__lastItems;
        let lastMulti = this.__lastMulti;
        if (multi !== lastMulti) {
          this.clearSelection();
        }
        if (lastItems) {
          let splices = calculateSplices(newItems, lastItems);
          this.__applySplices(splices);
        }
        this.__lastItems = newItems;
        this.__lastMulti = multi;
      } else if (itemsInfo.path == `${JSCompiler_renameProperty("items", this)}.splices`) {
        this.__applySplices(itemsInfo.value.indexSplices);
      } else {
        let part = path.slice(`${JSCompiler_renameProperty("items", this)}.`.length);
        let idx = parseInt(part, 10);
        if (part.indexOf(".") < 0 && part == idx) {
          this.__deselectChangedIdx(idx);
        }
      }
    }
    __applySplices(splices) {
      let selected = this.__selectedMap;
      for (let i = 0; i < splices.length; i++) {
        let s = splices[i];
        selected.forEach((idx, item) => {
          if (idx < s.index) {
          } else if (idx >= s.index + s.removed.length) {
            selected.set(item, idx + s.addedCount - s.removed.length);
          } else {
            selected.set(item, -1);
          }
        });
        for (let j = 0; j < s.addedCount; j++) {
          let idx = s.index + j;
          if (selected.has(this.items[idx])) {
            selected.set(this.items[idx], idx);
          }
        }
      }
      this.__updateLinks();
      let sidx = 0;
      selected.forEach((idx, item) => {
        if (idx < 0) {
          if (this.multi) {
            this.splice(JSCompiler_renameProperty("selected", this), sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
          selected.delete(item);
        } else {
          sidx++;
        }
      });
    }
    __updateLinks() {
      this.__dataLinkedPaths = {};
      if (this.multi) {
        let sidx = 0;
        this.__selectedMap.forEach((idx) => {
          if (idx >= 0) {
            this.linkPaths(
              `${JSCompiler_renameProperty("items", this)}.${idx}`,
              `${JSCompiler_renameProperty("selected", this)}.${sidx++}`
            );
          }
        });
      } else {
        this.__selectedMap.forEach((idx) => {
          this.linkPaths(
            JSCompiler_renameProperty("selected", this),
            `${JSCompiler_renameProperty("items", this)}.${idx}`
          );
          this.linkPaths(
            JSCompiler_renameProperty("selectedItem", this),
            `${JSCompiler_renameProperty("items", this)}.${idx}`
          );
        });
      }
    }
    clearSelection() {
      this.__dataLinkedPaths = {};
      this.__selectedMap = /* @__PURE__ */ new Map();
      this.selected = this.multi ? [] : null;
      this.selectedItem = null;
    }
    isSelected(item) {
      return this.__selectedMap.has(item);
    }
    isIndexSelected(idx) {
      return this.isSelected(this.items[idx]);
    }
    __deselectChangedIdx(idx) {
      let sidx = this.__selectedIndexForItemIndex(idx);
      if (sidx >= 0) {
        let i = 0;
        this.__selectedMap.forEach((idx2, item) => {
          if (sidx == i++) {
            this.deselect(item);
          }
        });
      }
    }
    __selectedIndexForItemIndex(idx) {
      let selected = this.__dataLinkedPaths[`${JSCompiler_renameProperty("items", this)}.${idx}`];
      if (selected) {
        return parseInt(selected.slice(`${JSCompiler_renameProperty("selected", this)}.`.length), 10);
      }
    }
    deselect(item) {
      let idx = this.__selectedMap.get(item);
      if (idx >= 0) {
        this.__selectedMap.delete(item);
        let sidx;
        if (this.multi) {
          sidx = this.__selectedIndexForItemIndex(idx);
        }
        this.__updateLinks();
        if (this.multi) {
          this.splice(JSCompiler_renameProperty("selected", this), sidx, 1);
        } else {
          this.selected = this.selectedItem = null;
        }
      }
    }
    deselectIndex(idx) {
      this.deselect(this.items[idx]);
    }
    select(item) {
      this.selectIndex(this.items.indexOf(item));
    }
    selectIndex(idx) {
      let item = this.items[idx];
      if (!this.isSelected(item)) {
        if (!this.multi) {
          this.__selectedMap.clear();
        }
        this.__selectedMap.set(item, idx);
        this.__updateLinks();
        if (this.multi) {
          this.push(JSCompiler_renameProperty("selected", this), item);
        } else {
          this.selected = this.selectedItem = item;
        }
      } else if (this.toggle) {
        this.deselectIndex(idx);
      }
    }
  }
  return ArraySelectorMixin2;
});
var baseArraySelector = ArraySelectorMixin(PolymerElement);
var ArraySelector = class extends baseArraySelector {
  static get is() {
    return "array-selector";
  }
  static get template() {
    return null;
  }
};
customElements.define(ArraySelector.is, ArraySelector);

// node_modules/@polymer/polymer/polymer-legacy.js
var Base = LegacyElementMixin(HTMLElement).prototype;

export {
  dom,
  Polymer,
  Templatizer,
  OptionalMutableDataBehavior,
  Base
};
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
//# sourceMappingURL=chunk-IKEUZ42Z.js.map
