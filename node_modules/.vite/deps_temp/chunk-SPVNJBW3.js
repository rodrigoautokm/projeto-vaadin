import {
  CSSResult
} from "./chunk-BVJZYYEF.js";

// node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js
var ThemePropertyMixin = (superClass) => class VaadinThemePropertyMixin extends superClass {
  static get properties() {
    return {
      theme: {
        type: String,
        reflectToAttribute: true,
        observer: "__deprecatedThemePropertyChanged"
      },
      _theme: {
        type: String,
        readOnly: true
      }
    };
  }
  __deprecatedThemePropertyChanged(theme) {
    this._set_theme(theme);
  }
};

// node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js
var themeRegistry = [];
function registerStyles(themeFor, styles, options = {}) {
  if (themeFor) {
    if (hasThemes(themeFor)) {
      console.warn(`The custom element definition for "${themeFor}"
      was finalized before a style module was registered.
      Make sure to add component specific style modules before
      importing the corresponding custom element.`);
    }
  }
  styles = flattenStyles(styles);
  if (window.Vaadin && window.Vaadin.styleModules) {
    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);
  } else {
    themeRegistry.push({
      themeFor,
      styles,
      include: options.include,
      moduleId: options.moduleId
    });
  }
}
function getAllThemes() {
  if (window.Vaadin && window.Vaadin.styleModules) {
    return window.Vaadin.styleModules.getAllThemes();
  }
  return themeRegistry;
}
function matchesThemeFor(themeFor, tagName) {
  return (themeFor || "").split(" ").some((themeForToken) => {
    return new RegExp(`^${themeForToken.split("*").join(".*")}$`).test(tagName);
  });
}
function getIncludePriority(moduleName = "") {
  let includePriority = 0;
  if (moduleName.startsWith("lumo-") || moduleName.startsWith("material-")) {
    includePriority = 1;
  } else if (moduleName.startsWith("vaadin-")) {
    includePriority = 2;
  }
  return includePriority;
}
function flattenStyles(styles = []) {
  return [styles].flat(Infinity).filter((style) => {
    if (style instanceof CSSResult) {
      return true;
    }
    console.warn("An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.");
    return false;
  });
}
function getIncludedStyles(theme) {
  const includedStyles = [];
  if (theme.include) {
    [].concat(theme.include).forEach((includeModuleId) => {
      const includedTheme = getAllThemes().find((s) => s.moduleId === includeModuleId);
      if (includedTheme) {
        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);
      } else {
        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);
      }
    }, theme.styles);
  }
  return includedStyles;
}
function addStylesToTemplate(styles, template) {
  const styleEl = document.createElement("style");
  styleEl.innerHTML = styles.map((style) => style.cssText).join("\n");
  template.content.appendChild(styleEl);
}
function getThemes(tagName) {
  const defaultModuleName = `${tagName}-default-theme`;
  const themes = getAllThemes().filter((theme) => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName)).map((theme) => ({
    ...theme,
    styles: [...getIncludedStyles(theme), ...theme.styles],
    includePriority: getIncludePriority(theme.moduleId)
  })).sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);
  if (themes.length > 0) {
    return themes;
  }
  return getAllThemes().filter((theme) => theme.moduleId === defaultModuleName);
}
function hasThemes(tagName) {
  return classHasThemes(customElements.get(tagName));
}
function classHasThemes(elementClass) {
  return elementClass && Object.prototype.hasOwnProperty.call(elementClass, "__themes");
}
var ThemableMixin = (superClass) => class VaadinThemableMixin extends ThemePropertyMixin(superClass) {
  static finalize() {
    super.finalize();
    if (this.elementStyles) {
      return;
    }
    const template = this.prototype._template;
    if (!template || classHasThemes(this)) {
      return;
    }
    addStylesToTemplate(this.getStylesForThis(), template);
  }
  static finalizeStyles(styles) {
    const themeStyles = this.getStylesForThis();
    return styles ? [...super.finalizeStyles(styles), ...themeStyles] : themeStyles;
  }
  static getStylesForThis() {
    const parent = Object.getPrototypeOf(this.prototype);
    const inheritedThemes = (parent ? parent.constructor.__themes : []) || [];
    this.__themes = [...inheritedThemes, ...getThemes(this.is)];
    const themeStyles = this.__themes.flatMap((theme) => theme.styles);
    return themeStyles.filter((style, index) => index === themeStyles.lastIndexOf(style));
  }
};

export {
  ThemePropertyMixin,
  themeRegistry,
  registerStyles,
  ThemableMixin
};
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-SPVNJBW3.js.map
