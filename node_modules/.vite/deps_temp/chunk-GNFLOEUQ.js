import {
  cssFromModules
} from "./chunk-A5QYNKPK.js";

// node_modules/@webcomponents/shadycss/src/document-wait.js
var readyPromise = null;
var whenReady = window["HTMLImports"] && window["HTMLImports"]["whenReady"] || null;
var resolveFn;
function documentWait(callback) {
  requestAnimationFrame(function() {
    if (whenReady) {
      whenReady(callback);
    } else {
      if (!readyPromise) {
        readyPromise = new Promise((resolve) => {
          resolveFn = resolve;
        });
        if (document.readyState === "complete") {
          resolveFn();
        } else {
          document.addEventListener("readystatechange", () => {
            if (document.readyState === "complete") {
              resolveFn();
            }
          });
        }
      }
      readyPromise.then(function() {
        callback && callback();
      });
    }
  });
}

// node_modules/@webcomponents/shadycss/src/custom-style-interface.js
var SEEN_MARKER = "__seenByShadyCSS";
var CACHED_STYLE = "__shadyCSSCachedStyle";
var transformFn = null;
var validateFn = null;
var CustomStyleInterface = class {
  constructor() {
    this["customStyles"] = [];
    this["enqueued"] = false;
    documentWait(() => {
      if (window["ShadyCSS"]["flushCustomStyles"]) {
        window["ShadyCSS"]["flushCustomStyles"]();
      }
    });
  }
  enqueueDocumentValidation() {
    if (this["enqueued"] || !validateFn) {
      return;
    }
    this["enqueued"] = true;
    documentWait(validateFn);
  }
  addCustomStyle(style) {
    if (!style[SEEN_MARKER]) {
      style[SEEN_MARKER] = true;
      this["customStyles"].push(style);
      this.enqueueDocumentValidation();
    }
  }
  getStyleForCustomStyle(customStyle) {
    if (customStyle[CACHED_STYLE]) {
      return customStyle[CACHED_STYLE];
    }
    let style;
    if (customStyle["getStyle"]) {
      style = customStyle["getStyle"]();
    } else {
      style = customStyle;
    }
    return style;
  }
  processStyles() {
    const cs = this["customStyles"];
    for (let i = 0; i < cs.length; i++) {
      const customStyle = cs[i];
      if (customStyle[CACHED_STYLE]) {
        continue;
      }
      const style = this.getStyleForCustomStyle(customStyle);
      if (style) {
        const styleToTransform = style["__appliedElement"] || style;
        if (transformFn) {
          transformFn(styleToTransform);
        }
        customStyle[CACHED_STYLE] = styleToTransform;
      }
    }
    return cs;
  }
};
CustomStyleInterface.prototype["addCustomStyle"] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype["getStyleForCustomStyle"] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype["processStyles"] = CustomStyleInterface.prototype.processStyles;
Object.defineProperties(CustomStyleInterface.prototype, {
  "transformCallback": {
    get() {
      return transformFn;
    },
    set(fn) {
      transformFn = fn;
    }
  },
  "validateCallback": {
    get() {
      return validateFn;
    },
    set(fn) {
      let needsEnqueue = false;
      if (!validateFn) {
        needsEnqueue = true;
      }
      validateFn = fn;
      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    }
  }
});

// node_modules/@webcomponents/shadycss/src/common-regex.js
var VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
var MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
var MEDIA_MATCH = /@media\s(.*)/;

// node_modules/@webcomponents/shadycss/src/common-utils.js
function updateNativeProperties(element, properties) {
  for (let p in properties) {
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}
function getComputedStyleValue(element, property) {
  const value = window.getComputedStyle(element).getPropertyValue(property);
  if (!value) {
    return "";
  } else {
    return value.trim();
  }
}
function detectMixin(cssText) {
  const has = MIXIN_MATCH.test(cssText) || VAR_ASSIGN.test(cssText);
  MIXIN_MATCH.lastIndex = 0;
  VAR_ASSIGN.lastIndex = 0;
  return has;
}

// node_modules/@webcomponents/shadycss/src/style-settings.js
var nativeShadow = !(window["ShadyDOM"] && window["ShadyDOM"]["inUse"]);
var nativeCssVariables_;
function calcCssVariables(settings) {
  if (settings && settings.shimcssproperties) {
    nativeCssVariables_ = false;
  } else {
    nativeCssVariables_ = nativeShadow || Boolean(
      !navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports("box-shadow", "0 0 0 var(--foo)")
    );
  }
}
var cssBuild;
if (window.ShadyCSS && window.ShadyCSS.cssBuild !== void 0) {
  cssBuild = window.ShadyCSS.cssBuild;
}
var disableRuntime = Boolean(
  window.ShadyCSS && window.ShadyCSS.disableRuntime
);
if (window.ShadyCSS && window.ShadyCSS.nativeCss !== void 0) {
  nativeCssVariables_ = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS);
  window.ShadyCSS = void 0;
} else {
  calcCssVariables(window["WebComponents"] && window["WebComponents"]["flags"]);
}
var nativeCssVariables = nativeCssVariables_;

// node_modules/@webcomponents/shadycss/entrypoints/custom-style-interface.js
var customStyleInterface = new CustomStyleInterface();
if (!window.ShadyCSS) {
  window.ShadyCSS = {
    prepareTemplate(template, elementName, elementExtends) {
    },
    prepareTemplateDom(template, elementName) {
    },
    prepareTemplateStyles(template, elementName, elementExtends) {
    },
    styleSubtree(element, properties) {
      customStyleInterface.processStyles();
      updateNativeProperties(element, properties);
    },
    styleElement(element) {
      customStyleInterface.processStyles();
    },
    styleDocument(properties) {
      customStyleInterface.processStyles();
      updateNativeProperties(document.body, properties);
    },
    getComputedStyleValue(element, property) {
      return getComputedStyleValue(element, property);
    },
    flushCustomStyles() {
    },
    nativeCss: nativeCssVariables,
    nativeShadow,
    cssBuild,
    disableRuntime
  };
}
window.ShadyCSS.CustomStyleInterface = customStyleInterface;

// node_modules/@polymer/polymer/lib/elements/custom-style.js
var attr = "include";
var CustomStyleInterface2 = window.ShadyCSS.CustomStyleInterface;
var CustomStyle = class extends HTMLElement {
  constructor() {
    super();
    this._style = null;
    CustomStyleInterface2.addCustomStyle(this);
  }
  getStyle() {
    if (this._style) {
      return this._style;
    }
    const style = this.querySelector("style");
    if (!style) {
      return null;
    }
    this._style = style;
    const include = style.getAttribute(attr);
    if (include) {
      style.removeAttribute(attr);
      style.textContent = cssFromModules(include) + style.textContent;
    }
    if (this.ownerDocument !== window.document) {
      window.document.head.appendChild(this);
    }
    return this._style;
  }
};
window.customElements.define("custom-style", CustomStyle);

export {
  nativeShadow,
  cssBuild,
  disableRuntime,
  nativeCssVariables,
  VAR_ASSIGN,
  MIXIN_MATCH,
  MEDIA_MATCH,
  updateNativeProperties,
  getComputedStyleValue,
  detectMixin
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
//# sourceMappingURL=chunk-GNFLOEUQ.js.map
