{
  "version": 3,
  "sources": ["../../@polymer/polymer/lib/elements/dom-repeat.js"],
  "sourcesContent": ["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\n\nimport { TemplateInstanceBase, templatize, modelForElement } from '../utils/templatize.js'; // eslint-disable-line no-unused-vars\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { OptionalMutableData } from '../mixins/mutable-data.js';\nimport { matches, translate } from '../utils/path.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\nimport { hideElementsGlobally } from '../utils/hide-template-controls.js';\nimport { suppressTemplateNotifications } from '../utils/settings.js';\n\n/**\n * @constructor\n * @implements {Polymer_OptionalMutableData}\n * @extends {PolymerElement}\n * @private\n */\nconst domRepeatBase = OptionalMutableData(PolymerElement);\n\n/**\n * The `<dom-repeat>` element will automatically stamp and binds one instance\n * of template content to each object in a user-provided array.\n * `dom-repeat` accepts an `items` property, and one instance of the template\n * is stamped for each item into the DOM at the location of the `dom-repeat`\n * element.  The `item` property will be set on each instance's binding\n * scope, thus templates should bind to sub-properties of `item`.\n *\n * Example:\n *\n * ```html\n * <dom-module id=\"employee-list\">\n *\n *   <template>\n *\n *     <div> Employee list: </div>\n *     <dom-repeat items=\"{{employees}}\">\n *       <template>\n *         <div>First name: <span>{{item.first}}</span></div>\n *         <div>Last name: <span>{{item.last}}</span></div>\n *       </template>\n *     </dom-repeat>\n *\n *   </template>\n *\n * </dom-module>\n * ```\n *\n * With the following custom element definition:\n *\n * ```js\n * class EmployeeList extends PolymerElement {\n *   static get is() { return 'employee-list'; }\n *   static get properties() {\n *     return {\n *       employees: {\n *         value() {\n *           return [\n *             {first: 'Bob', last: 'Smith'},\n *             {first: 'Sally', last: 'Johnson'},\n *             ...\n *           ];\n *         }\n *       }\n *     };\n *   }\n * }\n * ```\n *\n * Notifications for changes to items sub-properties will be forwarded to template\n * instances, which will update via the normal structured data notification system.\n *\n * Mutations to the `items` array itself should be made using the Array\n * mutation API's on the PropertyEffects mixin (`push`, `pop`, `splice`,\n * `shift`, `unshift`), and template instances will be kept in sync with the\n * data in the array.\n *\n * Events caught by event handlers within the `dom-repeat` template will be\n * decorated with a `model` property, which represents the binding scope for\n * each template instance.  The model should be used to manipulate data on the\n * instance, for example `event.model.set('item.checked', true);`.\n *\n * Alternatively, the model for a template instance for an element stamped by\n * a `dom-repeat` can be obtained using the `modelForElement` API on the\n * `dom-repeat` that stamped it, for example\n * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.\n * This may be useful for manipulating instance data of event targets obtained\n * by event handlers on parents of the `dom-repeat` (event delegation).\n *\n * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a\n * `filter` and/or `sort` property.  This may be a string that names a function on\n * the host, or a function may be assigned to the property directly.  The functions\n * should implemented following the standard `Array` filter/sort API.\n *\n * In order to re-run the filter or sort functions based on changes to sub-fields\n * of `items`, the `observe` property may be set as a space-separated list of\n * `item` sub-fields that should cause a re-filter/sort when modified.  If\n * the filter or sort function depends on properties not contained in `items`,\n * the user should observe changes to those properties and call `render` to update\n * the view based on the dependency change.\n *\n * For example, for an `dom-repeat` with a filter of the following:\n *\n * ```js\n * isEngineer(item) {\n *   return item.type == 'engineer' || item.manager.type == 'engineer';\n * }\n * ```\n *\n * Then the `observe` property should be configured as follows:\n *\n * ```html\n * <dom-repeat items=\"{{employees}}\" filter=\"isEngineer\" observe=\"type manager.type\">\n * ```\n *\n * @customElement\n * @polymer\n * @extends {domRepeatBase}\n * @appliesMixin OptionalMutableData\n * @summary Custom element for stamping instance of a template bound to\n *   items in an array.\n */\nexport class DomRepeat extends domRepeatBase {\n\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() { return 'dom-repeat'; }\n\n  static get template() { return null; }\n\n  static get properties() {\n\n    /**\n     * Fired whenever DOM is added or removed by this template (by\n     * default, rendering occurs lazily).  To force immediate rendering, call\n     * `render`.\n     *\n     * @event dom-change\n     */\n    return {\n\n      /**\n       * An array containing items determining how many instances of the template\n       * to stamp and that that each template instance should bind to.\n       */\n      items: {\n        type: Array\n      },\n\n      /**\n       * The name of the variable to add to the binding scope for the array\n       * element associated with a given template instance.\n       */\n      as: {\n        type: String,\n        value: 'item'\n      },\n\n      /**\n       * The name of the variable to add to the binding scope with the index\n       * of the instance in the sorted and filtered list of rendered items.\n       * Note, for the index in the `this.items` array, use the value of the\n       * `itemsIndexAs` property.\n       */\n      indexAs: {\n        type: String,\n        value: 'index'\n      },\n\n      /**\n       * The name of the variable to add to the binding scope with the index\n       * of the instance in the `this.items` array. Note, for the index of\n       * this instance in the sorted and filtered list of rendered items,\n       * use the value of the `indexAs` property.\n       */\n      itemsIndexAs: {\n        type: String,\n        value: 'itemsIndex'\n      },\n\n      /**\n       * A function that should determine the sort order of the items.  This\n       * property should either be provided as a string, indicating a method\n       * name on the element's host, or else be an actual function.  The\n       * function should match the sort function passed to `Array.sort`.\n       * Using a sort function has no effect on the underlying `items` array.\n       */\n      sort: {\n        type: Function,\n        observer: '__sortChanged'\n      },\n\n      /**\n       * A function that can be used to filter items out of the view.  This\n       * property should either be provided as a string, indicating a method\n       * name on the element's host, or else be an actual function.  The\n       * function should match the sort function passed to `Array.filter`.\n       * Using a filter function has no effect on the underlying `items` array.\n       */\n      filter: {\n        type: Function,\n        observer: '__filterChanged'\n      },\n\n      /**\n       * When using a `filter` or `sort` function, the `observe` property\n       * should be set to a space-separated list of the names of item\n       * sub-fields that should trigger a re-sort or re-filter when changed.\n       * These should generally be fields of `item` that the sort or filter\n       * function depends on.\n       */\n      observe: {\n        type: String,\n        observer: '__observeChanged'\n      },\n\n      /**\n       * When using a `filter` or `sort` function, the `delay` property\n       * determines a debounce time in ms after a change to observed item\n       * properties that must pass before the filter or sort is re-run.\n       * This is useful in rate-limiting shuffling of the view when\n       * item changes may be frequent.\n       */\n      delay: Number,\n\n      /**\n       * Count of currently rendered items after `filter` (if any) has been applied.\n       * If \"chunking mode\" is enabled, `renderedItemCount` is updated each time a\n       * set of template instances is rendered.\n       *\n       */\n      renderedItemCount: {\n        type: Number,\n        notify: !suppressTemplateNotifications,\n        readOnly: true\n      },\n\n      /**\n       * When greater than zero, defines an initial count of template instances\n       * to render after setting the `items` array, before the next paint, and\n       * puts the `dom-repeat` into \"chunking mode\".  The remaining items (and\n       * any future items as a result of pushing onto the array) will be created\n       * and rendered incrementally at each animation frame thereof until all\n       * instances have been rendered.\n       */\n      initialCount: {\n        type: Number\n      },\n\n      /**\n       * When `initialCount` is used, this property defines a frame rate (in\n       * fps) to target by throttling the number of instances rendered each\n       * frame to not exceed the budget for the target frame rate.  The\n       * framerate is effectively the number of `requestAnimationFrame`s that\n       * it tries to allow to actually fire in a given second. It does this\n       * by measuring the time between `rAF`s and continuously adjusting the\n       * number of items created each `rAF` to maintain the target framerate.\n       * Setting this to a higher number allows lower latency and higher\n       * throughput for event handlers and other tasks, but results in a\n       * longer time for the remaining items to complete rendering.\n       */\n      targetFramerate: {\n        type: Number,\n        value: 20\n      },\n\n      _targetFrameTime: {\n        type: Number,\n        computed: '__computeFrameTime(targetFramerate)'\n      },\n\n      /**\n       * When the global `suppressTemplateNotifications` setting is used, setting\n       * `notifyDomChange: true` will enable firing `dom-change` events on this\n       * element.\n       */\n      notifyDomChange: {\n        type: Boolean\n      },\n\n      /**\n       * When chunking is enabled via `initialCount` and the `items` array is\n       * set to a new array, this flag controls whether the previously rendered\n       * instances are reused or not.\n       *\n       * When `true`, any previously rendered template instances are updated in\n       * place to their new item values synchronously in one shot, and then any\n       * further items (if any) are chunked out.  When `false`, the list is\n       * returned back to its `initialCount` (any instances over the initial\n       * count are discarded) and the remainder of the list is chunked back in.\n       * Set this to `true` to avoid re-creating the list and losing scroll\n       * position, although note that when changing the list to completely\n       * different data the render thread will be blocked until all existing\n       * instances are updated to their new data.\n       */\n      reuseChunkedInstances: {\n        type: Boolean\n      }\n\n    };\n\n  }\n\n  static get observers() {\n    return [ '__itemsChanged(items.*)' ];\n  }\n\n  constructor() {\n    super();\n    this.__instances = [];\n    this.__renderDebouncer = null;\n    this.__itemsIdxToInstIdx = {};\n    this.__chunkCount = null;\n    this.__renderStartTime = null;\n    this.__itemsArrayChanged = false;\n    this.__shouldMeasureChunk = false;\n    this.__shouldContinueChunking = false;\n    this.__chunkingId = 0;\n    this.__sortFn = null;\n    this.__filterFn = null;\n    this.__observePaths = null;\n    /** @type {?function(new:TemplateInstanceBase, Object=)} */\n    this.__ctor = null;\n    this.__isDetached = true;\n    this.template = null;\n    /** @type {TemplateInfo} */\n    this._templateInfo;\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__isDetached = true;\n    for (let i=0; i<this.__instances.length; i++) {\n      this.__detachInstance(i);\n    }\n    // Stop chunking if one was in progress\n    if (this.__chunkingId) {\n      cancelAnimationFrame(this.__chunkingId);\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    if (!hideElementsGlobally()) {\n      this.style.display = 'none';\n    }\n    // only perform attachment if the element was previously detached.\n    if (this.__isDetached) {\n      this.__isDetached = false;\n      let wrappedParent = wrap(wrap(this).parentNode);\n      for (let i=0; i<this.__instances.length; i++) {\n        this.__attachInstance(i, wrappedParent);\n      }\n      // Restart chunking if one was in progress when disconnected\n      if (this.__chunkingId) {\n        this.__render();\n      }\n    }\n  }\n\n  __ensureTemplatized() {\n    // Templatizing (generating the instance constructor) needs to wait\n    // until ready, since won't have its template content handed back to\n    // it until then\n    if (!this.__ctor) {\n      // When `removeNestedTemplates` is true, the \"template\" is the element\n      // itself, which has been given a `_templateInfo` property\n      const thisAsTemplate = /** @type {!HTMLTemplateElement} */ (\n          /** @type {!HTMLElement} */ (this));\n      let template = this.template = thisAsTemplate._templateInfo ?\n          thisAsTemplate :\n          /** @type {!HTMLTemplateElement} */ (this.querySelector('template'));\n      if (!template) {\n        // Wait until childList changes and template should be there by then\n        let observer = new MutationObserver(() => {\n          if (this.querySelector('template')) {\n            observer.disconnect();\n            this.__render();\n          } else {\n            throw new Error('dom-repeat requires a <template> child');\n          }\n        });\n        observer.observe(this, {childList: true});\n        return false;\n      }\n      // Template instance props that should be excluded from forwarding\n      let instanceProps = {};\n      instanceProps[this.as] = true;\n      instanceProps[this.indexAs] = true;\n      instanceProps[this.itemsIndexAs] = true;\n      this.__ctor = templatize(template, this, {\n        mutableData: this.mutableData,\n        parentModel: true,\n        instanceProps: instanceProps,\n        /**\n         * @this {DomRepeat}\n         * @param {string} prop Property to set\n         * @param {*} value Value to set property to\n         */\n        forwardHostProp: function(prop, value) {\n          let i$ = this.__instances;\n          for (let i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {\n            inst.forwardHostProp(prop, value);\n          }\n        },\n        /**\n         * @this {DomRepeat}\n         * @param {Object} inst Instance to notify\n         * @param {string} prop Property to notify\n         * @param {*} value Value to notify\n         */\n        notifyInstanceProp: function(inst, prop, value) {\n          if (matches(this.as, prop)) {\n            let idx = inst[this.itemsIndexAs];\n            if (prop == this.as) {\n              this.items[idx] = value;\n            }\n            let path = translate(this.as, `${JSCompiler_renameProperty('items', this)}.${idx}`, prop);\n            this.notifyPath(path, value);\n          }\n        }\n      });\n    }\n    return true;\n  }\n\n  __getMethodHost() {\n    // Technically this should be the owner of the outermost template.\n    // In shadow dom, this is always getRootNode().host, but we can\n    // approximate this via cooperation with our dataHost always setting\n    // `_methodHost` as long as there were bindings (or id's) on this\n    // instance causing it to get a dataHost.\n    return this.__dataHost._methodHost || this.__dataHost;\n  }\n\n  __functionFromPropertyValue(functionOrMethodName) {\n    if (typeof functionOrMethodName === 'string') {\n      let methodName = functionOrMethodName;\n      let obj = this.__getMethodHost();\n      return function() { return obj[methodName].apply(obj, arguments); };\n    }\n\n    return functionOrMethodName;\n  }\n\n  __sortChanged(sort) {\n    this.__sortFn = this.__functionFromPropertyValue(sort);\n    if (this.items) { this.__debounceRender(this.__render); }\n  }\n\n  __filterChanged(filter) {\n    this.__filterFn = this.__functionFromPropertyValue(filter);\n    if (this.items) { this.__debounceRender(this.__render); }\n  }\n\n  __computeFrameTime(rate) {\n    return Math.ceil(1000/rate);\n  }\n\n  __observeChanged() {\n    this.__observePaths = this.observe &&\n      this.observe.replace('.*', '.').split(' ');\n  }\n\n  __handleObservedPaths(path) {\n    // Handle cases where path changes should cause a re-sort/filter\n    if (this.__sortFn || this.__filterFn) {\n      if (!path) {\n        // Always re-render if the item itself changed\n        this.__debounceRender(this.__render, this.delay);\n      } else if (this.__observePaths) {\n        // Otherwise, re-render if the path changed matches an observed path\n        let paths = this.__observePaths;\n        for (let i=0; i<paths.length; i++) {\n          if (path.indexOf(paths[i]) === 0) {\n            this.__debounceRender(this.__render, this.delay);\n          }\n        }\n      }\n    }\n  }\n\n  __itemsChanged(change) {\n    if (this.items && !Array.isArray(this.items)) {\n      console.warn('dom-repeat expected array for `items`, found', this.items);\n    }\n    // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the\n    // path to that instance synchronously (returns false for non-item paths)\n    if (!this.__handleItemPath(change.path, change.value)) {\n      // Otherwise, the array was reset ('items') or spliced ('items.splices'),\n      // so queue a render.  Restart chunking when the items changed (for\n      // backward compatibility), unless `reuseChunkedInstances` option is set\n      if (change.path === 'items') {\n        this.__itemsArrayChanged = true;\n      }\n      this.__debounceRender(this.__render);\n    }\n  }\n\n  /**\n   * @param {function(this:DomRepeat)} fn Function to debounce.\n   * @param {number=} delay Delay in ms to debounce by.\n   */\n  __debounceRender(fn, delay = 0) {\n    this.__renderDebouncer = Debouncer.debounce(\n          this.__renderDebouncer\n        , delay > 0 ? timeOut.after(delay) : microTask\n        , fn.bind(this));\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   * @return {void}\n   */\n  render() {\n    // Queue this repeater, then flush all in order\n    this.__debounceRender(this.__render);\n    flush();\n  }\n\n  __render() {\n    if (!this.__ensureTemplatized()) {\n      // No template found yet\n      return;\n    }\n    let items = this.items || [];\n    // Sort and filter the items into a mapping array from instance->item\n    const isntIdxToItemsIdx = this.__sortAndFilterItems(items);\n    // If we're chunking, increase the limit if there are new instances to\n    // create and schedule the next chunk\n    const limit = this.__calculateLimit(isntIdxToItemsIdx.length);\n    // Create, update, and/or remove instances\n    this.__updateInstances(items, limit, isntIdxToItemsIdx);\n    // If we're chunking, schedule a rAF task to measure/continue chunking.     \n    // Do this before any notifying events (renderedItemCount & dom-change)\n    // since those could modify items and enqueue a new full render which will\n    // pre-empt this measurement.\n    if (this.initialCount &&\n       (this.__shouldMeasureChunk || this.__shouldContinueChunking)) {\n      cancelAnimationFrame(this.__chunkingId);\n      this.__chunkingId = requestAnimationFrame(() => {\n        this.__chunkingId = null;\n        this.__continueChunking();\n      });\n    }\n    // Set rendered item count\n    this._setRenderedItemCount(this.__instances.length);\n    // Notify users\n    if (!suppressTemplateNotifications || this.notifyDomChange) {\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n    }\n  }\n\n  __sortAndFilterItems(items) {\n    // Generate array maping the instance index to the items array index\n    let isntIdxToItemsIdx = new Array(items.length);\n    for (let i=0; i<items.length; i++) {\n      isntIdxToItemsIdx[i] = i;\n    }\n    // Apply user filter\n    if (this.__filterFn) {\n      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) =>\n        this.__filterFn(items[i], idx, array));\n    }\n    // Apply user sort\n    if (this.__sortFn) {\n      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));\n    }\n    return isntIdxToItemsIdx;\n  }\n\n  __calculateLimit(filteredItemCount) {\n    let limit = filteredItemCount;\n    const currentCount = this.__instances.length;\n    // When chunking, we increase the limit from the currently rendered count\n    // by the chunk count that is re-calculated after each rAF (with special\n    // cases for resetting the limit to initialCount after changing items)\n    if (this.initialCount) {\n      let newCount;\n      if (!this.__chunkCount ||\n        (this.__itemsArrayChanged && !this.reuseChunkedInstances)) {\n        // Limit next render to the initial count\n        limit = Math.min(filteredItemCount, this.initialCount);\n        // Subtract off any existing instances to determine the number of\n        // instances that will be created\n        newCount = Math.max(limit - currentCount, 0);\n        // Initialize the chunk size with how many items we're creating\n        this.__chunkCount = newCount || 1;\n      } else {\n        // The number of new instances that will be created is based on the\n        // existing instances, the new list size, and the chunk size\n        newCount = Math.min(\n          Math.max(filteredItemCount - currentCount, 0), \n          this.__chunkCount);\n        // Update the limit based on how many new items we're making, limited\n        // buy the total size of the list\n        limit = Math.min(currentCount + newCount, filteredItemCount);\n      }\n      // Record some state about chunking for use in `__continueChunking`\n      this.__shouldMeasureChunk = newCount === this.__chunkCount;\n      this.__shouldContinueChunking = limit < filteredItemCount;\n      this.__renderStartTime = performance.now();\n    }\n    this.__itemsArrayChanged = false;\n    return limit;\n  }\n\n  __continueChunking() {\n    // Simple auto chunkSize throttling algorithm based on feedback loop:\n    // measure actual time between frames and scale chunk count by ratio of\n    // target/actual frame time.  Only modify chunk size if our measurement\n    // reflects the cost of a creating a full chunk's worth of instances; this\n    // avoids scaling up the chunk size if we e.g. quickly re-rendered instances\n    // in place\n    if (this.__shouldMeasureChunk) {\n      const renderTime = performance.now() - this.__renderStartTime;\n      const ratio = this._targetFrameTime / renderTime;\n      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;\n    }\n    // Enqueue a new render if we haven't reached the full size of the list\n    if (this.__shouldContinueChunking) {\n      this.__debounceRender(this.__render);\n    }\n  }\n  \n  __updateInstances(items, limit, isntIdxToItemsIdx) {\n    // items->inst map kept for item path forwarding\n    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};\n    let instIdx;\n    // Generate instances and assign items\n    for (instIdx=0; instIdx<limit; instIdx++) {\n      let inst = this.__instances[instIdx];\n      let itemIdx = isntIdxToItemsIdx[instIdx];\n      let item = items[itemIdx];\n      itemsIdxToInstIdx[itemIdx] = instIdx;\n      if (inst) {\n        inst._setPendingProperty(this.as, item);\n        inst._setPendingProperty(this.indexAs, instIdx);\n        inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n        inst._flushProperties();\n      } else {\n        this.__insertInstance(item, instIdx, itemIdx);\n      }\n    }\n    // Remove any extra instances from previous state\n    for (let i=this.__instances.length-1; i>=instIdx; i--) {\n      this.__detachAndRemoveInstance(i);\n    }\n  }\n\n  __detachInstance(idx) {\n    let inst = this.__instances[idx];\n    const wrappedRoot = wrap(inst.root);\n    for (let i=0; i<inst.children.length; i++) {\n      let el = inst.children[i];\n      wrappedRoot.appendChild(el);\n    }\n    return inst;\n  }\n\n  __attachInstance(idx, parent) {\n    let inst = this.__instances[idx];\n    // Note, this is pre-wrapped as an optimization\n    parent.insertBefore(inst.root, this);\n  }\n\n  __detachAndRemoveInstance(idx) {\n    this.__detachInstance(idx);\n    this.__instances.splice(idx, 1);\n  }\n\n  __stampInstance(item, instIdx, itemIdx) {\n    let model = {};\n    model[this.as] = item;\n    model[this.indexAs] = instIdx;\n    model[this.itemsIndexAs] = itemIdx;\n    return new this.__ctor(model);\n  }\n\n  __insertInstance(item, instIdx, itemIdx) {\n    const inst = this.__stampInstance(item, instIdx, itemIdx);\n    let beforeRow = this.__instances[instIdx + 1];\n    let beforeNode = beforeRow ? beforeRow.children[0] : this;\n    wrap(wrap(this).parentNode).insertBefore(inst.root, beforeNode);\n    this.__instances[instIdx] = inst;\n    return inst;\n  }\n\n  // Implements extension point from Templatize mixin\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @param {boolean} hidden Set to true to hide the children;\n   * set to false to show them.\n   * @return {void}\n   * @protected\n   */\n  _showHideChildren(hidden) {\n    for (let i=0; i<this.__instances.length; i++) {\n      this.__instances[i]._showHideChildren(hidden);\n    }\n  }\n\n  // Called as a side effect of a host items.<key>.<path> path change,\n  // responsible for notifying item.<path> changes to inst for key\n  __handleItemPath(path, value) {\n    let itemsPath = path.slice(6); // 'items.'.length == 6\n    let dot = itemsPath.indexOf('.');\n    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);\n    // If path was index into array...\n    if (itemsIdx == parseInt(itemsIdx, 10)) {\n      let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot+1);\n      // If the path is observed, it will trigger a full refresh\n      this.__handleObservedPaths(itemSubPath);\n      // Note, even if a rull refresh is triggered, always do the path\n      // notification because unless mutableData is used for dom-repeat\n      // and all elements in the instance subtree, a full refresh may\n      // not trigger the proper update.\n      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];\n      let inst = this.__instances[instIdx];\n      if (inst) {\n        let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');\n        // This is effectively `notifyPath`, but avoids some of the overhead\n        // of the public API\n        inst._setPendingPropertyOrPath(itemPath, value, false, true);\n        inst._flushProperties();\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Returns the item associated with a given element stamped by\n   * this `dom-repeat`.\n   *\n   * Note, to modify sub-properties of the item,\n   * `modelForElement(el).set('item.<sub-prop>', value)`\n   * should be used.\n   *\n   * @param {!HTMLElement} el Element for which to return the item.\n   * @return {*} Item associated with the element.\n   */\n  itemForElement(el) {\n    let instance = this.modelForElement(el);\n    return instance && instance[this.as];\n  }\n\n  /**\n   * Returns the inst index for a given element stamped by this `dom-repeat`.\n   * If `sort` is provided, the index will reflect the sorted order (rather\n   * than the original array order).\n   *\n   * @param {!HTMLElement} el Element for which to return the index.\n   * @return {?number} Row index associated with the element (note this may\n   *   not correspond to the array index if a user `sort` is applied).\n   */\n  indexForElement(el) {\n    let instance = this.modelForElement(el);\n    return instance && instance[this.indexAs];\n  }\n\n  /**\n   * Returns the template \"model\" associated with a given element, which\n   * serves as the binding scope for the template instance the element is\n   * contained in. A template model\n   * should be used to manipulate data associated with this template instance.\n   *\n   * Example:\n   *\n   *   let model = modelForElement(el);\n   *   if (model.index < 10) {\n   *     model.set('item.checked', true);\n   *   }\n   *\n   * @param {!HTMLElement} el Element for which to return a template model.\n   * @return {TemplateInstanceBase} Model representing the binding scope for\n   *   the element.\n   */\n  modelForElement(el) {\n    return modelForElement(this.template, el);\n  }\n\n}\n\ncustomElements.define(DomRepeat.is, DomRepeat);\n"],
  "mappings": "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",
  "names": []
}
