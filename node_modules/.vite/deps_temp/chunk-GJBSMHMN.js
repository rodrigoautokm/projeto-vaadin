import {
  Iconset,
  ensureSvgLiteral,
  renderSvg
} from "./chunk-S5DBGBVD.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";

// node_modules/@vaadin/icon/theme/lumo/vaadin-icon-styles.js
registerStyles(
  "vaadin-icon",
  css`
    :host {
      width: var(--lumo-icon-size-m);
      height: var(--lumo-icon-size-m);
    }
  `,
  { moduleId: "lumo-icon" }
);

// node_modules/@vaadin/icon/src/vaadin-icon.js
var DEFAULT_ICONSET = "vaadin";
var Icon = class extends ThemableMixin(ElementMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: inline-flex;
          justify-content: center;
          align-items: center;
          box-sizing: border-box;
          vertical-align: middle;
          width: 24px;
          height: 24px;
          fill: currentColor;
        }

        :host([hidden]) {
          display: none !important;
        }

        svg {
          display: block;
          width: 100%;
          height: 100%;
        }
      </style>
      <svg
        version="1.1"
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        viewBox="[[__computeViewBox(size, __viewBox)]]"
        preserveAspectRatio="xMidYMid meet"
        aria-hidden="true"
      ></svg>
    `;
  }
  static get is() {
    return "vaadin-icon";
  }
  static get properties() {
    return {
      icon: {
        type: String,
        observer: "__iconChanged"
      },
      svg: {
        type: Object
      },
      size: {
        type: Number,
        value: 24
      },
      __svgElement: Object,
      __viewBox: String
    };
  }
  static get observers() {
    return ["__svgChanged(svg, __svgElement)"];
  }
  constructor() {
    super();
    this.__onIconsetRegistered = this.__onIconsetRegistered.bind(this);
  }
  ready() {
    super.ready();
    this.__svgElement = this.shadowRoot.querySelector("svg");
  }
  __getIconsetName(icon) {
    if (!icon) {
      return;
    }
    const parts = icon.split(":");
    return parts[0] || DEFAULT_ICONSET;
  }
  __onIconsetRegistered(e) {
    if (e.detail === this.__getIconsetName(this.icon)) {
      this.__iconChanged(this.icon);
    }
  }
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("vaadin-iconset-registered", this.__onIconsetRegistered);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("vaadin-iconset-registered", this.__onIconsetRegistered);
  }
  __iconChanged(icon) {
    if (icon) {
      this.__checkDeprecatedIcon(icon);
      const iconsetName = this.__getIconsetName(icon);
      const iconset = Iconset.getIconset(iconsetName);
      const { svg, size, viewBox } = iconset.applyIcon(icon);
      if (viewBox) {
        this.__viewBox = viewBox;
      }
      if (size !== this.size) {
        this.size = size;
      }
      this.svg = svg;
    } else {
      this.svg = ensureSvgLiteral(null);
    }
  }
  __checkDeprecatedIcon(icon) {
    const deprecatedIcons = {
      "vaadin:buss": "vaadin:bus",
      "vaadin:funcion": "vaadin:function",
      "vaadin:megafone": "vaadin:megaphone",
      "vaadin:palete": "vaadin:palette",
      "vaadin:trendind-down": "vaadin:trending-down"
    };
    if (icon in deprecatedIcons) {
      console.warn(`WARNING: The icon "${icon}" is deprecated. Use "${deprecatedIcons[icon]}" instead`);
    }
  }
  __svgChanged(svg, svgElement) {
    if (!svgElement) {
      return;
    }
    renderSvg(svg, svgElement);
  }
  __computeViewBox(size, viewBox) {
    return viewBox || `0 0 ${size} ${size}`;
  }
};
customElements.define(Icon.is, Icon);

export {
  Icon
};
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-GJBSMHMN.js.map
