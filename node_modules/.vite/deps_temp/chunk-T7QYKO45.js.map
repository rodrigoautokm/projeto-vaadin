{
  "version": 3,
  "sources": ["../../@vaadin/component-base/src/iron-list-core.js", "../../@vaadin/component-base/src/virtualizer-iron-list-adapter.js", "../../@vaadin/component-base/src/virtualizer.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { animationFrame, idlePeriod, microTask } from './async.js';\nimport { Debouncer, enqueueDebouncer, flush } from './debounce.js';\n\nconst IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/);\nconst IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nconst DEFAULT_PHYSICAL_COUNT = 3;\n\n/**\n * @private\n */\nexport const ironList = {\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    return this._physicalSize - this._viewportHeight;\n  },\n\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    const virtualCount = this._virtualCount;\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    this._virtualStartVal = val;\n  },\n\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val %= this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    this._physicalStartVal = val;\n  },\n\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    let idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n\n      idx =\n        this._iterateItems((pidx, vidx) => {\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n\n          if (physicalOffset > this._scrollPosition) {\n            return vidx;\n          }\n        }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    let idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n      this._iterateItems((pidx, vidx) => {\n        if (physicalOffset < this._scrollBottom) {\n          idx = vidx;\n        }\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n      });\n\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler() {\n    const scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    let delta = scrollTop - this._scrollPosition;\n    const isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta -= this._scrollOffset;\n      const idxAdjustment = Math.round(delta / this._physicalAverage);\n      this._virtualStart += idxAdjustment;\n      this._physicalStart += idxAdjustment;\n      // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n      this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition);\n      this._update();\n    } else if (this._physicalCount > 0) {\n      const reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart += reusables.indexes.length;\n        this._physicalStart += reusables.indexes.length;\n      } else {\n        this._virtualStart -= reusables.indexes.length;\n        this._physicalStart -= reusables.indexes.length;\n      }\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), microTask);\n    }\n  },\n\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables(fromTop) {\n    let ith, offsetContent, physicalItemHeight;\n    const idxs = [];\n    const protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    const virtualStart = this._virtualStart;\n    const virtualEnd = this._virtualEnd;\n    const physicalCount = this._physicalCount;\n    let top = this._physicalTop + this._scrollOffset;\n    const bottom = this._physicalBottom + this._scrollOffset;\n    // This may be called outside of a scrollHandler, so use last cached position\n    const scrollTop = this._scrollPosition;\n    const scrollBottom = this._scrollBottom;\n\n    if (fromTop) {\n      ith = this._physicalStart;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      offsetContent = bottom - scrollBottom;\n    }\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent -= physicalItemHeight;\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top += physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top -= physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return { indexes: idxs, physicalTop: top - this._scrollOffset };\n  },\n\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update(itemSet, movingUp) {\n    if ((itemSet && itemSet.length === 0) || this._physicalCount === 0) {\n      return;\n    }\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        const idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n\n  _isClientFull() {\n    return (\n      this._scrollBottom !== 0 &&\n      this._physicalBottom - 1 >= this._scrollBottom &&\n      this._physicalTop <= this._scrollPosition\n    );\n  },\n\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded(count) {\n    const nextPhysicalCount = this._clamp(\n      this._physicalCount + count,\n      DEFAULT_PHYSICAL_COUNT,\n      this._virtualCount - this._virtualStart,\n    );\n    const delta = nextPhysicalCount - this._physicalCount;\n    let nextIncrease = Math.round(this._physicalCount * 0.5);\n\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      const ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n      for (let i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount += delta;\n      // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n      if (\n        this._physicalStart > this._physicalEnd &&\n        this._isIndexRendered(this._focusedVirtualIndex) &&\n        this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd\n      ) {\n        this._physicalStart += delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce(\n        '_increasePoolIfNeeded',\n        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)),\n        idlePeriod,\n      );\n    }\n  },\n\n  /**\n   * Renders the a new list.\n   */\n  _render() {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      const reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart += reusables.indexes.length;\n      this._physicalStart += reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged(change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      this._physicalCount = this._physicalCount || 0;\n      this._physicalItems = this._physicalItems || [];\n      this._physicalSizes = this._physicalSizes || [];\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._debounce('_render', this._render, animationFrame);\n    }\n  },\n\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems(fn, itemSet) {\n    let pidx, vidx, rtn, i;\n\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx(pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics(itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush();\n\n    let newPhysicalSize = 0;\n    let oldPhysicalSize = 0;\n    const prevAvgCount = this._physicalAverageCount;\n    const prevPhysicalAvg = this._physicalAverage;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._iterateItems((pidx, vidx) => {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n\n    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round(\n        (prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount,\n      );\n    }\n  },\n\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems() {\n    this._adjustScrollPosition();\n\n    let y = this._physicalTop;\n\n    this._iterateItems((pidx) => {\n      this.translate3d(0, `${y}px`, 0, this._physicalItems[pidx]);\n      y += this._physicalSizes[pidx];\n    });\n  },\n\n  _getPhysicalSizeIncrement(pidx) {\n    return this._physicalSizes[pidx];\n  },\n\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition() {\n    const deltaHeight =\n      this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop -= deltaHeight;\n      // This may be called outside of a scrollHandler, so use last cached position\n      const scrollTop = this._scrollPosition;\n      // Juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition(pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize(forceUpdate) {\n    this._estScrollHeight =\n      this._physicalBottom +\n      Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n\n    forceUpdate = forceUpdate || this._scrollHeight === 0;\n    forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._viewportHeight) {\n      this.$.items.style.height = `${this._estScrollHeight}px`;\n      this._scrollHeight = this._estScrollHeight;\n    }\n  },\n\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex(idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    flush();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = idx - 1;\n    }\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = this._virtualStart * this._physicalAverage;\n\n    let currentTopItem = this._physicalStart;\n    let currentVirtualItem = this._virtualStart;\n    let targetOffsetTop = 0;\n    const hiddenContentSize = this._hiddenContentSize;\n    // Scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop += this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem += 1;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // Clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage() {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler() {\n    this._debounce(\n      '_render',\n      () => {\n        // Clear cached visible index.\n        this._firstVisibleIndexVal = null;\n        this._lastVisibleIndexVal = null;\n        if (this._isVisible) {\n          this.updateViewportBoundaries();\n          // Reinstall the scroll event listener.\n          this.toggleScrollListener(true);\n          this._resetAverage();\n          this._render();\n        } else {\n          // Uninstall the scroll event listener.\n          this.toggleScrollListener(false);\n        }\n      },\n      animationFrame,\n    );\n  },\n\n  _isIndexRendered(idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n\n  _getPhysicalIndex(vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n\n  _clamp(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n\n  _debounce(name, cb, asyncModule) {\n    this._debouncers = this._debouncers || {};\n    this._debouncers[name] = Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  },\n};\n", "/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { animationFrame, timeOut } from './async.js';\nimport { isSafari } from './browser-utils.js';\nimport { Debouncer, flush } from './debounce.js';\nimport { ironList } from './iron-list-core.js';\n\n// Iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\nconst MAX_VIRTUAL_COUNT = 100000;\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\n\nexport class IronListAdapter {\n  constructor({ createElements, updateElement, scrollTarget, scrollContainer, elementsContainer, reorderElements }) {\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.elementsContainer = elementsContainer || scrollContainer;\n    this.reorderElements = reorderElements;\n    // Iron-list uses this value to determine how many pages of elements to render\n    this._maxPages = 1.3;\n\n    // Placeholder height (used for sizing elements that have intrinsic 0 height after update)\n    this.__placeholderHeight = 200;\n    // A queue of 10 previous element heights\n    this.__elementHeightQueue = Array(10);\n\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      IGNORE_WHEEL: 500,\n    };\n\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\n\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n\n    this.__resizeObserver.observe(this.scrollTarget);\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\n\n    this._scrollLineHeight = this._getScrollLineHeight();\n    this.scrollTarget.addEventListener('wheel', (e) => this.__onWheel(e));\n\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', () => {\n        this.__mouseDown = true;\n      });\n      this.scrollTarget.addEventListener('mouseup', () => {\n        this.__mouseDown = false;\n        if (this.__pendingReorder) {\n          this.__reorderElements();\n        }\n      });\n    }\n  }\n\n  get scrollOffset() {\n    return 0;\n  }\n\n  get adjustedFirstVisibleIndex() {\n    return this.firstVisibleIndex + this._vidxOffset;\n  }\n\n  get adjustedLastVisibleIndex() {\n    return this.lastVisibleIndex + this._vidxOffset;\n  }\n\n  scrollToIndex(index) {\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n      return;\n    }\n    index = this._clamp(index, 0, this.size - 1);\n\n    const visibleElementCount = this.__getVisibleElements().length;\n    let targetVirtualIndex = Math.floor((index / this.size) * this._virtualCount);\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n      targetVirtualIndex = this._virtualCount - (this.size - index);\n      this._vidxOffset = this.size - this._virtualCount;\n    } else if (targetVirtualIndex < visibleElementCount) {\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n        targetVirtualIndex = index;\n        this._vidxOffset = 0;\n      } else {\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n    } else {\n      this._vidxOffset = index - targetVirtualIndex;\n    }\n\n    this.__skipNextVirtualIndexAdjust = true;\n    super.scrollToIndex(targetVirtualIndex);\n\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n      // Workaround an iron-list issue by manually adjusting the scroll position\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n    }\n    this._scrollHandler();\n  }\n\n  flush() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._resizeHandler();\n    flush();\n    this._scrollHandler();\n    if (this.__scrollReorderDebouncer) {\n      this.__scrollReorderDebouncer.flush();\n    }\n    if (this.__debouncerWheelAnimationFrame) {\n      this.__debouncerWheelAnimationFrame.flush();\n    }\n  }\n\n  update(startIndex = 0, endIndex = this.size - 1) {\n    this.__getVisibleElements().forEach((el) => {\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n        this.__updateElement(el, el.__virtualIndex, true);\n      }\n    });\n  }\n\n  __updateElement(el, index, forceSameIndexUpdates) {\n    // Clean up temporary placeholder sizing\n    if (el.style.paddingTop) {\n      el.style.paddingTop = '';\n    }\n\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n      this.updateElement(el, index);\n      el.__lastUpdatedIndex = index;\n    }\n\n    const elementHeight = el.offsetHeight;\n    if (elementHeight === 0) {\n      // If the elements have 0 height after update (for example due to lazy rendering),\n      // it results in iron-list requesting to create an unlimited count of elements.\n      // Assign a temporary placeholder sizing to elements that would otherwise end up having\n      // no height.\n      el.style.paddingTop = `${this.__placeholderHeight}px`;\n\n      // Manually schedule the resize handler to make sure the placeholder padding is\n      // cleared in case the resize observer never triggers.\n      requestAnimationFrame(() => this._resizeHandler());\n    } else {\n      // Add element height to the queue\n      this.__elementHeightQueue.push(elementHeight);\n      this.__elementHeightQueue.shift();\n\n      // Calcualte new placeholder height based on the average of the defined values in the\n      // element height queue\n      const filteredHeights = this.__elementHeightQueue.filter((h) => h !== undefined);\n      this.__placeholderHeight = Math.round(filteredHeights.reduce((a, b) => a + b, 0) / filteredHeights.length);\n    }\n  }\n\n  __getIndexScrollOffset(index) {\n    const element = this.__getVisibleElements().find((el) => el.__virtualIndex === index);\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n  }\n\n  get size() {\n    return this.__size;\n  }\n\n  set size(size) {\n    if (size === this.size) {\n      return;\n    }\n\n    // Prevent element update while the scroll position is being restored\n    this.__preventElementUpdates = true;\n\n    // Record the scroll position before changing the size\n    let fvi; // First visible index\n    let fviOffsetBefore; // Scroll offset of the first visible index\n    if (size > 0) {\n      fvi = this.adjustedFirstVisibleIndex;\n      fviOffsetBefore = this.__getIndexScrollOffset(fvi);\n    }\n\n    // Change the size\n    this.__size = size;\n\n    // Flush before invoking items change to avoid\n    // creating excess elements on the following flush()\n    flush();\n\n    this._itemsChanged({\n      path: 'items',\n    });\n    flush();\n\n    // Try to restore the scroll position if the new size is larger than 0\n    if (size > 0) {\n      fvi = Math.min(fvi, size - 1);\n      this.scrollToIndex(fvi);\n\n      const fviOffsetAfter = this.__getIndexScrollOffset(fvi);\n      if (fviOffsetBefore !== undefined && fviOffsetAfter !== undefined) {\n        this._scrollTop += fviOffsetBefore - fviOffsetAfter;\n      }\n    }\n\n    if (!this.elementsContainer.children.length) {\n      requestAnimationFrame(() => this._resizeHandler());\n    }\n\n    this.__preventElementUpdates = false;\n    // Schedule and flush a resize handler\n    this._resizeHandler();\n    flush();\n  }\n\n  /** @private */\n  get _scrollTop() {\n    return this.scrollTarget.scrollTop;\n  }\n\n  /** @private */\n  set _scrollTop(top) {\n    this.scrollTarget.scrollTop = top;\n  }\n\n  /** @private */\n  get items() {\n    return {\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT),\n    };\n  }\n\n  /** @private */\n  get offsetHeight() {\n    return this.scrollTarget.offsetHeight;\n  }\n\n  /** @private */\n  get $() {\n    return {\n      items: this.scrollContainer,\n    };\n  }\n\n  /** @private */\n  updateViewportBoundaries() {\n    const styles = window.getComputedStyle(this.scrollTarget);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.elementsContainer.offsetWidth;\n    this._viewportHeight = this.scrollTarget.offsetHeight;\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n    if (this.grid) {\n      this._updateGridMetrics();\n    }\n  }\n\n  /** @private */\n  setAttribute() {}\n\n  /** @private */\n  _createPool(size) {\n    const physicalItems = this.createElements(size);\n    const fragment = document.createDocumentFragment();\n    physicalItems.forEach((el) => {\n      el.style.position = 'absolute';\n      fragment.appendChild(el);\n      this.__resizeObserver.observe(el);\n    });\n    this.elementsContainer.appendChild(fragment);\n    return physicalItems;\n  }\n\n  /** @private */\n  _assignModels(itemSet) {\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      el.hidden = vidx >= this.size;\n      if (!el.hidden) {\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\n        this.__updateElement(el, el.__virtualIndex);\n      } else {\n        delete el.__lastUpdatedIndex;\n      }\n    }, itemSet);\n  }\n\n  /** @private */\n  _isClientFull() {\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n    setTimeout(() => {\n      this.__clientFull = true;\n    });\n    return this.__clientFull || super._isClientFull();\n  }\n\n  /** @private */\n  translate3d(_x, y, _z, el) {\n    el.style.transform = `translateY(${y})`;\n  }\n\n  /** @private */\n  toggleScrollListener() {}\n\n  _scrollHandler() {\n    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\n    const delta = this.scrollTarget.scrollTop - this._scrollPosition;\n\n    super._scrollHandler();\n\n    if (this._physicalCount !== 0) {\n      const isScrollingDown = delta >= 0;\n      const reusables = this._getReusables(!isScrollingDown);\n\n      if (reusables.indexes.length) {\n        // After running super._scrollHandler, fix internal properties to workaround an iron-list issue.\n        // See https://github.com/vaadin/web-components/issues/1691\n        this._physicalTop = reusables.physicalTop;\n\n        if (isScrollingDown) {\n          this._virtualStart -= reusables.indexes.length;\n          this._physicalStart -= reusables.indexes.length;\n        } else {\n          this._virtualStart += reusables.indexes.length;\n          this._physicalStart += reusables.indexes.length;\n        }\n        this._resizeHandler();\n      }\n    }\n\n    if (this.reorderElements) {\n      this.__scrollReorderDebouncer = Debouncer.debounce(\n        this.__scrollReorderDebouncer,\n        timeOut.after(this.timeouts.SCROLL_REORDER),\n        () => this.__reorderElements(),\n      );\n    }\n\n    this.__previousScrollTop = this._scrollTop;\n\n    // If the first visible index is not 0 when scrolled to the top,\n    // add some scroll offset to enable the user to continue scrolling.\n    if (this._scrollTop === 0 && this.firstVisibleIndex !== 0) {\n      this._scrollTop = 1;\n    }\n  }\n\n  /** @private */\n  __onWheel(e) {\n    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\n      return;\n    }\n\n    let deltaY = e.deltaY;\n    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n      // Scrolling by \"lines of text\" instead of pixels\n      deltaY *= this._scrollLineHeight;\n    } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n      // Scrolling by \"pages\" instead of pixels\n      deltaY *= this._scrollPageHeight;\n    }\n\n    this._deltaYAcc = this._deltaYAcc || 0;\n\n    if (this._wheelAnimationFrame) {\n      // Accumulate wheel delta while a frame is being processed\n      this._deltaYAcc += deltaY;\n      e.preventDefault();\n      return;\n    }\n\n    deltaY += this._deltaYAcc;\n    this._deltaYAcc = 0;\n\n    this._wheelAnimationFrame = true;\n    this.__debouncerWheelAnimationFrame = Debouncer.debounce(\n      this.__debouncerWheelAnimationFrame,\n      animationFrame,\n      () => {\n        this._wheelAnimationFrame = false;\n      },\n    );\n\n    const momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\n\n    if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\n      e.preventDefault();\n      this.scrollTarget.scrollTop += deltaY;\n      this.scrollTarget.scrollLeft += e.deltaX;\n\n      this._hasResidualMomentum = true;\n\n      this._ignoreNewWheel = true;\n      this._debouncerIgnoreNewWheel = Debouncer.debounce(\n        this._debouncerIgnoreNewWheel,\n        timeOut.after(this.timeouts.IGNORE_WHEEL),\n        () => {\n          this._ignoreNewWheel = false;\n        },\n      );\n    } else if ((this._hasResidualMomentum && momentum <= this._previousMomentum) || this._ignoreNewWheel) {\n      e.preventDefault();\n    } else if (momentum > this._previousMomentum) {\n      this._hasResidualMomentum = false;\n    }\n    this._previousMomentum = momentum;\n  }\n\n  /**\n   * Determines if the element has an ancestor that handles the scroll delta prior to this\n   *\n   * @private\n   */\n  _hasScrolledAncestor(el, deltaX, deltaY) {\n    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\n      return false;\n    } else if (\n      this._canScroll(el, deltaX, deltaY) &&\n      ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1\n    ) {\n      return true;\n    } else if (el !== this && el.parentElement) {\n      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\n    }\n  }\n\n  _canScroll(el, deltaX, deltaY) {\n    return (\n      (deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight) ||\n      (deltaY < 0 && el.scrollTop > 0) ||\n      (deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth) ||\n      (deltaX < 0 && el.scrollLeft > 0)\n    );\n  }\n\n  /**\n   * @returns {Number|undefined} - The browser's default font-size in pixels\n   * @private\n   */\n  _getScrollLineHeight() {\n    const el = document.createElement('div');\n    el.style.fontSize = 'initial';\n    el.style.display = 'none';\n    document.body.appendChild(el);\n    const fontSize = window.getComputedStyle(el).fontSize;\n    document.body.removeChild(el);\n    return fontSize ? window.parseInt(fontSize) : undefined;\n  }\n\n  __getVisibleElements() {\n    return Array.from(this.elementsContainer.children).filter((element) => !element.hidden);\n  }\n\n  /** @private */\n  __reorderElements() {\n    if (this.__mouseDown) {\n      this.__pendingReorder = true;\n      return;\n    }\n    this.__pendingReorder = false;\n\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\n\n    // Which row to use as a target?\n    const visibleElements = this.__getVisibleElements();\n\n    const elementWithFocus = visibleElements.find(\n      (element) =>\n        element.contains(this.elementsContainer.getRootNode().activeElement) ||\n        element.contains(this.scrollTarget.getRootNode().activeElement),\n    );\n    const targetElement = elementWithFocus || visibleElements[0];\n    if (!targetElement) {\n      // All elements are hidden, don't reorder\n      return;\n    }\n\n    // Where the target row should be?\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\n\n    // Reodrer the DOM elements to keep the target row at the target physical index\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n    if (delta > 0) {\n      for (let i = 0; i < delta; i++) {\n        this.elementsContainer.appendChild(visibleElements[i]);\n      }\n    } else if (delta < 0) {\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\n      }\n    }\n\n    // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n    if (isSafari) {\n      const { transform } = this.scrollTarget.style;\n      this.scrollTarget.style.transform = 'translateZ(0)';\n      setTimeout(() => {\n        this.scrollTarget.style.transform = transform;\n      });\n    }\n  }\n\n  /** @private */\n  _adjustVirtualIndexOffset(delta) {\n    if (this._virtualCount >= this.size) {\n      this._vidxOffset = 0;\n    } else if (this.__skipNextVirtualIndexAdjust) {\n      this.__skipNextVirtualIndexAdjust = false;\n    } else if (Math.abs(delta) > 10000) {\n      // Process a large scroll position change\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);\n      const offset = scale * this.size;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset;\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n      const maxShift = 100;\n\n      // Near start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n      }\n\n      // Near end\n      const maxOffset = this.size - this._virtualCount;\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount - 1);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n      }\n    }\n  }\n}\n\nObject.setPrototypeOf(IronListAdapter.prototype, ironList);\n", "import { IronListAdapter } from './virtualizer-iron-list-adapter.js';\n\nexport class Virtualizer {\n  /**\n   * @typedef {Object} VirtualizerConfig\n   * @property {Function} createElements Function that returns the given number of new elements\n   * @property {Function} updateElement Function that updates the element at a specific index\n   * @property {HTMLElement} scrollTarget Reference to the scrolling element\n   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget\n   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer\n   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM\n   * @param {VirtualizerConfig} config Configuration for the virtualizer\n   */\n  constructor(config) {\n    this.__adapter = new IronListAdapter(config);\n  }\n\n  /**\n   * The size of the virtualizer\n   * @return {number | undefined} The size of the virtualizer\n   */\n  get size() {\n    return this.__adapter.size;\n  }\n\n  /**\n   * The size of the virtualizer\n   * @param {number} size The size of the virtualizer\n   */\n  set size(size) {\n    this.__adapter.size = size;\n  }\n\n  /**\n   * Scroll to a specific index in the virtual list\n   *\n   * @method scrollToIndex\n   * @param {number} index The index of the item\n   */\n  scrollToIndex(index) {\n    this.__adapter.scrollToIndex(index);\n  }\n\n  /**\n   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM\n   *\n   * @method update\n   * @param {number | undefined} startIndex The start index of the range\n   * @param {number | undefined} endIndex The end index of the range\n   */\n  update(startIndex = 0, endIndex = this.size - 1) {\n    this.__adapter.update(startIndex, endIndex);\n  }\n\n  /**\n   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state\n   *\n   * @method update\n   * @param {number | undefined} startIndex The start index of the range\n   * @param {number | undefined} endIndex The end index of the range\n   */\n  flush() {\n    this.__adapter.flush();\n  }\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @return {number}\n   */\n  get firstVisibleIndex() {\n    return this.__adapter.adjustedFirstVisibleIndex;\n  }\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @return {number}\n   */\n  get lastVisibleIndex() {\n    return this.__adapter.adjustedLastVisibleIndex;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
