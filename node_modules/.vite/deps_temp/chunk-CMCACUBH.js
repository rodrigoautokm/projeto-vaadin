import {
  ComboBoxItem,
  ComboBoxMixin,
  ComboBoxOverlay,
  ComboBoxScroller
} from "./chunk-RTLPYO4G.js";
import {
  PatternMixin
} from "./chunk-3X24PFLT.js";
import {
  InputControlMixin,
  inputFieldShared as inputFieldShared2
} from "./chunk-KP6A4WLM.js";
import {
  inputFieldShared
} from "./chunk-VED5C5P5.js";
import {
  InputController
} from "./chunk-GGAGROPH.js";
import {
  LabelledInputController
} from "./chunk-67AQUJJH.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";

// node_modules/@vaadin/time-picker/theme/lumo/vaadin-time-picker-styles.js
var timePicker = css`
  [part~='toggle-button']::before {
    content: var(--lumo-icons-clock);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }
`;
registerStyles("vaadin-time-picker", [inputFieldShared, timePicker], { moduleId: "lumo-time-picker" });

// node_modules/@vaadin/time-picker/src/vaadin-time-picker-item.js
var TimePickerItem = class extends ComboBoxItem {
  static get is() {
    return "vaadin-time-picker-item";
  }
};
customElements.define(TimePickerItem.is, TimePickerItem);

// node_modules/@vaadin/time-picker/src/vaadin-time-picker-scroller.js
var TimePickerScroller = class extends ComboBoxScroller {
  static get is() {
    return "vaadin-time-picker-scroller";
  }
};
customElements.define(TimePickerScroller.is, TimePickerScroller);

// node_modules/@vaadin/time-picker/src/vaadin-time-picker-overlay.js
registerStyles(
  "vaadin-time-picker-overlay",
  css`
    #overlay {
      width: var(--vaadin-time-picker-overlay-width, var(--_vaadin-time-picker-overlay-default-width, auto));
    }
  `,
  { moduleId: "vaadin-time-picker-overlay-styles" }
);
var TimePickerOverlay = class extends ComboBoxOverlay {
  static get is() {
    return "vaadin-time-picker-overlay";
  }
};
customElements.define(TimePickerOverlay.is, TimePickerOverlay);

// node_modules/@vaadin/time-picker/src/vaadin-time-picker-combo-box.js
var TimePickerComboBox = class extends ComboBoxMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-time-picker-combo-box";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-time-picker-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[positionTarget]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-time-picker-overlay>
    `;
  }
  static get properties() {
    return {
      positionTarget: {
        type: Object
      }
    };
  }
  get _tagNamePrefix() {
    return "vaadin-time-picker";
  }
  get clearElement() {
    return this.querySelector('[part="clear-button"]');
  }
  ready() {
    super.ready();
    this.allowCustomValue = true;
    this._toggleElement = this.querySelector(".toggle-button");
    this.setAttribute("dir", "ltr");
  }
};
customElements.define(TimePickerComboBox.is, TimePickerComboBox);

// node_modules/@vaadin/time-picker/src/vaadin-time-picker.js
var MIN_ALLOWED_TIME = "00:00:00.000";
var MAX_ALLOWED_TIME = "23:59:59.999";
registerStyles("vaadin-time-picker", inputFieldShared2, { moduleId: "vaadin-time-picker-styles" });
var TimePicker = class extends PatternMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-time-picker";
  }
  static get template() {
    return html`
      <style>
        /* See https://github.com/vaadin/vaadin-time-picker/issues/145 */
        :host([dir='rtl']) [part='input-field'] {
          direction: ltr;
        }

        :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
          direction: rtl;
          text-align: left;
        }

        [part~='toggle-button'] {
          cursor: pointer;
        }
      </style>

      <div class="vaadin-time-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-time-picker-combo-box
          id="comboBox"
          filtered-items="[[__dropdownItems]]"
          value="{{_comboBoxValue}}"
          disabled="[[disabled]]"
          readonly="[[readonly]]"
          clear-button-visible="[[clearButtonVisible]]"
          auto-open-disabled="[[autoOpenDisabled]]"
          position-target="[[_inputContainer]]"
          theme$="[[_theme]]"
          on-change="__onComboBoxChange"
        >
          <vaadin-input-container
            part="input-field"
            readonly="[[readonly]]"
            disabled="[[disabled]]"
            invalid="[[invalid]]"
            theme$="[[_theme]]"
          >
            <slot name="prefix" slot="prefix"></slot>
            <slot name="input"></slot>
            <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
            <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix" aria-hidden="true"></div>
          </vaadin-input-container>
        </vaadin-time-picker-combo-box>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
    `;
  }
  static get properties() {
    return {
      value: {
        type: String,
        notify: true,
        value: ""
      },
      min: {
        type: String,
        value: ""
      },
      max: {
        type: String,
        value: ""
      },
      step: {
        type: Number
      },
      autoOpenDisabled: Boolean,
      __dropdownItems: {
        type: Array
      },
      i18n: {
        type: Object,
        value: () => {
          return {
            formatTime: (time) => {
              if (!time) {
                return;
              }
              const pad = (num = 0, fmt = "00") => (fmt + num).substr((fmt + num).length - fmt.length);
              let timeString = `${pad(time.hours)}:${pad(time.minutes)}`;
              if (time.seconds !== void 0) {
                timeString += `:${pad(time.seconds)}`;
              }
              if (time.milliseconds !== void 0) {
                timeString += `.${pad(time.milliseconds, "000")}`;
              }
              return timeString;
            },
            parseTime: (text) => {
              const MATCH_HOURS = "(\\d|[0-1]\\d|2[0-3])";
              const MATCH_MINUTES = "(\\d|[0-5]\\d)";
              const MATCH_SECONDS = MATCH_MINUTES;
              const MATCH_MILLISECONDS = "(\\d{1,3})";
              const re = new RegExp(
                `^${MATCH_HOURS}(?::${MATCH_MINUTES}(?::${MATCH_SECONDS}(?:\\.${MATCH_MILLISECONDS})?)?)?$`
              );
              const parts = re.exec(text);
              if (parts) {
                if (parts[4]) {
                  while (parts[4].length < 3) {
                    parts[4] += "0";
                  }
                }
                return { hours: parts[1], minutes: parts[2], seconds: parts[3], milliseconds: parts[4] };
              }
            }
          };
        }
      },
      _comboBoxValue: {
        type: String,
        observer: "__comboBoxValueChanged"
      },
      _inputContainer: Object
    };
  }
  static get observers() {
    return ["__updateDropdownItems(i18n.*, min, max, step)"];
  }
  static get constraints() {
    return [...super.constraints, "min", "max"];
  }
  get clearElement() {
    return this.$.clearButton;
  }
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._inputContainer = this.shadowRoot.querySelector('[part~="input-field"]');
  }
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      this.$.comboBox._setInputElement(input);
    }
  }
  checkValidity() {
    return !!(this.inputElement.checkValidity() && (!this.value || this._timeAllowed(this.i18n.parseTime(this.value))) && (!this._comboBoxValue || this.i18n.parseTime(this._comboBoxValue)));
  }
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.validate();
    }
  }
  __validDayDivisor(step) {
    return !step || 24 * 3600 % step === 0 || step < 1 && step % 1 * 1e3 % 1 === 0;
  }
  _onKeyDown(e) {
    super._onKeyDown(e);
    if (this.readonly || this.disabled || this.__dropdownItems.length) {
      return;
    }
    const stepResolution = this.__validDayDivisor(this.step) && this.step || 60;
    if (e.keyCode === 40) {
      this.__onArrowPressWithStep(-stepResolution);
    } else if (e.keyCode === 38) {
      this.__onArrowPressWithStep(stepResolution);
    }
  }
  _onEscape() {
  }
  __onArrowPressWithStep(step) {
    const objWithStep = this.__addStep(this.__getMsec(this.__memoValue), step, true);
    this.__memoValue = objWithStep;
    this.inputElement.value = this.i18n.formatTime(this.__validateTime(objWithStep));
    this.__dispatchChange();
  }
  __dispatchChange() {
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  __getMsec(obj) {
    let result = (obj && obj.hours || 0) * 60 * 60 * 1e3;
    result += (obj && obj.minutes || 0) * 60 * 1e3;
    result += (obj && obj.seconds || 0) * 1e3;
    result += obj && parseInt(obj.milliseconds) || 0;
    return result;
  }
  __getSec(obj) {
    let result = (obj && obj.hours || 0) * 60 * 60;
    result += (obj && obj.minutes || 0) * 60;
    result += obj && obj.seconds || 0;
    result += obj && obj.milliseconds / 1e3 || 0;
    return result;
  }
  __addStep(msec, step, precision) {
    if (msec === 0 && step < 0) {
      msec = 24 * 60 * 60 * 1e3;
    }
    const stepMsec = step * 1e3;
    const diffToNext = msec % stepMsec;
    if (stepMsec < 0 && diffToNext && precision) {
      msec -= diffToNext;
    } else if (stepMsec > 0 && diffToNext && precision) {
      msec -= diffToNext - stepMsec;
    } else {
      msec += stepMsec;
    }
    const hh = Math.floor(msec / 1e3 / 60 / 60);
    msec -= hh * 1e3 * 60 * 60;
    const mm = Math.floor(msec / 1e3 / 60);
    msec -= mm * 1e3 * 60;
    const ss = Math.floor(msec / 1e3);
    msec -= ss * 1e3;
    return { hours: hh < 24 ? hh : 0, minutes: mm, seconds: ss, milliseconds: msec };
  }
  __updateDropdownItems(i8n, min, max, step) {
    const minTimeObj = this.__validateTime(this.__parseISO(min || MIN_ALLOWED_TIME));
    const minSec = this.__getSec(minTimeObj);
    const maxTimeObj = this.__validateTime(this.__parseISO(max || MAX_ALLOWED_TIME));
    const maxSec = this.__getSec(maxTimeObj);
    this.__adjustValue(minSec, maxSec, minTimeObj, maxTimeObj);
    this.__dropdownItems = this.__generateDropdownList(minSec, maxSec, step);
    if (step !== this.__oldStep) {
      this.__oldStep = step;
      const parsedObj = this.__validateTime(this.__parseISO(this.value));
      this.__updateValue(parsedObj);
    }
    if (this.value) {
      this._comboBoxValue = this.i18n.formatTime(this.i18n.parseTime(this.value));
    }
  }
  __generateDropdownList(minSec, maxSec, step) {
    if (step < 15 * 60 || !this.__validDayDivisor(step)) {
      return [];
    }
    const generatedList = [];
    step = step || 3600;
    let time = -step + minSec;
    while (time + step >= minSec && time + step <= maxSec) {
      const timeObj = this.__validateTime(this.__addStep(time * 1e3, step));
      time += step;
      const formatted = this.i18n.formatTime(timeObj);
      generatedList.push({ label: formatted, value: formatted });
    }
    return generatedList;
  }
  __adjustValue(minSec, maxSec, minTimeObj, maxTimeObj) {
    if (!this.__memoValue) {
      return;
    }
    const valSec = this.__getSec(this.__memoValue);
    if (valSec < minSec) {
      this.__updateValue(minTimeObj);
    } else if (valSec > maxSec) {
      this.__updateValue(maxTimeObj);
    }
  }
  _valueChanged(value, oldValue) {
    const parsedObj = this.__memoValue = this.__parseISO(value);
    const newValue = this.__formatISO(parsedObj) || "";
    if (value !== "" && value !== null && !parsedObj) {
      this.value = oldValue === void 0 ? "" : oldValue;
    } else if (value !== newValue) {
      this.value = newValue;
    } else if (this.__keepInvalidInput) {
      delete this.__keepInvalidInput;
    } else {
      this.__updateInputValue(parsedObj);
    }
    this._toggleHasValue(this._hasValue);
  }
  __comboBoxValueChanged(value, oldValue) {
    if (value === "" && oldValue === void 0) {
      return;
    }
    const parsedObj = this.i18n.parseTime(value);
    const newValue = this.i18n.formatTime(parsedObj) || "";
    if (parsedObj) {
      if (value !== newValue) {
        this._comboBoxValue = newValue;
      } else {
        this.__updateValue(parsedObj);
      }
    } else {
      if (value !== "") {
        this.__keepInvalidInput = true;
      }
      this.value = "";
    }
  }
  __onComboBoxChange(event) {
    event.stopPropagation();
    this.validate();
    this.__dispatchChange();
  }
  __updateValue(obj) {
    const timeString = this.__formatISO(this.__validateTime(obj)) || "";
    this.value = timeString;
  }
  __updateInputValue(obj) {
    const timeString = this.i18n.formatTime(this.__validateTime(obj)) || "";
    this._comboBoxValue = timeString;
  }
  __validateTime(timeObject) {
    if (timeObject) {
      timeObject.hours = parseInt(timeObject.hours);
      timeObject.minutes = parseInt(timeObject.minutes || 0);
      timeObject.seconds = this.__stepSegment < 3 ? void 0 : parseInt(timeObject.seconds || 0);
      timeObject.milliseconds = this.__stepSegment < 4 ? void 0 : parseInt(timeObject.milliseconds || 0);
    }
    return timeObject;
  }
  get __stepSegment() {
    if (this.step % 3600 === 0) {
      return 1;
    } else if (this.step % 60 === 0 || !this.step) {
      return 2;
    } else if (this.step % 1 === 0) {
      return 3;
    } else if (this.step < 1) {
      return 4;
    }
    return void 0;
  }
  __formatISO(time) {
    return TimePicker.properties.i18n.value().formatTime(time);
  }
  __parseISO(text) {
    return TimePicker.properties.i18n.value().parseTime(text);
  }
  _timeAllowed(time) {
    const parsedMin = this.i18n.parseTime(this.min || MIN_ALLOWED_TIME);
    const parsedMax = this.i18n.parseTime(this.max || MAX_ALLOWED_TIME);
    return (!this.__getMsec(parsedMin) || this.__getMsec(time) >= this.__getMsec(parsedMin)) && (!this.__getMsec(parsedMax) || this.__getMsec(time) <= this.__getMsec(parsedMax));
  }
  _onClearButtonClick() {
  }
  _onChange() {
  }
  _onInput() {
    this._checkInputValue();
  }
};
customElements.define(TimePicker.is, TimePicker);

export {
  TimePicker
};
/**
 * @license
 * Copyright (c) 2018 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-CMCACUBH.js.map
