import {
  ContextMenu
} from "./chunk-U7PZSMAM.js";
import "./chunk-CE2HX6X3.js";
import "./chunk-WJZC25EU.js";
import {
  ResizeMixin
} from "./chunk-C2K2GOEG.js";
import "./chunk-S3HOX4GU.js";
import "./chunk-QJ5Y7LU7.js";
import "./chunk-H44FQUHM.js";
import "./chunk-QAHWQ2NB.js";
import "./chunk-Q6GVJPMX.js";
import "./chunk-E2XIUAPG.js";
import "./chunk-BTTUSTOZ.js";
import "./chunk-LH2VMHWZ.js";
import "./chunk-2FVEPLVQ.js";
import "./chunk-VUBXZXWD.js";
import "./chunk-WE3EBNE7.js";
import "./chunk-XAUSENF3.js";
import "./chunk-SG4ORNH2.js";
import "./chunk-UMTV3SEQ.js";
import "./chunk-4V7CPLV2.js";
import "./chunk-IOVQFHDT.js";
import {
  Button,
  button
} from "./chunk-DGKQRYYZ.js";
import "./chunk-NLOSRFQ7.js";
import "./chunk-37YVODLE.js";
import "./chunk-45DBWWZS.js";
import "./chunk-ZB6KQ55W.js";
import {
  DisabledMixin
} from "./chunk-PVLUQVE7.js";
import "./chunk-TXOUNVRU.js";
import "./chunk-ZCT3SKJI.js";
import "./chunk-DALKQVZ5.js";
import "./chunk-ZU2IWMPM.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import "./chunk-7OTQVW5F.js";
import "./chunk-D7TE3X7L.js";
import "./chunk-7S7VFRNQ.js";
import "./chunk-ZYZHRUSQ.js";
import "./chunk-2EAS4FPS.js";
import "./chunk-VUWTYCVF.js";
import "./chunk-RTIK5DCO.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import "./chunk-CQH3N2QY.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";
import "./chunk-A5QYNKPK.js";
import "./chunk-NCN7ELFS.js";
import "./chunk-CJPRR7ZF.js";

// node_modules/@vaadin/menu-bar/theme/lumo/vaadin-menu-bar-button-styles.js
var menuBarButton = css`
  :host {
    margin: calc(var(--lumo-space-xs) / 2);
    margin-left: 0;
    border-radius: 0;
  }

  [part='label'] {
    width: 100%;
  }

  /* NOTE(web-padawan): avoid using shorthand padding property for IE11 */
  [part='label'] ::slotted(vaadin-context-menu-item) {
    justify-content: center;
    background-color: transparent;
    height: var(--lumo-button-size);
    margin: 0 calc((var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2) * -1);
    padding-left: calc(var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2);
    padding-right: calc(var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2);
  }

  :host([theme~='small']) [part='label'] ::slotted(vaadin-context-menu-item) {
    min-height: var(--lumo-size-s);
    margin: 0 calc((var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2) * -1);
    padding-left: calc(var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2);
    padding-right: calc(var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2);
  }

  :host([theme~='tertiary']) [part='label'] ::slotted(vaadin-context-menu-item) {
    margin: 0 calc((var(--lumo-button-size) / 6) * -1);
    padding-left: calc(var(--lumo-button-size) / 6);
    padding-right: calc(var(--lumo-button-size) / 6);
  }

  :host([theme~='tertiary-inline']) {
    margin-top: calc(var(--lumo-space-xs) / 2);
    margin-bottom: calc(var(--lumo-space-xs) / 2);
    margin-right: calc(var(--lumo-space-xs) / 2);
  }

  :host([theme~='tertiary-inline']) [part='label'] ::slotted(vaadin-context-menu-item) {
    margin: 0;
    padding: 0;
  }

  :host(:first-of-type) {
    border-radius: var(--lumo-border-radius-m) 0 0 var(--lumo-border-radius-m);

    /* Needed to retain the focus-ring with border-radius */
    margin-left: calc(var(--lumo-space-xs) / 2);
  }

  :host(:nth-last-of-type(2)),
  :host([part='overflow-button']) {
    border-radius: 0 var(--lumo-border-radius-m) var(--lumo-border-radius-m) 0;
  }

  :host([theme~='tertiary']),
  :host([theme~='tertiary-inline']) {
    border-radius: var(--lumo-border-radius-m);
  }

  :host([part='overflow-button']) {
    min-width: var(--lumo-button-size);
    padding-left: calc(var(--lumo-button-size) / 4);
    padding-right: calc(var(--lumo-button-size) / 4);
  }

  :host([part='overflow-button']) ::slotted(*) {
    font-size: var(--lumo-font-size-xl);
  }

  :host([part='overflow-button']) [part='prefix'],
  :host([part='overflow-button']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }

  /* RTL styles */
  :host([dir='rtl']) {
    margin-left: calc(var(--lumo-space-xs) / 2);
    margin-right: 0;
    border-radius: 0;
  }

  :host([dir='rtl']:first-of-type) {
    border-radius: 0 var(--lumo-border-radius-m) var(--lumo-border-radius-m) 0;
    margin-right: calc(var(--lumo-space-xs) / 2);
  }

  :host([dir='rtl']:nth-last-of-type(2)),
  :host([dir='rtl'][part='overflow-button']) {
    border-radius: var(--lumo-border-radius-m) 0 0 var(--lumo-border-radius-m);
  }
`;
registerStyles("vaadin-menu-bar-button", [button, menuBarButton], {
  moduleId: "lumo-menu-bar-button"
});

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-button.js
registerStyles(
  "vaadin-menu-bar-button",
  css`
    [part='label'] ::slotted(vaadin-context-menu-item) {
      position: relative;
      z-index: 1;
    }
  `,
  { moduleId: "vaadin-menu-bar-button-styles" }
);
var MenuBarButton = class extends Button {
  static get is() {
    return "vaadin-menu-bar-button";
  }
};
customElements.define(MenuBarButton.is, MenuBarButton);

// node_modules/@vaadin/menu-bar/theme/lumo/vaadin-menu-bar-item-styles.js
registerStyles(
  "vaadin-context-menu-item",
  css`
    :host([theme='menu-bar-item']) [part='content'] {
      display: flex;
      /* tweak to inherit centering from menu bar button */
      align-items: inherit;
      justify-content: inherit;
    }

    :host([theme='menu-bar-item']) [part='content'] ::slotted(vaadin-icon),
    :host([theme='menu-bar-item']) [part='content'] ::slotted(iron-icon) {
      display: inline-block;
      width: var(--lumo-icon-size-m);
      height: var(--lumo-icon-size-m);
    }

    :host([theme='menu-bar-item']) [part='content'] ::slotted(vaadin-icon[icon^='vaadin:']),
    :host([theme='menu-bar-item']) [part='content'] ::slotted(iron-icon[icon^='vaadin:']) {
      padding: var(--lumo-space-xs);
      box-sizing: border-box !important;
    }
  `,
  { moduleId: "lumo-menu-bar-item" }
);

// node_modules/@vaadin/menu-bar/theme/lumo/vaadin-menu-bar-overlay-styles.js
registerStyles(
  "vaadin-context-menu-overlay",
  css`
    :host(:first-of-type) {
      padding-top: var(--lumo-space-xs);
    }
  `,
  { moduleId: "lumo-menu-bar-overlay" }
);

// node_modules/@vaadin/menu-bar/theme/lumo/vaadin-menu-bar-styles.js
registerStyles(
  "vaadin-menu-bar",
  css`
    :host([has-single-button]) [part$='button'] {
      border-radius: var(--lumo-border-radius-m);
    }

    :host([theme~='end-aligned']) [part$='button']:first-child,
    :host([theme~='end-aligned'][has-single-button]) [part$='button'] {
      margin-inline-start: auto;
    }
  `,
  { moduleId: "lumo-menu-bar" }
);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-submenu.js
var MenuBarSubmenu = class extends ContextMenu {
  static get is() {
    return "vaadin-menu-bar-submenu";
  }
  constructor() {
    super();
    this.openOn = "opensubmenu";
  }
  _openedChanged(opened) {
    this.$.overlay.opened = opened;
  }
  close() {
    super.close();
    if (this.hasAttribute("is-root")) {
      this.getRootNode().host._close();
    }
  }
};
customElements.define(MenuBarSubmenu.is, MenuBarSubmenu);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-buttons-mixin.js
var ButtonsMixin = (superClass) => class extends ResizeMixin(superClass) {
  static get properties() {
    return {
      _hasOverflow: {
        type: Boolean,
        value: false
      }
    };
  }
  static get observers() {
    return ["_menuItemsChanged(items, items.splices)"];
  }
  get _observeParent() {
    return true;
  }
  ready() {
    super.ready();
    this.setAttribute("role", "menubar");
  }
  connectedCallback() {
    super.connectedCallback();
    this._initButtonAttrs(this._overflow);
  }
  get _buttons() {
    return Array.from(this.shadowRoot.querySelectorAll('[part$="button"]'));
  }
  get _container() {
    return this.shadowRoot.querySelector('[part="container"]');
  }
  get _overflow() {
    return this.shadowRoot.querySelector('[part="overflow-button"]');
  }
  _menuItemsChanged(items) {
    if (items !== this._oldItems) {
      this._oldItems = items;
      this.__renderButtons(items);
    }
  }
  __getOverflowCount(overflow) {
    return overflow.item && overflow.item.children && overflow.item.children.length || 0;
  }
  __restoreButtons(buttons) {
    for (let i = 0; i < buttons.length; i++) {
      const btn = buttons[i];
      btn.disabled = btn.item && btn.item.disabled || this.disabled;
      btn.style.visibility = "";
      btn.style.position = "";
      const item = btn.item && btn.item.component;
      if (item instanceof HTMLElement && item.classList.contains("vaadin-menu-item")) {
        btn.appendChild(item);
        item.classList.remove("vaadin-menu-item");
      }
    }
    this.__updateOverflow([]);
  }
  __updateOverflow(items) {
    this._overflow.item = { children: items };
    this._hasOverflow = items.length > 0;
  }
  __setOverflowItems(buttons, overflow) {
    const container = this._container;
    if (container.offsetWidth < container.scrollWidth) {
      this._hasOverflow = true;
      const isRTL = this.getAttribute("dir") === "rtl";
      let i;
      for (i = buttons.length; i > 0; i--) {
        const btn = buttons[i - 1];
        const btnStyle = getComputedStyle(btn);
        if (!isRTL && btn.offsetLeft + btn.offsetWidth < container.offsetWidth - overflow.offsetWidth || isRTL && btn.offsetLeft >= overflow.offsetWidth) {
          break;
        }
        btn.disabled = true;
        btn.style.visibility = "hidden";
        btn.style.position = "absolute";
        btn.style.width = btnStyle.width;
      }
      const items = buttons.filter((_, idx) => idx >= i).map((b) => b.item);
      this.__updateOverflow(items);
    }
  }
  __detectOverflow() {
    const overflow = this._overflow;
    const buttons = this._buttons.filter((btn) => btn !== overflow);
    const oldOverflowCount = this.__getOverflowCount(overflow);
    this.__restoreButtons(buttons);
    this.__setOverflowItems(buttons, overflow);
    const newOverflowCount = this.__getOverflowCount(overflow);
    if (oldOverflowCount !== newOverflowCount && this._subMenu.opened) {
      this._subMenu.close();
    }
    const isSingleButton = newOverflowCount === buttons.length || newOverflowCount === 0 && buttons.length === 1;
    this.toggleAttribute("has-single-button", isSingleButton);
  }
  _removeButtons() {
    const container = this._container;
    while (container.children.length > 1) {
      container.removeChild(container.firstElementChild);
    }
  }
  _initButton(item) {
    const button2 = document.createElement("vaadin-menu-bar-button");
    button2.setAttribute("part", "menu-bar-button");
    const itemCopy = { ...item };
    button2.item = itemCopy;
    if (item.component) {
      const component = this.__getComponent(itemCopy);
      itemCopy.component = component;
      component.item = itemCopy;
      button2.appendChild(component);
    } else if (item.text) {
      button2.textContent = item.text;
    }
    return button2;
  }
  _initButtonAttrs(button2) {
    button2.setAttribute("role", "menuitem");
    if (button2 === this._overflow || button2.item && button2.item.children) {
      button2.setAttribute("aria-haspopup", "true");
      button2.setAttribute("aria-expanded", "false");
    }
  }
  _setButtonDisabled(button2, disabled) {
    button2.disabled = disabled;
    button2.setAttribute("tabindex", disabled ? "-1" : "0");
  }
  _setButtonTheme(btn, hostTheme) {
    let theme = hostTheme;
    const itemTheme = btn.item && btn.item.theme;
    if (itemTheme != null) {
      theme = Array.isArray(itemTheme) ? itemTheme.join(" ") : itemTheme;
    }
    if (theme) {
      btn.setAttribute("theme", theme);
    } else {
      btn.removeAttribute("theme");
    }
  }
  _appendButton(button2) {
    this._container.insertBefore(button2, this._overflow);
  }
  __getComponent(item) {
    const itemComponent = item.component;
    let component;
    const isElement = itemComponent instanceof HTMLElement;
    if (isElement && itemComponent.localName === "vaadin-context-menu-item") {
      component = itemComponent;
    } else {
      component = document.createElement("vaadin-context-menu-item");
      component.appendChild(isElement ? itemComponent : document.createElement(itemComponent));
    }
    if (item.text) {
      const node = component.firstChild || component;
      node.textContent = item.text;
    }
    component.setAttribute("theme", "menu-bar-item");
    return component;
  }
  __renderButtons(items = []) {
    this._removeButtons();
    if (items.length === 0) {
      return;
    }
    items.forEach((item) => {
      const button2 = this._initButton(item);
      this._appendButton(button2);
      this._setButtonDisabled(button2, item.disabled);
      this._initButtonAttrs(button2);
      this._setButtonTheme(button2, this._theme);
    });
    this.__detectOverflow();
  }
  _onResize() {
    this.__detectOverflow();
  }
};

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-interactions-mixin.js
var InteractionsMixin = (superClass) => class InteractionsMixin extends superClass {
  static get properties() {
    return {
      openOnHover: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.__boundOnContextMenuKeydown = this.__onContextMenuKeydown.bind(this);
  }
  static get observers() {
    return ["_itemsChanged(items, items.splices)"];
  }
  ready() {
    super.ready();
    this.addEventListener("keydown", (e) => this._onKeydown(e));
    this.addEventListener("focusin", (e) => this._onFocusin(e));
    this._subMenu.addEventListener("item-selected", this.__onItemSelected.bind(this));
    this._subMenu.addEventListener("close-all-menus", this.__onEscapeClose.bind(this));
    const overlay = this._subMenu.$.overlay;
    overlay.addEventListener("keydown", this.__boundOnContextMenuKeydown);
    const container = this._container;
    container.addEventListener("click", this.__onButtonClick.bind(this));
    container.addEventListener("mouseover", (e) => this._onMouseOver(e));
  }
  get __isRTL() {
    return this.getAttribute("dir") === "rtl";
  }
  _setExpanded(button2, expanded) {
    button2.toggleAttribute("expanded", expanded);
    button2.toggleAttribute("active", expanded);
    button2.setAttribute("aria-expanded", expanded ? "true" : "false");
  }
  _setTabindex(button2, focused) {
    button2.setAttribute("tabindex", focused ? "0" : "-1");
  }
  _focusButton(button2) {
    button2.focus();
    button2.setAttribute("focus-ring", "");
    this._buttons.forEach((btn) => {
      this._setTabindex(btn, btn === button2);
    });
  }
  _getButtonFromEvent(e) {
    return Array.from(e.composedPath()).filter((el) => el.localName === "vaadin-menu-bar-button")[0];
  }
  _getCurrentButton() {
    return this.shadowRoot.activeElement || this._expandedButton;
  }
  _onFocusin() {
    const target = this.shadowRoot.querySelector('[part$="button"][tabindex="0"]');
    if (target) {
      this._buttons.forEach((btn) => {
        this._setTabindex(btn, btn === target);
      });
    }
  }
  _onKeydown(event) {
    const button2 = this._getButtonFromEvent(event);
    if (button2) {
      if (event.keyCode === 40) {
        event.preventDefault();
        if (button2 === this._expandedButton) {
          this._focusFirstItem();
        } else {
          this.__openSubMenu(button2, event);
        }
      } else if (event.keyCode === 38) {
        event.preventDefault();
        if (button2 === this._expandedButton) {
          this._focusLastItem();
        } else {
          this.__openSubMenu(button2, event, { focusLast: true });
        }
      } else if (event.keyCode === 27 && button2 === this._expandedButton) {
        this._close(true);
      } else {
        this._navigateByKey(event);
      }
    }
  }
  _navigateByKey(event) {
    const key = event.key.replace(/^Arrow/, "");
    const buttons = this._buttons;
    const currentBtn = this._getCurrentButton();
    const currentIdx = buttons.indexOf(currentBtn);
    let idx;
    let increment;
    const dirIncrement = this.__isRTL ? -1 : 1;
    switch (key) {
      case "Left":
        increment = -dirIncrement;
        idx = currentIdx - dirIncrement;
        break;
      case "Right":
        increment = dirIncrement;
        idx = currentIdx + dirIncrement;
        break;
      case "Home":
        increment = 1;
        idx = 0;
        break;
      case "End":
        increment = -1;
        idx = buttons.length - 1;
        break;
      default:
    }
    idx = this._getAvailableIndex(idx, increment, buttons);
    if (idx >= 0) {
      event.preventDefault();
      const btn = buttons[idx];
      const wasExpanded = currentBtn === this._expandedButton;
      if (wasExpanded) {
        this._close();
      }
      this._focusButton(btn);
      if (wasExpanded && btn.item && btn.item.children) {
        this.__openSubMenu(btn, event, { keepFocus: true });
      }
    }
  }
  _getAvailableIndex(index, increment, buttons) {
    const totalItems = buttons.length;
    let idx = index;
    for (let i = 0; typeof idx === "number" && i < totalItems; i++, idx += increment || 1) {
      if (idx < 0) {
        idx = totalItems - 1;
      } else if (idx >= totalItems) {
        idx = 0;
      }
      const btn = buttons[idx];
      if (!btn.disabled && !btn.hasAttribute("hidden")) {
        return idx;
      }
    }
    return -1;
  }
  get _subMenu() {
    return this.shadowRoot.querySelector("vaadin-menu-bar-submenu");
  }
  _itemsChanged() {
    const subMenu = this._subMenu;
    if (subMenu && subMenu.opened) {
      subMenu.close();
    }
  }
  _onMouseOver(e) {
    const button2 = this._getButtonFromEvent(e);
    if (button2 && button2 !== this._expandedButton) {
      const isOpened = this._subMenu.opened;
      if (button2.item.children && (this.openOnHover || isOpened)) {
        this.__openSubMenu(button2, e);
      } else if (isOpened) {
        this._close();
      }
    }
  }
  __onContextMenuKeydown(e) {
    const item = Array.from(e.composedPath()).filter((el) => el._item)[0];
    if (item) {
      const list = item.parentNode;
      if (e.keyCode === 38 && item === list.items[0]) {
        this._close(true);
      }
      if (e.keyCode === 37 || e.keyCode === 39 && !item._item.children) {
        e.stopImmediatePropagation();
        this._navigateByKey(e);
        const button2 = this.shadowRoot.activeElement;
        if (button2 && button2.item && button2.item.children) {
          this.__openSubMenu(button2, e, { keepFocus: true });
        }
      }
    }
  }
  __fireItemSelected(value) {
    this.dispatchEvent(new CustomEvent("item-selected", { detail: { value } }));
  }
  __onButtonClick(e) {
    e.stopPropagation();
    const button2 = this._getButtonFromEvent(e);
    if (button2) {
      this.__openSubMenu(button2, e);
    }
  }
  __openSubMenu(button2, event, options = {}) {
    const subMenu = this._subMenu;
    const item = button2.item;
    if (subMenu.opened) {
      this._close();
      if (subMenu.listenOn === button2) {
        return;
      }
    }
    const items = item && item.children;
    if (!items || items.length === 0) {
      this.__fireItemSelected(item);
      return;
    }
    subMenu.items = items;
    subMenu.listenOn = button2;
    const overlay = subMenu.$.overlay;
    overlay.positionTarget = button2;
    overlay.noVerticalOverlap = true;
    this._expandedButton = button2;
    requestAnimationFrame(() => {
      button2.dispatchEvent(
        new CustomEvent("opensubmenu", {
          detail: {
            children: items
          }
        })
      );
      this._setExpanded(button2, true);
    });
    if (options.focusLast) {
      this.__onceOpened(() => this._focusLastItem());
    }
    if (options.keepFocus) {
      this.__onceOpened(() => {
        this._focusButton(this._expandedButton);
      });
    }
    this.__onceOpened(() => {
      if (event.type !== "keydown") {
        subMenu.$.overlay.$.overlay.focus();
      }
      overlay._updatePosition();
    });
  }
  _focusFirstItem() {
    const list = this._subMenu.$.overlay.firstElementChild;
    list.focus();
  }
  _focusLastItem() {
    const list = this._subMenu.$.overlay.firstElementChild;
    const item = list.items[list.items.length - 1];
    if (item) {
      item.focus();
    }
  }
  __onceOpened(cb) {
    this.style.pointerEvents = "auto";
    const overlay = this._subMenu.$.overlay;
    const listener = () => {
      cb();
      overlay.removeEventListener("vaadin-overlay-open", listener);
    };
    overlay.addEventListener("vaadin-overlay-open", listener);
  }
  __onItemSelected(e) {
    e.stopPropagation();
    this._close();
    this.__fireItemSelected(e.detail.value);
  }
  __onEscapeClose() {
    this.__deactivateButton(true);
  }
  __deactivateButton(restoreFocus) {
    const button2 = this._expandedButton;
    if (button2 && button2.hasAttribute("expanded")) {
      this._setExpanded(button2, false);
      if (restoreFocus) {
        this._focusButton(button2);
      }
      this._expandedButton = null;
    }
  }
  _close(restoreFocus) {
    this.style.pointerEvents = "";
    this.__deactivateButton(restoreFocus);
    if (this._subMenu.opened) {
      this._subMenu.close();
    }
  }
};

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar.js
var MenuBar = class extends ButtonsMixin(DisabledMixin(InteractionsMixin(ElementMixin(ThemableMixin(PolymerElement))))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='container'] {
          position: relative;
          display: flex;
          width: 100%;
          flex-wrap: nowrap;
          overflow: hidden;
        }

        [part$='button'] {
          flex-shrink: 0;
        }

        [part='overflow-button'] {
          margin-right: 0;
        }

        .dots::before {
          display: block;
          content: '\\00B7\\00B7\\00B7';
          font-size: inherit;
          line-height: inherit;
        }
      </style>

      <div part="container">
        <vaadin-menu-bar-button part="overflow-button" hidden$="[[!_hasOverflow]]" aria-label$="[[i18n.moreOptions]]">
          <div class="dots"></div>
        </vaadin-menu-bar-button>
      </div>
      <vaadin-menu-bar-submenu is-root=""></vaadin-menu-bar-submenu>
    `;
  }
  static get is() {
    return "vaadin-menu-bar";
  }
  static get properties() {
    return {
      items: {
        type: Array,
        value: () => []
      },
      i18n: {
        type: Object,
        value: () => {
          return {
            moreOptions: "More options"
          };
        }
      }
    };
  }
  static get observers() {
    return ["_themeChanged(_theme)"];
  }
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (oldValue !== newValue) {
      this.__updateButtonsDisabled(newValue);
    }
  }
  _themeChanged(theme) {
    if (this.shadowRoot) {
      this._buttons.forEach((btn) => this._setButtonTheme(btn, theme));
      this.__detectOverflow();
    }
    if (theme) {
      this._subMenu.setAttribute("theme", theme);
    } else {
      this._subMenu.removeAttribute("theme");
    }
  }
  __updateButtonsDisabled(disabled) {
    this._buttons.forEach((btn) => {
      btn.disabled = disabled || btn.item && btn.item.disabled;
    });
  }
};
customElements.define(MenuBar.is, MenuBar);
/**
 * @license
 * Copyright (c) 2019 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_menu-bar_theme_lumo_vaadin-menu-bar__js.js.map
