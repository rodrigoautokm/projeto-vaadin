{
  "version": 3,
  "sources": ["../../@vaadin/vaadin-overlay/src/vaadin-overlay-position-mixin.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getAncestorRootNodes } from '@vaadin/component-base/src/dom-utils.js';\n\nconst PROP_NAMES_VERTICAL = {\n  start: 'top',\n  end: 'bottom',\n};\n\nconst PROP_NAMES_HORIZONTAL = {\n  start: 'left',\n  end: 'right',\n};\n\n/**\n * @polymerMixin\n */\nexport const PositionMixin = (superClass) =>\n  class PositionMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * The element next to which this overlay should be aligned.\n         * The position of the overlay relative to the positionTarget can be adjusted\n         * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`\n         * and `noVerticalOverlap`.\n         */\n        positionTarget: {\n          type: Object,\n          value: null,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether to align the overlay's\n         * left or right side to the target element by default.\n         * Possible values are `start` and `end`.\n         * RTL is taken into account when interpreting the value.\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\n         * the default side defined by this property.\n         */\n        horizontalAlign: {\n          type: String,\n          value: 'start',\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether to align the overlay's\n         * top or bottom side to the target element by default.\n         * Possible values are `top` and `bottom`.\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\n         * the default side defined by this property.\n         */\n        verticalAlign: {\n          type: String,\n          value: 'top',\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\n         * the target element in the x-axis, or be positioned right next to it.\n         */\n        noHorizontalOverlap: {\n          type: Boolean,\n          value: false,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\n         * the target element in the y-axis, or be positioned right above/below it.\n         */\n        noVerticalOverlap: {\n          type: Boolean,\n          value: false,\n        },\n      };\n    }\n\n    static get observers() {\n      return [\n        '__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap)',\n        '__overlayOpenedChanged(opened, positionTarget)',\n      ];\n    }\n\n    constructor() {\n      super();\n\n      this.__onScroll = this.__onScroll.bind(this);\n      this._updatePosition = this._updatePosition.bind(this);\n    }\n\n    /** @protected */\n    connectedCallback() {\n      super.connectedCallback();\n\n      if (this.opened) {\n        this.__addUpdatePositionEventListeners();\n      }\n    }\n\n    /** @protected */\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.__removeUpdatePositionEventListeners();\n    }\n\n    /** @private */\n    __addUpdatePositionEventListeners() {\n      window.addEventListener('resize', this._updatePosition);\n\n      this.__positionTargetAncestorRootNodes = getAncestorRootNodes(this.positionTarget);\n      this.__positionTargetAncestorRootNodes.forEach((node) => {\n        node.addEventListener('scroll', this.__onScroll, true);\n      });\n    }\n\n    /** @private */\n    __removeUpdatePositionEventListeners() {\n      window.removeEventListener('resize', this._updatePosition);\n\n      if (this.__positionTargetAncestorRootNodes) {\n        this.__positionTargetAncestorRootNodes.forEach((node) => {\n          node.removeEventListener('scroll', this.__onScroll, true);\n        });\n        this.__positionTargetAncestorRootNodes = null;\n      }\n    }\n\n    /** @private */\n    __overlayOpenedChanged(opened, positionTarget) {\n      this.__removeUpdatePositionEventListeners();\n\n      if (opened && positionTarget) {\n        this.__addUpdatePositionEventListeners();\n      }\n\n      if (opened) {\n        const computedStyle = getComputedStyle(this);\n        if (!this.__margins) {\n          this.__margins = {};\n          ['top', 'bottom', 'left', 'right'].forEach((propName) => {\n            this.__margins[propName] = parseInt(computedStyle[propName], 10);\n          });\n        }\n        this.setAttribute('dir', computedStyle.direction);\n\n        this._updatePosition();\n        // Schedule another position update (to cover virtual keyboard opening for example)\n        requestAnimationFrame(() => this._updatePosition());\n      }\n    }\n\n    get __isRTL() {\n      return this.getAttribute('dir') === 'rtl';\n    }\n\n    __positionSettingsChanged() {\n      this._updatePosition();\n    }\n\n    /** @private */\n    __onScroll(e) {\n      // If the scroll event occurred inside the overlay, ignore it.\n      if (!this.contains(e.target)) {\n        this._updatePosition();\n      }\n    }\n\n    _updatePosition() {\n      if (!this.positionTarget || !this.opened) {\n        return;\n      }\n\n      const targetRect = this.positionTarget.getBoundingClientRect();\n\n      // Detect the desired alignment and update the layout accordingly\n      const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);\n      this.style.justifyContent = shouldAlignStartVertically ? 'flex-start' : 'flex-end';\n\n      const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, this.__isRTL);\n      const flexStart =\n        (!this.__isRTL && shouldAlignStartHorizontally) || (this.__isRTL && !shouldAlignStartHorizontally);\n      this.style.alignItems = flexStart ? 'flex-start' : 'flex-end';\n\n      // Get the overlay rect after possible overlay alignment changes\n      const overlayRect = this.getBoundingClientRect();\n\n      // Obtain vertical positioning properties\n      const verticalProps = this.__calculatePositionInOneDimension(\n        targetRect,\n        overlayRect,\n        this.noVerticalOverlap,\n        PROP_NAMES_VERTICAL,\n        this,\n        shouldAlignStartVertically,\n      );\n\n      // Obtain horizontal positioning properties\n      const horizontalProps = this.__calculatePositionInOneDimension(\n        targetRect,\n        overlayRect,\n        this.noHorizontalOverlap,\n        PROP_NAMES_HORIZONTAL,\n        this,\n        shouldAlignStartHorizontally,\n      );\n\n      // Apply the positioning properties to the overlay\n      Object.assign(this.style, verticalProps, horizontalProps);\n\n      this.toggleAttribute('bottom-aligned', !shouldAlignStartVertically);\n      this.toggleAttribute('top-aligned', shouldAlignStartVertically);\n\n      this.toggleAttribute('end-aligned', !flexStart);\n      this.toggleAttribute('start-aligned', flexStart);\n    }\n\n    __shouldAlignStartHorizontally(targetRect, rtl) {\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n      // smaller than its current space before the fit-calculations.\n      const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);\n      this.__oldContentWidth = this.$.overlay.offsetWidth;\n\n      const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n      const defaultAlignLeft = (!rtl && this.horizontalAlign === 'start') || (rtl && this.horizontalAlign === 'end');\n\n      return this.__shouldAlignStart(\n        targetRect,\n        contentWidth,\n        viewportWidth,\n        this.__margins,\n        defaultAlignLeft,\n        this.noHorizontalOverlap,\n        PROP_NAMES_HORIZONTAL,\n      );\n    }\n\n    __shouldAlignStartVertically(targetRect) {\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n      // smaller than its current space before the fit-calculations.\n      const contentHeight = Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);\n      this.__oldContentHeight = this.$.overlay.offsetHeight;\n\n      const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n      const defaultAlignTop = this.verticalAlign === 'top';\n\n      return this.__shouldAlignStart(\n        targetRect,\n        contentHeight,\n        viewportHeight,\n        this.__margins,\n        defaultAlignTop,\n        this.noVerticalOverlap,\n        PROP_NAMES_VERTICAL,\n      );\n    }\n\n    // eslint-disable-next-line max-params\n    __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {\n      const spaceForStartAlignment =\n        viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];\n      const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];\n\n      const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;\n      const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;\n\n      const shouldGoToDefaultSide =\n        spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;\n\n      return defaultAlignStart === shouldGoToDefaultSide;\n    }\n\n    /**\n     * Returns an object with CSS position properties to set,\n     * e.g. { top: \"100px\", bottom: \"\" }\n     */\n    // eslint-disable-next-line max-params\n    __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay, shouldAlignStart) {\n      const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;\n      const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;\n\n      const currentValue = parseFloat(overlay.style[cssPropNameToSet] || getComputedStyle(overlay)[cssPropNameToSet]);\n\n      const diff =\n        overlayRect[shouldAlignStart ? propNames.start : propNames.end] -\n        targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];\n\n      return {\n        [cssPropNameToSet]: `${currentValue + diff * (shouldAlignStart ? -1 : 1)}px`,\n        [cssPropNameToClear]: '',\n      };\n    }\n  };\n"],
  "mappings": "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",
  "names": []
}
