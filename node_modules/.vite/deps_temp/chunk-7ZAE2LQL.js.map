{
  "version": 3,
  "sources": ["../../@polymer/polymer/lib/mixins/disable-upgrade-mixin.js"],
  "sourcesContent": ["/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { ElementMixin } from './element-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { wrap } from '../utils/wrap.js';\n\nconst DISABLED_ATTR = 'disable-upgrade';\n\nexport const findObservedAttributesGetter = (ctor) => {\n  while (ctor) {\n    const desc = Object.getOwnPropertyDescriptor(ctor, 'observedAttributes');\n    if (desc) {\n      return desc.get;\n    }\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n  return () => [];\n};\n\n/**\n * Element class mixin that allows the element to boot up in a non-enabled\n * state when the `disable-upgrade` attribute is present. This mixin is\n * designed to be used with element classes like PolymerElement that perform\n * initial startup work when they are first connected. When the\n * `disable-upgrade` attribute is removed, if the element is connected, it\n * boots up and \"enables\" as it otherwise would; if it is not connected, the\n * element boots up when it is next connected.\n *\n * Using `disable-upgrade` with PolymerElement prevents any data propagation\n * to the element, any element DOM from stamping, or any work done in\n * connected/disconnctedCallback from occuring, but it does not prevent work\n * done in the element constructor.\n *\n * Note, this mixin must be applied on top of any element class that\n * itself implements a `connectedCallback` so that it can control the work\n * done in `connectedCallback`. For example,\n *\n *     MyClass = DisableUpgradeMixin(class extends BaseClass {...});\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport const DisableUpgradeMixin = dedupingMixin((base) => {\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const superClass = ElementMixin(base);\n\n  // Work around for closure bug #126934458. Using `super` in a property\n  // getter does not work so instead we search the Base prototype for an\n  // implementation of observedAttributes so that we can override and call\n  // the `super` getter. Note, this is done one time ever because we assume\n  // that `Base` is always comes from `Polymer.LegacyElementMixn`.\n  let observedAttributesGetter = findObservedAttributesGetter(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_DisableUpgradeMixin}\n   */\n  class DisableUpgradeClass extends superClass {\n\n    constructor() {\n      super();\n      /** @type {boolean|undefined} */\n      this.__isUpgradeDisabled;\n    }\n\n    static get observedAttributes() {\n      return observedAttributesGetter.call(this).concat(DISABLED_ATTR);\n    }\n\n    // Prevent element from initializing properties when it's upgrade disabled.\n    /** @override */\n    _initializeProperties() {\n      if (this.hasAttribute(DISABLED_ATTR)) {\n        this.__isUpgradeDisabled = true;\n      } else {\n        super._initializeProperties();\n      }\n    }\n\n    // Prevent element from enabling properties when it's upgrade disabled.\n    // Normally overriding connectedCallback would be enough, but dom-* elements\n    /** @override */\n    _enableProperties() {\n      if (!this.__isUpgradeDisabled) {\n        super._enableProperties();\n      }\n    }\n\n    // If the element starts upgrade-disabled and a property is set for\n    // which an accessor exists, the default should not be applied.\n    // This additional check is needed because defaults are applied via\n    // `_initializeProperties` which is called after initial properties\n    // have been set when the element starts upgrade-disabled.\n    /** @override */\n    _canApplyPropertyDefault(property) {\n      return super._canApplyPropertyDefault(property) &&\n        !(this.__isUpgradeDisabled && this._isPropertyPending(property));\n    }\n\n    /**\n     * @override\n     * @param {string} name Attribute name.\n     * @param {?string} old The previous value for the attribute.\n     * @param {?string} value The new value for the attribute.\n     * @param {?string} namespace The XML namespace for the attribute.\n     * @return {void}\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (name == DISABLED_ATTR) {\n        // When disable-upgrade is removed, initialize properties and\n        // provoke connectedCallback if the element is already connected.\n        if (this.__isUpgradeDisabled && value == null) {\n          super._initializeProperties();\n          this.__isUpgradeDisabled = false;\n          if (wrap(this).isConnected) {\n            super.connectedCallback();\n          }\n        }\n      } else {\n        super.attributeChangedCallback(\n            name, old, value, /** @type {null|string} */ (namespace));\n      }\n    }\n\n    // Prevent element from connecting when it's upgrade disabled.\n    // This prevents user code in `attached` from being called.\n    /** @override */\n    connectedCallback() {\n      if (!this.__isUpgradeDisabled) {\n        super.connectedCallback();\n      }\n    }\n\n    // Prevent element from disconnecting when it's upgrade disabled.\n    // This avoids allowing user code `detached` from being called without a\n    // paired call to `attached`.\n    /** @override */\n    disconnectedCallback() {\n      if (!this.__isUpgradeDisabled) {\n        super.disconnectedCallback();\n      }\n    }\n\n  }\n\n  return DisableUpgradeClass;\n});\n"],
  "mappings": ";;;;;;;;;AAeA,IAAM,gBAAgB;AAEf,IAAM,+BAA+B,CAAC,SAAS;AACpD,SAAO,MAAM;AACX,UAAM,OAAO,OAAO,yBAAyB,MAAM,oBAAoB;AACvE,QAAI,MAAM;AACR,aAAO,KAAK;AAAA,IACd;AACA,WAAO,OAAO,eAAe,KAAK,SAAS,EAAE;AAAA,EAC/C;AACA,SAAO,MAAM,CAAC;AAChB;AA6BO,IAAM,sBAAsB,cAAc,CAAC,SAAS;AAOzD,QAAM,aAAa,aAAa,IAAI;AAOpC,MAAI,2BAA2B,6BAA6B,UAAU;AAOtE,QAAM,4BAA4B,WAAW;AAAA,IAE3C,cAAc;AACZ,YAAM;AAEN,WAAK;AAAA,IACP;AAAA,IAEA,WAAW,qBAAqB;AAC9B,aAAO,yBAAyB,KAAK,IAAI,EAAE,OAAO,aAAa;AAAA,IACjE;AAAA,IAIA,wBAAwB;AACtB,UAAI,KAAK,aAAa,aAAa,GAAG;AACpC,aAAK,sBAAsB;AAAA,MAC7B,OAAO;AACL,cAAM,sBAAsB;AAAA,MAC9B;AAAA,IACF;AAAA,IAKA,oBAAoB;AAClB,UAAI,CAAC,KAAK,qBAAqB;AAC7B,cAAM,kBAAkB;AAAA,MAC1B;AAAA,IACF;AAAA,IAQA,yBAAyB,UAAU;AACjC,aAAO,MAAM,yBAAyB,QAAQ,KAC5C,EAAE,KAAK,uBAAuB,KAAK,mBAAmB,QAAQ;AAAA,IAClE;AAAA,IAUA,yBAAyB,MAAM,KAAK,OAAO,WAAW;AACpD,UAAI,QAAQ,eAAe;AAGzB,YAAI,KAAK,uBAAuB,SAAS,MAAM;AAC7C,gBAAM,sBAAsB;AAC5B,eAAK,sBAAsB;AAC3B,cAAI,KAAK,IAAI,EAAE,aAAa;AAC1B,kBAAM,kBAAkB;AAAA,UAC1B;AAAA,QACF;AAAA,MACF,OAAO;AACL,cAAM;AAAA,UACF;AAAA,UAAM;AAAA,UAAK;AAAA,UAAmC;AAAA,QAAU;AAAA,MAC9D;AAAA,IACF;AAAA,IAKA,oBAAoB;AAClB,UAAI,CAAC,KAAK,qBAAqB;AAC7B,cAAM,kBAAkB;AAAA,MAC1B;AAAA,IACF;AAAA,IAMA,uBAAuB;AACrB,UAAI,CAAC,KAAK,qBAAqB;AAC7B,cAAM,qBAAqB;AAAA,MAC7B;AAAA,IACF;AAAA,EAEF;AAEA,SAAO;AACT,CAAC;",
  "names": []
}
