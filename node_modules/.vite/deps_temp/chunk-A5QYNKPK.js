// node_modules/@polymer/polymer/lib/utils/resolve-url.js
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var ABS_URL = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/;
var workingURL;
var resolveDoc;
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  if (url === "//") {
    return url;
  }
  if (workingURL === void 0) {
    workingURL = false;
    try {
      const u = new URL("b", "http://a");
      u.pathname = "c%20d";
      workingURL = u.href === "http://a/c%20d";
    } catch (e) {
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    try {
      return new URL(url, baseURI).href;
    } catch (e) {
      return url;
    }
  }
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument("temp");
    resolveDoc.base = resolveDoc.createElement("base");
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement("a");
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;
}
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
    return pre + "'" + resolveUrl(url.replace(/["']/g, ""), baseURI) + "'" + post;
  });
}
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf("/") + 1);
}

// node_modules/@polymer/polymer/lib/utils/settings.js
var useShadow = !window.ShadyDOM || !window.ShadyDOM.inUse;
var useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
var useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;
var supportsAdoptingStyleSheets = useShadow && "adoptedStyleSheets" in Document.prototype && "replaceSync" in CSSStyleSheet.prototype && (() => {
  try {
    const sheet = new CSSStyleSheet();
    sheet.replaceSync("");
    const host = document.createElement("div");
    host.attachShadow({ mode: "open" });
    host.shadowRoot.adoptedStyleSheets = [sheet];
    return host.shadowRoot.adoptedStyleSheets[0] === sheet;
  } catch (e) {
    return false;
  }
})();
var rootPath = window.Polymer && window.Polymer.rootPath || pathFromUrl(document.baseURI || window.location.href);
var sanitizeDOMValue = window.Polymer && window.Polymer.sanitizeDOMValue || void 0;
var passiveTouchGestures = window.Polymer && window.Polymer.setPassiveTouchGestures || false;
var strictTemplatePolicy = window.Polymer && window.Polymer.strictTemplatePolicy || false;
var allowTemplateFromDomModule = window.Polymer && window.Polymer.allowTemplateFromDomModule || false;
var legacyOptimizations = window.Polymer && window.Polymer.legacyOptimizations || false;
var legacyWarnings = window.Polymer && window.Polymer.legacyWarnings || false;
var syncInitialRender = window.Polymer && window.Polymer.syncInitialRender || false;
var legacyUndefined = window.Polymer && window.Polymer.legacyUndefined || false;
var orderedComputed = window.Polymer && window.Polymer.orderedComputed || false;
var cancelSyntheticClickEvents = true;
var setCancelSyntheticClickEvents = function(useCancelSyntheticClickEvents) {
  cancelSyntheticClickEvents = useCancelSyntheticClickEvents;
};
var removeNestedTemplates = window.Polymer && window.Polymer.removeNestedTemplates || false;
var fastDomIf = window.Polymer && window.Polymer.fastDomIf || false;
var suppressTemplateNotifications = window.Polymer && window.Polymer.suppressTemplateNotifications || false;
var legacyNoObservedAttributes = window.Polymer && window.Polymer.legacyNoObservedAttributes || false;
var useAdoptedStyleSheetsWithBuiltCSS = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || false;

// node_modules/@polymer/polymer/lib/elements/dom-module.js
var modules = {};
var lcModules = {};
function setModule(id, module) {
  modules[id] = lcModules[id.toLowerCase()] = module;
}
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}
function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector("style")) {
    console.warn("dom-module %s has style outside template", inst.id);
  }
}
var DomModule = class extends HTMLElement {
  static get observedAttributes() {
    return ["id"];
  }
  static import(id, selector) {
    if (id) {
      let m = findModule(id);
      if (m && selector) {
        return m.querySelector(selector);
      }
      return m;
    }
    return null;
  }
  attributeChangedCallback(name, old, value, namespace) {
    if (old !== value) {
      this.register();
    }
  }
  get assetpath() {
    if (!this.__assetpath) {
      const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = resolveUrl(
        this.getAttribute("assetpath") || "",
        owner.baseURI
      );
      this.__assetpath = pathFromUrl(url);
    }
    return this.__assetpath;
  }
  register(id) {
    id = id || this.id;
    if (id) {
      if (strictTemplatePolicy && findModule(id) !== void 0) {
        setModule(id, null);
        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);
      }
      this.id = id;
      setModule(id, this);
      styleOutsideTemplateCheck(this);
    }
  }
};
DomModule.prototype["modules"] = modules;
customElements.define("dom-module", DomModule);

// node_modules/@polymer/polymer/lib/utils/style-gather.js
var MODULE_STYLE_LINK_SELECTOR = "link[rel=import][type~=css]";
var INCLUDE_ATTR = "include";
var SHADY_UNSCOPED_ATTR = "shady-unscoped";
function importModule(moduleId) {
  return DomModule.import(moduleId);
}
function styleForImport(importDoc) {
  let container = importDoc.body ? importDoc.body : importDoc;
  const importCss = resolveCss(
    container.textContent,
    importDoc.baseURI
  );
  const style = document.createElement("style");
  style.textContent = importCss;
  return style;
}
function stylesFromModules(moduleIds) {
  const modules2 = moduleIds.trim().split(/\s+/);
  const styles = [];
  for (let i = 0; i < modules2.length; i++) {
    styles.push(...stylesFromModule(modules2[i]));
  }
  return styles;
}
function stylesFromModule(moduleId) {
  const m = importModule(moduleId);
  if (!m) {
    console.warn("Could not find style data in module named", moduleId);
    return [];
  }
  if (m._styles === void 0) {
    const styles = [];
    styles.push(..._stylesFromModuleImports(m));
    const template = m.querySelector("template");
    if (template) {
      styles.push(...stylesFromTemplate(
        template,
        m.assetpath
      ));
    }
    m._styles = styles;
  }
  return m._styles;
}
function stylesFromTemplate(template, baseURI) {
  if (!template._styles) {
    const styles = [];
    const e$ = template.content.querySelectorAll("style");
    for (let i = 0; i < e$.length; i++) {
      let e = e$[i];
      let include = e.getAttribute(INCLUDE_ATTR);
      if (include) {
        styles.push(...stylesFromModules(include).filter(function(item, index, self) {
          return self.indexOf(item) === index;
        }));
      }
      if (baseURI) {
        e.textContent = resolveCss(e.textContent, baseURI);
      }
      styles.push(e);
    }
    template._styles = styles;
  }
  return template._styles;
}
function stylesFromModuleImports(moduleId) {
  let m = importModule(moduleId);
  return m ? _stylesFromModuleImports(m) : [];
}
function _stylesFromModuleImports(module) {
  const styles = [];
  const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (let i = 0; i < p$.length; i++) {
    let p = p$[i];
    if (p.import) {
      const importDoc = p.import;
      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);
      if (unscoped && !importDoc._unscopedStyle) {
        const style = styleForImport(importDoc);
        style.setAttribute(SHADY_UNSCOPED_ATTR, "");
        importDoc._unscopedStyle = style;
      } else if (!importDoc._style) {
        importDoc._style = styleForImport(importDoc);
      }
      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
    }
  }
  return styles;
}
function cssFromModules(moduleIds) {
  let modules2 = moduleIds.trim().split(/\s+/);
  let cssText = "";
  for (let i = 0; i < modules2.length; i++) {
    cssText += cssFromModule(modules2[i]);
  }
  return cssText;
}
function cssFromModule(moduleId) {
  let m = importModule(moduleId);
  if (m && m._cssText === void 0) {
    let cssText = _cssFromModuleImports(m);
    let t = m.querySelector("template");
    if (t) {
      cssText += cssFromTemplate(
        t,
        m.assetpath
      );
    }
    m._cssText = cssText || null;
  }
  if (!m) {
    console.warn("Could not find style data in module named", moduleId);
  }
  return m && m._cssText || "";
}
function cssFromTemplate(template, baseURI) {
  let cssText = "";
  const e$ = stylesFromTemplate(template, baseURI);
  for (let i = 0; i < e$.length; i++) {
    let e = e$[i];
    if (e.parentNode) {
      e.parentNode.removeChild(e);
    }
    cssText += e.textContent;
  }
  return cssText;
}
function _cssFromModuleImports(module) {
  let cssText = "";
  let styles = _stylesFromModuleImports(module);
  for (let i = 0; i < styles.length; i++) {
    cssText += styles[i].textContent;
  }
  return cssText;
}

export {
  resolveUrl,
  resolveCss,
  pathFromUrl,
  useShadow,
  supportsAdoptingStyleSheets,
  rootPath,
  sanitizeDOMValue,
  passiveTouchGestures,
  strictTemplatePolicy,
  allowTemplateFromDomModule,
  legacyOptimizations,
  legacyWarnings,
  syncInitialRender,
  legacyUndefined,
  orderedComputed,
  cancelSyntheticClickEvents,
  setCancelSyntheticClickEvents,
  removeNestedTemplates,
  fastDomIf,
  suppressTemplateNotifications,
  legacyNoObservedAttributes,
  useAdoptedStyleSheetsWithBuiltCSS,
  DomModule,
  stylesFromTemplate,
  stylesFromModuleImports,
  cssFromModules
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
//# sourceMappingURL=chunk-A5QYNKPK.js.map
