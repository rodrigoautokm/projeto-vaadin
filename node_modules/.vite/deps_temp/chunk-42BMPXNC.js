import {
  InputFieldMixin
} from "./chunk-BIVBC2ID.js";
import {
  PatternMixin
} from "./chunk-3X24PFLT.js";
import {
  inputFieldShared as inputFieldShared2
} from "./chunk-KP6A4WLM.js";
import {
  inputFieldShared
} from "./chunk-VED5C5P5.js";
import {
  LabelledInputController
} from "./chunk-67AQUJJH.js";
import {
  SlotController
} from "./chunk-5765XJOL.js";
import {
  ResizeMixin
} from "./chunk-C2K2GOEG.js";
import {
  ElementMixin
} from "./chunk-PT6BHIKU.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-SPVNJBW3.js";
import {
  css
} from "./chunk-BVJZYYEF.js";
import {
  PolymerElement,
  html
} from "./chunk-ZKSNVHJS.js";

// node_modules/@vaadin/text-area/theme/lumo/vaadin-text-area-styles.js
var textArea = css`
  [part='input-field'],
  [part='input-field'] ::slotted(textarea) {
    height: auto;
    box-sizing: border-box;
  }

  [part='input-field'] {
    /* Equal to the implicit padding in vaadin-text-field */
    padding-top: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    padding-bottom: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    transition: background-color 0.1s;
    line-height: var(--lumo-line-height-s);
  }

  :host(:not([readonly])) [part='input-field']::after {
    display: none;
  }

  :host([readonly]) [part='input-field'] {
    border: 1px dashed var(--lumo-contrast-30pct);
  }

  :host([readonly]) [part='input-field']::after {
    border: none;
  }

  :host(:hover:not([readonly]):not([focused]):not([invalid])) [part='input-field'] {
    background-color: var(--lumo-contrast-20pct);
  }

  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused]):not([invalid])) [part='input-field'] {
      background-color: var(--lumo-contrast-10pct);
    }

    :host(:active:not([readonly]):not([focused])) [part='input-field'] {
      background-color: var(--lumo-contrast-20pct);
    }
  }

  [part='input-field'] ::slotted(textarea) {
    line-height: inherit;
    --_lumo-text-field-overflow-mask-image: none;
  }

  /* Vertically align icon prefix/suffix with the first line of text */
  [part='input-field'] ::slotted(iron-icon),
  [part='input-field'] ::slotted(vaadin-icon) {
    margin-top: calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);
  }
`;
registerStyles("vaadin-text-area", [inputFieldShared, textArea], {
  moduleId: "lumo-text-area"
});

// node_modules/@vaadin/field-base/src/text-area-controller.js
var TextAreaController = class extends SlotController {
  constructor(host, callback) {
    super(
      host,
      "textarea",
      () => document.createElement("textarea"),
      (host2, node) => {
        const value = host2.getAttribute("value");
        if (value) {
          node.value = value;
        }
        const name = host2.getAttribute("name");
        if (name) {
          node.setAttribute("name", name);
        }
        node.id = this.defaultId;
        if (typeof callback === "function") {
          callback(node);
        }
      },
      true
    );
  }
};

// node_modules/@vaadin/text-area/src/vaadin-text-area.js
registerStyles("vaadin-text-area", inputFieldShared2, { moduleId: "vaadin-text-area-styles" });
var TextArea = class extends ResizeMixin(PatternMixin(InputFieldMixin(ThemableMixin(ElementMixin(PolymerElement))))) {
  static get is() {
    return "vaadin-text-area";
  }
  static get template() {
    return html`
      <style>
        :host {
          animation: 1ms vaadin-text-area-appear;
        }

        .vaadin-text-area-container {
          flex: auto;
        }

        /* The label, helper text and the error message should neither grow nor shrink. */
        [part='label'],
        [part='helper-text'],
        [part='error-message'] {
          flex: none;
        }

        [part='input-field'] {
          flex: auto;
          overflow: auto;
          -webkit-overflow-scrolling: touch;
        }

        ::slotted(textarea) {
          -webkit-appearance: none;
          -moz-appearance: none;
          flex: auto;
          overflow: hidden;
          width: 100%;
          height: 100%;
          outline: none;
          resize: none;
          margin: 0;
          padding: 0 0.25em;
          border: 0;
          border-radius: 0;
          min-width: 0;
          font: inherit;
          font-size: 1em;
          line-height: normal;
          color: inherit;
          background-color: transparent;
          /* Disable default invalid style in Firefox */
          box-shadow: none;
        }

        /* Override styles from <vaadin-input-container> */
        [part='input-field'] ::slotted(textarea) {
          align-self: stretch;
          white-space: pre-wrap;
        }

        [part='input-field'] ::slotted(:not(textarea)) {
          align-self: flex-start;
        }

        /* Workaround https://bugzilla.mozilla.org/show_bug.cgi?id=1739079 */
        :host([disabled]) ::slotted(textarea) {
          user-select: none;
        }

        @keyframes vaadin-text-area-appear {
          to {
            opacity: 1;
          }
        }
      </style>

      <div class="vaadin-text-area-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
          on-scroll="__scrollPositionUpdated"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="textarea"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
    `;
  }
  static get properties() {
    return {
      maxlength: {
        type: Number
      },
      minlength: {
        type: Number
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "maxlength", "minlength"];
  }
  static get constraints() {
    return [...super.constraints, "maxlength", "minlength"];
  }
  get clearElement() {
    return this.$.clearButton;
  }
  _onResize() {
    this.__scrollPositionUpdated();
  }
  ready() {
    super.ready();
    this.addController(
      new TextAreaController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this.addEventListener("animationend", this._onAnimationEnd);
    this._inputField = this.shadowRoot.querySelector("[part=input-field]");
    this._inputField.addEventListener("wheel", (e) => {
      const scrollTopBefore = this._inputField.scrollTop;
      this._inputField.scrollTop += e.deltaY;
      if (scrollTopBefore !== this._inputField.scrollTop) {
        e.preventDefault();
        this.__scrollPositionUpdated();
      }
    });
    this._updateHeight();
    this.__scrollPositionUpdated();
  }
  __scrollPositionUpdated() {
    this._inputField.style.setProperty("--_text-area-vertical-scroll-position", "0px");
    this._inputField.style.setProperty("--_text-area-vertical-scroll-position", `${this._inputField.scrollTop}px`);
  }
  _onAnimationEnd(e) {
    if (e.animationName.indexOf("vaadin-text-area-appear") === 0) {
      this._updateHeight();
    }
  }
  _valueChanged(newVal, oldVal) {
    super._valueChanged(newVal, oldVal);
    this._updateHeight();
  }
  _updateHeight() {
    const input = this.inputElement;
    const inputField = this._inputField;
    if (!input || !inputField) {
      return;
    }
    const scrollTop = inputField.scrollTop;
    const valueLength = this.value ? this.value.length : 0;
    if (this._oldValueLength >= valueLength) {
      const inputFieldHeight = getComputedStyle(inputField).height;
      const inputWidth = getComputedStyle(input).width;
      inputField.style.display = "block";
      inputField.style.height = inputFieldHeight;
      input.style.maxWidth = inputWidth;
      input.style.height = "auto";
    }
    this._oldValueLength = valueLength;
    const inputHeight = input.scrollHeight;
    if (inputHeight > input.clientHeight) {
      input.style.height = `${inputHeight}px`;
    }
    input.style.removeProperty("max-width");
    inputField.style.removeProperty("display");
    inputField.style.removeProperty("height");
    inputField.scrollTop = scrollTop;
  }
  checkValidity() {
    if (!super.checkValidity()) {
      return false;
    }
    if (!this.pattern || !this.inputElement.value) {
      return true;
    }
    try {
      const match = this.inputElement.value.match(this.pattern);
      return match ? match[0] === match.input : false;
    } catch (_) {
      return true;
    }
  }
};
customElements.define(TextArea.is, TextArea);

export {
  TextArea
};
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-42BMPXNC.js.map
